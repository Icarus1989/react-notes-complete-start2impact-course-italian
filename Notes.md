Guida React.js Start2Impact

# Prima parte - BEGINNER

## 1. Introduction

Prefazione iniziale e consigli. Requisiti.

## 2. Build a React Info site

• Si imparerà tutto ciò che serve per creare una static page in React.
• Sezione incentrata su sintassi e vocabolario basic di React.
• Prima imparare a pensare in React.
• Si imparerà la differenza fra programmazione declerative e imperative.
• Perché React é così popolare
• Sintassi proprietaria chiamata JSX
• Creazione Custom components
• Styling CSS

## 3. Build a React Info site ! First React

Impostazione React:

- usare CDN per importare React (si supererà questo metodo)
- user CDN per Babel
- Impostare type=text/babel nello script dove si vuole utilizzare React

  <code>
  <!DOCTYPE html>
  <html lang="en">
  	<head>
  		<meta charset="UTF-8" />
  		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
  		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
  		<title>Document</title>
  		<link rel="stylesheet" href="index.css" />
  		<script
  			crossorigin
  			src="https://unpkg.com/react@18/umd/react.development.js"
  		></script>
  		<script
  			crossorigin
  			src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
  		></script>
  		<!-- <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> -->
  		<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  	</head>
  	<body>
  		<h1>Hello, React!</h1>
  		<script src="index.js" type="text/babel"></script>
  	</body>
  </html>
  </code>

- Si potrà allora usare nello script la variabile Globale ReactDOM
  ReactDOM.render() - renderizza qualcosa che sembra molto all'HTML
  <code>ReactDOM.render(<h1>Hello EveryOne!</h1>, document.querySelector("#root"));
  </code>
  così sto scrivendo del **declerative code**.

  Nota: memorizzazione stringa di codice nel tutorial

## 4. Build a React Info Site | First React Practice

Esercizio:

<code>
ReactDOM.render(
	<ul>
		My React List
		<li>One</li>
		<li>Two</li>
	</ul>,
	document.querySelector("#root")
);
</code>

Corretto :white_check_mark:

## 5. Build a React Info Site | Local setup (the quick way)

Setup per localhost (usa Live Server)

## 6. Build a React Info Site | Why React? It's Composable

Perché usare React?
React permette di create codice componibile (composable).
Cosa significa componibile. Immaginare una statua fatta di Lego.
Usare esempio per capire significato di componibile: si uniscono vari pezzi creati utilizzando ReactDOM.render().

Esercizio: creare un Custom Component che restituisca un h1 e renderizzarlo dopo il Custom Component NavBar fornito.
Nota: in index.html importare via CDN Bootstrap

<code>

    function Navbar() {
    	return (
    		<nav className="navbar navbar-expand-lg navbar-light bg-light">
    			<a className="navbar-brand" href="#">
    				Navbar
    			</a>
    			<button
    				className="navbar-toggler"
    				type="button"
    				data-toggle="collapse"
    				data-target="#navbarSupportedContent"
    				aria-controls="navbarSupportedContent"
    				aria-expanded="false"
    				aria-label="Toggle navigation"
    			>
    				<span className="navbar-toggler-icon"></span>
    			</button>

    				<div className="collapse navbar-collapse" id="navbarSupportedContent">
    					<ul className="navbar-nav mr-auto">
    						<li className="nav-item active">
    							<a className="nav-link" href="#">
    								Home <span className="sr-only">(current)</span>
    							</a>
    						</li>
    						<li className="nav-item">
    							<a className="nav-link" href="#">
    								Link
    							</a>
    						</li>
    						<li className="nav-item dropdown">
    							<a
    								className="nav-link dropdown-toggle"
    								href="#"
    								id="navbarDropdown"
    								role="button"
    								data-toggle="dropdown"
    								aria-haspopup="true"
    								aria-expanded="false"
    							>
    								Dropdown
    							</a>
    							<div className="dropdown-menu" aria-labelledby="navbarDropdown">
    								<a className="dropdown-item" href="#">
    									Action
    								</a>
    								<a className="dropdown-item" href="#">
    									Another action
    								</a>
    								<div className="dropdown-divider"></div>
    								<a className="dropdown-item" href="#">
    									Something else here
    								</a>
    							</div>
    						</li>
    						<li className="nav-item">
    							<a className="nav-link disabled" href="#">
    								Disabled
    							</a>
    						</li>
    					</ul>
    					<form className="form-inline my-2 my-lg-0">
    						<input
    							className="form-control mr-sm-2"
    							type="search"
    							placeholder="Search"
    							aria-label="Search"
    						/>
    						<button
    							className="btn btn-outline-success my-2 my-sm-0"
    							type="submit"
    						>
    							Search
    						</button>
    					</form>
    				</div>
    			</nav>
    		);

    }

    function MainContent() {
    return <h1>I'm learning React.js</h1>;
    }

    ReactDOM.render(

    <div>
    <Navbar />
    <MainContent />
    </div>,
    document.querySelector("#root")
    );

</code>

Corretto :white_check_mark:

## 7. Build a React Info Site | Why React? It's Declarative!

I programmi possono essere declerative (dichiarativi) oppure imperative (imperativi):

• quando un programma é declerative possiamo sempicemente dire cosa dovrebbe essere fatto.
"Dimmi cosa dev'essere fatto e mi preoccuperò io dei dettagli su come farlo".

• quando un programma é imperative dobbiamo dire come dovrebbe essere fatta una cosa.
"Descrivimi passo per passo come fare qualcosa e io lo farò".

In JavaScript (Vanilla) per creare un element dobbiamo dire passo per passo come farlo.

Esercizio: ricreare l'element h1 in JavaScript:
• crea h1
• aggiungere contenuto
• dare class "header"
• attaccarlo come child e root

<code>
const h1 = document.createElement("h1");
h1.textContent = "Hello Everyone from JavaScript, an imperative way to program";
h1.classList.add("header");
document.querySelector("#root").append(h1);
</code>

Corretto :white_check_mark:

In React basta una riga di codice:
<code>
ReactDOM.render(<h1 className="header">Hello Everyone from React, a declerative way to program</h1>, document.querySelector("#root"));
</code>

Nota: className nell'HTML non class="header"

Altri due motivi per scegliere React.js possonon essere é una skill molto ricercata e che viene mantenuto attivamente aggiornato da persone competenti, visto che appartiene a FB.

## 8. Build a React Info Site | JSX

• Nei primi tempi di React.js venne creato JSX JavaScriptXML.
• E' come una fraganza di JavaScript che assomiglia molto ad HTML.
• E' questa particolare sintassi che ha reso React così declerative rispetto al puro JavaScript.
• Per la maggior parte del codice scriveremo comunque l'HTML che siamo abituati ad usare, anche se con piccole differenze (vedi class sostituito da className)
• per notare le differenze tra un element creato con JavaScript ed uno creato con JSX passiamo all'analisi del codice tramite console.log

JS:
<code>
const h1 = document.createElement("h1");
h1.textContent = "Hello Everyone from JavaScript, an imperative way to program";
h1.classList.add("header");
document.querySelector("#root").append(h1);
console.log(h1);
</code>
Risulterà:

<!-- <h1 class="header">Hello Everyone from JavaScript, an imperative way to program</h1> -->

JSX:
<code>
const element = <h1 className="header">This is JSX</h1>;
console.log(element);
ReactDOM.render(element, document.querySelector("#root"));
</code>
Risulterà:
{$$typeof: Symbol(react.element), type: 'h1', key: null, ref: null, props: {…}, …}

• L'object riflette l'element che vogliomo che React renderizzi sulla nostra pagina

• Questo avrà delle proprietà similari all'element HTML precende come props, che ha all'interno className : "header" e children : "This is JSX"

JSX é come una funzione che quando si esegue restituisce objects che React.js puuò interpretare ed effettivamente usare per creare elements e inserirli nello schermo per noi.

Non si possono combinare direttamente due elements HTML nella stesso metodo ReactDOM.render. Per esempio non si può

<!-- ReactDOM.render(<h1></h1><p></p>, document.querySelector...) -->

Per farlo in questo modo occorre avvolgere i due elements in un parent come per esempio un div.
<code>
ReactDOM.render(

<div>
<h1>This is JSX</h1>
<p>This is a paragraph</p>
</div>,
document.querySelector("#root")
);
</code>

Non importa quanti siano i children elements all'interno, basta che venga renderizzato un solo parent, in questo caso div.

Esercizio:
Posso salvare l'intero parent all'interno di una variabile come:
<code>
const page = (

<div>
<h1>This is JSX</h1>
<p>This is a paragraph</p>
</div>
);

ReactDOM.render(page, document.querySelector("#root"));
</code>

Corretto :white_check_mark:

• Utilizzando il console.log vedremo che risulterà ancora un JavaScript object con all'interno un element (div) che sarà un array con due elements al suo interno (h1 e p).

Challange:

Crea una navbar in JSX:
• Usa l'element semantico nav come parent wrapper
<code>
const navbar = (

<nav>
<h1>My Bistro Website</h1>
<ul>
<li>Pricing</li>
<li>About</li>
<li>Contact</li>
</ul>
</nav>
);

ReactDOM.render(navbar, document.querySelector("#root"));
</code>

Corretto :white_check_mark:

## 9. Build a React Info Site | Goodbye, CDNs

• Uso di import React from 'react'

## 10. Build a React Info Site | Thought Experiment

Test veloce con append usando:

<code>
const page = (
	<div>
		<h1>My awesome website in React</h1>
		<h3>Reasons I love React</h3>
		<ol>
			<li>It's Composable</li>
			<li>It's Declerative</li>
			<li>It's hireable skill</li>
			<li>It's actively maintained by skilled people</li>
		</ol>
	</div>
);

const root = document.querySelector('#root');
root.append(JSON.stringify(page));
</code>

Se usassimo il metodo append come in JS per attaccare del JSX alla root della pagina otterremmo come risultato visualizzato:
[object Object]

JSX infatti restituisce dei plain JavaScript objects, non viene quindi riconosciuto dal DOM che restituisce quanto visto.

Da qui la necessità di utilizzare React.render che esamina il contenuto e lo renderizza come pagina web, facendolo interpretare al browser nel modo corretto.

Il tutorial a questo punto non usa più ReactDOM.render dalla CDN
Utilizzando ReactDOM.render
<code>
ReactDOM.render(page, root);
</code>

Da tutorial differenza ricordare import ReactDOM from...

## 10.5. Update Version 18

Aggiornamento versione 18 React che consista nella differenza nella root. Si usa infatti un nuovo metodo createRoot.

import ReactDOM from "react-dom"
diventerà:
import ReactDOM from "react-dom/client"

Usando ReactDOM.render(navbar, document.querySelector('#root'))
non si passerà più il secondo parametro in questo modo ma da variabile con

ReactDOM.createRoot(document.querySelector('#root')).render(navbar)

o meglio:

const root = ReactDOM.createRoot(document.querySelector('#root'));
root.render(navbar);

## 11. Build a React Info Site | Project 1 Part 1 - MarkUp

Challange: creare l'HTML per la section project.

Corretto :white_check_mark:

Nota: non funziona style:"40px" ma ok width:"40px"

## 12. Build a React Info Site | Pop Quiz!

Test:

1- Per poter utilizzare ReactDOM.render (v.17) ReactDOM.createRoot() e tutti gli altri metodi oltre ad abilitare JSX

Corretto :white_check_mark:

2- [object Object] - Elements che lo compongono

Corretto :white_check_mark:

3- Tutti gli elements renderizzati devono essere all'interno di un parent Element, nel nostro caso un div. Non possono essere renderizzati due sibling elements.

NOTA: si possono usare dei tag vuoti, definiti Fragments, per inglobare i vari elements (<>.......</>)

Corretto :white_check_mark:

4- Declarative significa che dico cosa compiere al codice e lui trova un modo per farlo senza indicare passo passo cosa fare, Imperative significa che do una lista di comandi tramite codice e vengono eseguiti, come in Javascript.

Nota: differenza tra "preparami un panino" e prendi il pane, il prosciutto ecc ecc passo per passo.

Nota: Declerative da un esperienza migliore programmando generando anche meno errori.

Corretto :white_check_mark:

5- Che possono essere attaccati vari piccoli pezzi (elements) come nel caso di ReactDOM.render:
<code>
ReactDOM.render(

<div>
	<Navbar />
	<MainContent />
</div>,
document.querySelector("#root")
);
<code>

Corretto :white_check_mark:

## 13. Build a React Info Site | Custom Components

Quando diciamo che la composibility é uno dei maggiori benefici (pregi) di React parliamo della possibilità in React di creare i nostri Custom Components.

Più grandi diventano gli elements più difficili diventano da mantenere e non diventano riutilizzabili

Come per le funzioni che si richiamano più e più volte in JavaScript così React applica lo stesso concetto per creare gli elements e renderli riutilizzabili.

<code>
function temporaryName() {
	return (
		<div>
			<img src="./react-logo.png" width="40px" />
			<h1>Fun facts about React</h1>
			<ul>
				<li>Was First released in 2013</li>
				<li>Was originally created by Jordan Walke</li>
				<li>Has well 100K stars on GitHub</li>
				<li>Is maintained by Meta</li>
				<li>Powers thousands of enterprise apps, including mobile apps</li>
			</ul>
		</div>
	);
}
</code>

Questo, una funzione che restituisce degli elements, viene definito un "Component".
Occorre però usare un paio di convenzioni per indicarlo correttamente:

• si usi il PascalCase invece che il camelCase, cioé in maiuscolo la prima lettera di una parola, fin dalla prima parola.
• nel metodo render la chiamata della funzione non viene effettuata con temporaryName() ma con <TemporaryName />
<code>
function TemporaryName() {
return (

<div>
	<img src="./react-logo.png" width="40px" />
	<h1>Fun facts about React</h1>
		<ul>
			<li>Was First released in 2013</li>
			<li>Was originally created by Jordan Walke</li>
			<li>Has well 100K stars on GitHub</li>
			<li>Is maintained by Meta</li>
			<li>Powers thousands of enterprise apps, including mobile apps</li>
		</ul>
</div>
);
}

root.render(<TemporaryName />);

</code>

Ricorda import
Challange

Risultato:
Corretto :white_check_mark:

## 14. Build a React Info Site | Custom Components Part 2

Challange
Risultato (troppo avanti ;) ):
Diverso da tutorial, blocco unico

## 15. Build a React Info Site | Custom Components Quiz

NOTA: RIPASSARE QUESTO PER SICUREZZA

1- E' un element creato da una funzione che restituisce un element HTML che viene poi renderizzato da ReactDOM creando un React Element, cioé un regular JS object

Corretto :white_check_mark:

2- Il nome dev'essere in Pascal Case, forse meglio inglobare in un div ma indifferente.

Corretto :white_check_mark:

3- Non si vedeva, nullo
Dicitura corretta di <code><Header /></code>

## 16. Build a React Info Site | Parent/Child Components

Non é mai una buona idea mettere tutti gli elements in un solo Component, quindi capiamo come creare dei Parent e Child Components.

Mini Challange 1:

Risultato:
Corretto :white_check_mark:

<!-- function Header() {
	return (
		<header>
			<nav>
				<img src="./react-logo.png" width="40px" />
			</nav>
		</header>
	);
}

function Page() {
	return (
		<div>
			<Header />
			<h1>Reason why a I love Learn React</h1>
			<ol>
				<li>Want to Create Magical Web Apps</li>
				<li>Want to Create Native Apps for iOS Environment</li>
			</ol>
			<small>
				<footer>© 2022 Alex development. All rightsa reserved.</footer>
			</small>
		</div>
	);
}

const root = ReactDOM.createRoot(document.querySelector("#root"));
root.render(<Page />); -->

<!-- const root = ReactDOM.createRoot(document.querySelector("#root"));
root.render(<Page />); -->

Spiegazione:

Come creo un istanza di Page per essere renderizzata nel metodo root.render(<Page />), allo stesso modo posso creare un istanza di Header all'interno della funzione Page.

NOTA: Questo é esattamente il concetto di composability messo in pratica.
Inoltre ogni volta che voglio reinserire un component nell'UI basta solamente che io crei un istanza di quel component nella pagina.

Mini Challange 2:

<!-- function Header() {
	return (
		<header>
			<nav>
				<img src="./react-logo.png" width="40px" />
			</nav>
		</header>
	);
}

function MainComponent() {
	return (
		<div>
			<h1>Reason why a I love Learn React</h1>
			<ol>
				<li>Want to Create Magical Web Apps</li>
				<li>Want to Create Native Apps for iOS Environment</li>
			</ol>
		</div>
	);
}

function Footer() {
	return (
		<footer>
			<small>© 2022 Alex development. All rightsa reserved.</small>
		</footer>
	);
}

function Page() {
	return (
		<div>
			<Header />
			<MainComponent />
			<Footer />
		</div>
	);
}

const root = ReactDOM.createRoot(document.querySelector("#root"));
root.render(<Page />); -->

Risultato:
Corretto :white_check_mark:

Nota: Nel caso della funzione MainContent il div é l'element parent mentre h1 e ol sono gli elements children.

## 17. Build a React Info Site | Styling with Classes

Mini challange:
Corretto :white_check_mark:

Aggiungere dello style con delle classi é semplice. L'unica differenza al momento é che invece di usare class="..." si usa className. Questo perché con JSX creiamo dei plain JavaScript objects quindi utilizzando il metodo className possiamo dare agli elements delle classi per lo style associate.

<!-- function Header() {
	return (
		<header>
			<nav>
				<img src="./react-logo.png" width="40px" />
				<ul className="nav-items">
					<li>Pricing</li>
					<li>About</li>
					<li>Contact</li>
				</ul>
			</nav>
		</header>
	);
} -->

Mini challange:
Corretto :white_check_mark:

Styling Elements :white_check_mark:

## 18. Build a React Info Site | Organize Components

Vi sono molti modi per organizzare i progetti.
Imparemo qui i principi e durante il corso se ne vedranno svariati.

Separeremo quindi in file i vari components.
Attenzione al naming. Per esempio Header.js per il component Header.

Test cose necessarie per la separazione: export nel file del component, import nel file principale.
Parzialmente corretto :white_check_mark:
Occorre anche import di React.
Non necessario per React v > 17

Una volta fatto questo non occorrerà altro.

Challange:
Creare Footer.js e MainContent.js e connetterli correttamente.

Corretto :white_check_mark:
Prova non possible.

## 19. Build a React Info Site | Setup a local React environment with Create React App

Babel non funziona a lungo se vogliamo creare un'app più complessa.
Occorre utilizzare un package chiamato Create React App in modo da poter utilizzare un pacchetto già creato con bundler e transpiler (Webpack e Babel) impostati già funzionanti.

Node.js e Npm necessari.

Creazione App con tutti i file funzionanti, ricorda sempre import per immagini e altri file, import per script e file css.
Corretto :white_check_mark:

## 20. Build a React Info Site | Style and Images with Create React App

Dettaglio nel caricamento CSS e images con import (vedi insegnamenti webpack)

## 21. Build a React Info Site | Quick Mental outline of project

Mini Challange:
Immaginare elements necessari per il project:

• root - color white
•• navbar - display flex con align content spacebetween?
(da sinistra)
••• img
••• h3 - color light blue fontsize fontweight
••• h4
•• main ( main content ) -
(dall'alto)
••• h1 fontsize
••• ul colorliststyle
•••• li x 5

Corretto :white_check_mark:

Cominciamo a capire che ci servono quindi due Custom Components: un nav ed un main inseriti in un Custom Component principale formato da un div con class container (di solito chiamato App) inserito nel root element principale usato con root.render.

## 22. Build a React Info Site | Quick Figma Walkthrough

Vedere video Intro to Figma for Developers
:white_check_mark:

## 23. Build a React Info Site | Project Setup

Challange:
Seguire istruzioni e creare primi file.
Corretto :white_check_mark:

## 24. Builld a React Info Site | Navbar and Styling

Challange:
Creare navbar osservando il design di Figma e creando i components.
Corretto :white_check_mark:

## 25. Build a React Info Site | Main Section

Challange:
Creare main osservando il design di Figma e creando i components, unica nota non inserire style dei points e immagine logo sullo sfondo.

Corretto :white_check_mark:
Piccoli dettagli imprecisi nel CSS.

## 26. Build a React Info Site | Color the bullets

Per colorare ed ingrandire i bullets della lista, possiamo usare la nuova property CSS (chiamata sudo property?) ::marker.

Impostando quindi font-size 1.4rem e color corretto si otterrà il risultato desiderato.

## 27. Build a React Info Site | Add background logo

Challange:
Aggiungere background-image con logo di React a metà pagina.
Corretto :white_check_mark:

## 28. Build a React Info Site | Section 1 Solo Project

Challange:
Costruire il progetto Digital Business Card.
Corretto :white_check_mark:

## 29. Build a React Info Site | Section 1 Recap

• Why React?
•• Composable e Declerative definizioni
• JSX
•• Scrittura HTML in JavaScript
• Styling

## 1. Build an AirBnb Experiences Clone | Section Intro & Figma File

Creazione clone Airbnb experiences.
Concetti che si impareranno:

• Props in React.js - uno dei maggiori argomenti in React.js che permette di creare Components riusabili e composable. Si copriranno i concetti e la sintassi dei Props.

• Creating components from an array of data - questo ci permetterà di creare i nostri design senza il bisogno di aggiungere dati manualmente ogni volta che i dati cambiano.

Secondary Challange:
Corretto :white_check_mark:

## 2. Build an AirBnb Experiences Clone | Project Setup: NavBar

Challange:
Crezione NavBar con Logo.
Corretto :white_check_mark:

## 3. Build an AirBnb Experiences Clone | Project Setup: Hero

Challange:
Crezione Hero Section - Gruppo Immagini - Titolo - Testo
Attenzione naming - valutare se cambiare stile no camelCase
Attenzione display diverso, usa flex. Valutare se cambiare o no.
Corretto :white_check_mark:

## 4. Build an AirBnb Experiences Clone | project Card Component

Challange:
Creare una singola instanza del component Card ed il component Card.
Corretto :white_check_mark:
Osservare limitazioni nell'hard coding dei dati.

## 5. Build an AirBnb Experiences Clone | Problem - Not Reusable

Per riutilizzare parti del codice vengono in aiuto i props.

<code>

export default function Card(props) {
return (

    <div className="card">
    	<img src={image} className="cardImg" />
    	<div className="cardStats">
    		<img src={starIcon} className="cardStarIcon" />
    		<span className="cardRank">5.0</span>
    		<span className="cardRankNum grayText">(6) • </span>
    		<span className="cardLocation grayText">USA</span>
    	</div>
    <p className="cardDescription">Life lessons with Katie Zaferes</p>
    <p className="cardCost">
    	<span className="boldText">From $136</span> / person
    </p>
    </div>
    );

}

</code>

## 6. Build an AirBnb Experiences Clone | Props Part 1: Understanding the concept

Partendo dal semplice codice:

<code>

<html>
	<head></head>
	<body>
		<a></a>
		<img />
		<input />
	</body>
</html>

</code>

Possiamo notare che mancano gli attributes href nel anchor tag "a" e src nel tag "img".
Senza questi atrributes questi tag sono essenzialmente inutili.
Il tag input é visibile anche senza attributes ma aggiungendoli possiamo usarlo in modi migliori.

<code>

<html>
	<head></head>
	<body>
		<a href="www.google.com">This is a link</a>
		<img src="" />
		<input placeholder="First Name"/>
    </body>

</html>

</code>

Passiamo ora ad un esempio similare in JavaScript.
<code>
function addTwoNumbers(){
return 1 + 2;
}
</code>
Challange:
Cosa non va nella funzione?
Somma sempre 1 e 2, i dati sono hard coded (preimpostati / fissi).
Corretto :white_check_mark:

Aggiungendo due parametri possiamo rendere utile la funzione:
<code>
function addTwoNumbers(a, b){
return a + b;
}
</code>

Come visto sia nell'esempio HTML che nella funzione JavaScript, aggiungere dei parametri ci permette di rendere riutilizzabili in moltepolici modi i nostri elememts o funzioni.

## 7. Build an AirBnb Experiences Clone | Props Part 2: Reusable Components

Si figuri la home page di YouTube dove tutti i video sono predentati con la stessa struttura che si ripete.

Questo significa che un component, per esempio una video card, é stato reso abbastanza flessibile da prendere come property l'immagine, il titolo, il numero di visualizzazioni ecc.
Questi components riusabili possono essere anche inseriti a loro volta in altri components come delle video list.

## 8. Build an AirBnb Experiences Clone | Aside: JS inside JSX

Avendo un component e volendo inserivi del codice JavaScript, si può agire come per le img già usate.
Se voglio per esempio inserire il valore di una variabile all'intero di un h1 posso includere quella value usando delle parentesi grafe:

<code>
export default function App(){
	const firtname = "Joe"
	const lastname = "Schmoe"

    return (
    	<h1>Hello {firstname} {lastname}</h1>
    )

}
</code>

Challange:
Completa l'esempio dell'h1 in modo che sia funzionante.
<code>
export default function App() {
const firstname = "Alex";
const lastname = "Valente";

    return (
    	<div className="container">
    		<h1>
    			Hello {firstname} {lastname}!
    		</h1>
    		<Navbar />
    		<HeroSection />
    		<Card />
    	</div>
    );

}
</code>
Corretto :white_check_mark:

Possiamo considerare le parentesi grafe come il passaggio temporaneo dalla JSX land alla JS land. Tutto all'interno delle parentesi grafe sarà considerato JavaScript ed interpretato come tale.

Possiamo quindi avanzare con l'esempio:
<code>
export default function App() {
const date = new Date();
const hours = date.getHours() % 12;

    return (
    	<div className="container">
    		<h1>It's about {hours}!</h1>
    		<Navbar />
    		<HeroSection />
    		<Card />
    	</div>
    );

}
</code>

Questo ci permette anche di separare la logica che il component andrà ad eseguire dal component stesso che verrà visualizzato.

Challange:
Modifica il codice del component in modo che visualizzi il risultato ottenuto dal codice fornito per ottenere morning, afternoon ed evening.

<code>
export default function App() {
	const date = new Date();
	const hours = date.getHours();

    let timeOfDay;

    if (hours < 12) {
    	timeOfDay = "morning";
    } else if (hours > 12 && hours < 17) {
    	timeOfDay = "afternoon";
    } else {
    	timeOfDay = "evening";
    }

    return (
    	<div className="container">
    		<h1>Good {timeOfDay}!</h1>
    		<Navbar />
    		<HeroSection />
    		<Card />
    	</div>
    );

}
</code>

Corretto :white_check_mark:

## 9. Build an AirBnb Experiences Clone | Props Part 3: Create a contact component

Challange:
Creare component contact-card in Contact.js e quattro istanze di questa in App.js
Qual'é il problema che si riscontra con i dati hard coded?
Soluzione prima della creazione: le quattro cards sono uguali chiaramente.

Corretto :white_check_mark:

Come per la funzione in JavaScript vista in precedenza anche qui abbiamo bisogno di passare dei dati.
Effettuato in modo similare agli attributes in HTML.

Qui viene mostrato come passare i dati al component, più avanti come utilizzare i dati passati al component.

In App.js
<code>
return (

    <div className="container">
    		<h1>Good {timeOfDay}!</h1>
    		<Contact />
    		<Contact />
    		<Contact />
    		<Contact />
    		<Navbar />
    		<HeroSection />
    		<Card />
    </div>

);
</code>

per passare i dati al component Contact:

<code>

return (

<div className="container">
<h1>Good {timeOfDay}!</h1>
<Contact
							img=""
							name="Mr.Whiskerson"
							phone="000-0000-00"
							email="mr.whiskaz@catnap.meow"
						/>
<Contact
							img=""
							name="Fluffykins"
							phone="000-0000-01"
							email="fluffme.com"
						/>
<Contact
							img=""
							name="Felix"
							phone="000-0000-02"
							email="thecat@hotmail.com"
						/>
<Contact
							img=""
							name="Pumpkin"
							phone="000-0000-03"
							email="pumpkin@scrimba.com"
						/>
<Navbar />
<HeroSection />
<Card />
</div>
);
</code>

Al momento senza comunque gestire i dati in entrata le quattro cards rimangono identiche.

## 10. Build an AirBnb Experiences Clone | Props Part 4: receving props in a component

In React.js gli attributes assegnati ai components come...
<code>
<Contact
				img=""
				name="Mr.Whiskerson"
				phone="000-0000-00"
				email="mr.whiskaz@catnap.meow"
			/>
</code>
...non vengono chiamati attributes ma properties (o props).
Ora dopo aver creato le varie props nelle istanze, utilizziamo i dati passati nelle nostre funzioni.
Diamo un paramenter con il nome che vogliamo, in questo caso "props", alla funzione che crea il nostro component:
<code>

export default function Contact(props) {
console.log(props);
return (

<div className="contact-card">
<img src="" />
<h3>Mr.Whiskerson</h3>
<div className="info-group">
<img src="" />
<p>000-0000-00</p>
</div>
<div className="info-group">
<img src="" />
<p>mr.whiskaz@catnap.meow</p>
</div>
</div>
);
}

</code>

Otteniamo così degli Objects con le varie proprietà, come i params nelle API di Node.js. Ogni proprietà degli objects ricalcherà le props dichiarate nelle istanze del component Contact.

Challange:
Perché otteniamo 4 Objects con properties differenti?
Perché abbiamo 4 istanze del component Contact.
Corretto :white_check_mark:

Nota: i nomi scelti per le props nelle istanze non sono fissi, si può cambiare il nome a scelta.

Challange:
Usare le props per creare le quattro istanze del component Contact con i dati diversi l'una dall'altra.
Soluzione:
<code>
export default function Contact(props) {
console.log(props);
return (

<div className="contact-card">
<img src={props.img} />
<h3>{props.name}</h3>
<div className="info-group">
<img src="" />
<p>{props.phone}</p>
</div>
<div className="info-group">
<img src="" />
<p>{props.email}</p>
</div>
</div>
);
}
</code>

Corretto :white_check_mark:

Challange:
Bug sull'immagine, come risolvere?
import per importare l'immagine.
No, era il nome errato nell'esempio presentato, piccolo trucco, maggiore attenzione.
La tecnica comunque é funzionante.

## 11. Build an AirBnb Experiences Clone | Prop Quiz (Get it?)

1- Le props ci aiutano a passare dei dati che possono mutare ad ogni istanza ai components, quindi a rendere i Components più riusabili.
Corretto :white_check_mark:

2- Attraverso una struttura molto simile agli attributes in HTML nell'istanza del component, e attraverso il parametro props nella funzione che crea il component stesso.
Corretto :white_check_mark:

3- No, ogni DOM element ha degli attributes specifici, crearne uno di personalizzato non garantirebbe il risultato.
Corretto :white_check_mark:

4- Utilizzando il paramentro "props" nella dichiarazione della funzione, che sarà un Object di cui posso usare le proprietà.
<code>
function Navbar(props){
return (
<code>

<header>
<img src={props.img}>
</header>
)
}
</code>
Corretto :white_check_mark:

5- Le Props sono Objects.
Corretto :white_check_mark:

## 12. Build an AirBnb Experiences Clone | Destructuring Props

Il destructuring di un object, ripasso.
Partendo da un object come può essere:
<code>

    const person = {
    	img: "",
    	name: "Alex",
    	lastname: "Valente",
    	email: "one@one.com"
    }

</code>

Possiamo assegnare a delle variabili le values delle properties di quest'object con:

<code>

    const {img, name} = person;
    console.log(name) => "Alex"

</code>

E' una cosa comune applicare questa tecnica con le props che si ricevono.
"props" sarà un Object che rappresenta tutte le props che si riceveranno nella funzione di creazione del Component:

<code>
export default function Contact(props) {
	console.log(props);
	return (
		<div className="contact-card">
			<img src={props.img} />
			<h3>{props.name}</h3>
			<div className="info-group">
				<img src="" />
				<p>{props.phone}</p>
			</div>
			<div className="info-group">
				<img src="" />
				<p>{props.email}</p>
			</div>
		</div>
	);
}
</code>

Per il destructuring é importante mantenere gli stessi name delle props fornite, oppure usare {img : image, name,...}, ma é preferibile mantenerli, {img, name, lastname, phone, email...}.

Challange:
Destrutturare la props e modificare il codice del Component in modo che funzioni.

<code>
export default function Contact({ img, name, phone, email }) {
	return (
		<div className="contact-card">
			<img src={img} />
			<h3>{name}</h3>
			<div className="info-group">
				<img src="" />
				<p>{phone}</p>
			</div>
			<div className="info-group">
				<img src="" />
				<p>{email}</p>
			</div>
		</div>
	);
}
</code>

Corretto :white_check_mark:

E' una pratica comune destrutturare le props, quindi é molto facile imbattersi in codici che eseguono tale pratica.

Utilizzare le props non destrutturate, quindi usare le proprietà di tale Object (i.e. props.name), rende però più chiaro il codice se vi é la necessità di utilizzare altre variabili all'interno del codice del Component.

## 13. Build an AirBnb Experiences Clone | Props Practice

Challange:
Creare from scratch app e impostare Joke component per fare pratica con le props.
Corretto :white_check_mark:

Extra Challange:
Come fare se non esiste una delle due props? In questo caso setup.
Utilizzato || all'interno del Component nel gruppo di parentesi grafe interessato {}
Quasi

Prima domanda durante la spiegazione: Non cambia niente
Corretto :white_check_mark:

Seconda domanda durante la spiegazione: Perché abbiamo 5 istanze del Component Joke.
Corretto :white_check_mark:

Terza domanda durante la spiegazione: Usando all'interno di h3 (parte del testo) delle parentesi grafe con {props.setup} e {props.punchline}.
Corretto :white_check_mark:

Soluzione Extra Challange:
Utilizzare un condizionale con all'interno l'element:
<code>
export default function Joke(props) {
return (

<div>
	<h1>Joke:</h1>
	{props.setup && <h3>{props.setup}</h3>}
	<p>{props.punchline}</p>
	<hr />
</div>
);

}
</code>
Così facendo se la props.setup non esite non verrà renderizzato il corrispondente element h3.

Un'altra soluzione possibile:
<code>
export default function Joke(props) {
return (

<div>
	<h1>Joke:</h1>
	<h3 style={{display:props.setup ? "block" : "none"}}>{props.setup}</h3>
	<p>{props.punchline}</p>
	<hr />
</div>
);

}
</code>

## 14. Build an AirBnb Experiences Clone | Passing in non-string Props

Negli attributes degli elements HTML passiamo solamente delle strings. Ma in React non siamo limitati a questo type.

Challange: come passare altri types di dati come props al component venendo poi analizzati correttamente?
Risposta: includendo tali dati in {}, per esempio:
<code>

<Joke
upvotes={15}
downvotes={2}
isPun={true}
comments={["one", "two", "three"]}
setup="I got my daughter a fridge for her birthday."
punchline="I can't wait to see her face light up when she opens it."
/>

</code>

Corretto :white_check_mark:

I dati all'interno delle curly braces possono essere quanto complessi vogliamo e persino JavaScript expressions che calcolano il valore al momento della creazione del Component.

## 15. Build an AirBnb Experiences Clone | Project: Pass props to card component

Challange:
Modificare la Card di Airbnb utilizzando le props per i dati.
<code>

export default function Card(props) {
return (

    	<div className="card">
    		<img src={props.img} className="cardImg" />
    		<div className="cardStats">
    			<img src={starIcon} className="cardStarIcon" />
    			<span className="cardRank">{props.rating}</span>
    			<span className="cardRankNum grayText">({props.reviewCount}) • </span>
    			<span className="cardLocation grayText">{props.country}</span>
    		</div>
    	<p className="cardDescription">{props.title}</p>
    	<p className="cardCost">
    		<span className="boldText">From ${props.price}</span> / person
    	</p>
    	</div>
    );

}

</code>

NOTA: per utilizzare in file JSX i backticks di JavaScript ES6 occorre avvolgerle in delle parentesi grafe {`../images/${props.img}`}

Corretto :white_check_mark:

## 16. Build an AirBnb Experiences Clone | Review - Array.map()

Challanges Array.map

1- Con...

<code>
	const nums = [1, 2, 3, 4, 5];
</code>

...ottenere un array di quadrati dei numeri presenti.

<code>
	const squared = nums.map((num) => num \* num);
</code>

Corretto :white_check_mark:

2- Con...

<code>
	const names = ["alice", "bob", "charlie", "danielle"];
</code>

...ottenere un array di parole con lettera iniziale maiuscola.

<code>

    const capitalNames = names.map((name) => {
    return `${name[0].toUpperCase()}${name.slice(1)}`;
    });+

</code>

Corretto :white_check_mark:

3- Con...
<code>
const pokemons = ["Bulbasaur", "Charmender", "Squirtle"];

</code>
...applicare ad ogni element dell'array i tag <p> e </p>.
Attenzione Consegna imprecisa.
<code>
const tags = pokemons.map((pokemon) => {
		return `<p>${pokemon}</p>`;
	});
</code>

Corretto :white_check_mark:

Da tutorial: Il vantaggio di usare map é che gestisce il for loop al posto nostro.

## 17. Build an AirBnb Experiences Clone | React renders Array

Si può passare all'interno dell'element principale renderizzato div un array invece che solamente dei Components singoli renderizzati. Sempre usando le parentesi grafe { }.

Challange:
Renderizza un array composto da Components.
Corretto :white_check_mark:

## 18. Build an AirBnb Experiences Clone | Mapping Components

Cominciando dal progetto Jokes, modifichiamolo creando il file jokesData.js che sarà molto similare alle future possibili risposte ottenute da un API.

Importiamo il file nel file App.js.

Uniamo quindi quanto imparato sopra e creaimo una variabile jokeElements che sarà un array ottenuto dal map di jokeData.

Challange:
Renderizza gli elements creati dal mapping array con le corrette props.
Soluzione:
<code>
export default function App() {
const jokeElements = jokesData.map((joke) => {
return <Joke setup={joke.setup} punchline={joke.punchline} />;
});
return <div className="container">{jokeElements}</div>;
}
</code>

Corretto :white_check_mark:

## 19. Build an AirBnb Experiences Clone | Map Quiz

1- Agendo sul loop event applica determinate condizioni a tutti gli elements di un array creando un nuovo array.
Corretto :white_check_mark:

2- Per creare una serie di Components simili, con la stessa base, ma con props variabili.

SBAGLIATO.
Converte un array di dati grezzi in un array di elements JSX che possono essere visualizzati sulla pagina.

3- Perché permette un codice più corto creando una singola volta il Component poi replicato grazie appunto a map invece che singolarmente.
Corretto :white_check_mark:
Rende il nostro codice più self-sustainable non richiedendo codice addizionale al cambiamento dei dati.

## 20. Build an AirBnb Experiences Clone | Loading images from .map()

Per far funzionare il caricamento delle images correttamente con Create React App inserire la cartella images in /public.

## 21. Build an AirBnb Experiences Clone | Project: Map experiences data into Components

Challange:
Importare l'array di dati da data.js
Usare map sull'array di dati per creare i Components Card
Visualizzare l'array di Cards Components sotto la Navbar al posto del Card Component corrente

Attenzione: tecnica suggerita in #20 non funziona!!!

Corretto :white_check_mark:

## 22. Build an AirBnb Experiences Clone | Project: Key Prop

Per lo style include l'Array in un section element e lo fa diventare un contenitore flex.

Cosa da notare: lavorando in questo modo se vengono aggiunti dei dati, si creerà una nuova Card senza che vi sia bosogno di intervento sul codice.

Come risolvere errore "key" unique prop. Si aggiunga la prop key al component, sull'istanza all'inizio. In questo caso la value sarà {elem.id}.

## 23. Build an AirBnb Experiences Clone | Project: Sold Out Badge

Qui si parlerà di Conditional Rendering.
Questo si verifica quando vogliamo renderizzare parte di una nostra pagina solo in qualche occasione.

Creaimo una nuova prop chiamata openSpots in App.js, ed un nuovo div nel file Card.js con:

<code>

    {props.openSpots === 0 && <div className="cardBadge">SOLD OUT</div>}

</code>

Con questo sarà come inserire un if statement, così che se props.openSpots fosse uguale a 0, il badge SOLDOUT verrebbe visualizzato.

Possiamo quindi modificare il badge per indicare per esempio se l'esperienza é online, con:
<code>
let badgeText;
if (props.openSpots === 0) {
badgeText = "SOLD OUT";
} else if (props.country === "Online") {
console.log("online course");
badgeText = "ONLINE";
}
</code>

Challange:
Modifica il codice in modo che appaia il badge anche quando la location é online.

<code>
{badgeText && <div className="cardBadge">{badgeText}</div>}
</code>

Corretto :white_check_mark:

## 24. Build an AirBnb Experiences Clone | Project: Pass Object as props

Ora come sintetizzare le properties passate al component Card in App.js.

Passiamo quindi invece che le singole properties l'intero object item quindi da questo:
<code>
const cardsArray = data.map((elem) => {
return (
<Card
				key={elem.id}
				img={elem.coverImg}
				rating={elem.stats.rating}
				reviewCount={elem.stats.reviewCount}
				country={elem.location}
				title={elem.title}
				price={elem.price}
				openSpots={elem.openSpots}
			/>
);
});
</code>

A questo:
<code>
const cardsArray = data.map((item) => {
return <Card key={item.id} item={item} />;
});
</code>

Manteniamo la property id in quanto qualcosa di abbastanza unico, che abbiamo bisogno di includere se usiamo map, ma per tutte le altre properties passiamo invece l'intero object "item".

Challange:
Sistema il Component Card in modo che funzioni nuovamente.

Corretto :white_check_mark:

Challange:
Sistema il problema di configurazione dell'object, già trovato, errore nell'indicazione delle properties. Prima passandole individualmente potevamo usare i names che volevamo, ora occorre attenersi alla struttura dell'object passanto. Quindi per esempio props.item.stats.reviewCount o props.item.coverImg. Da sistemare anche algoritmo per tag ONLINE / SOLD OUT.

Corretto :white_check_mark:

## 25. Build an AirBnb Experiences Clone | Spread Objects as Props

Invece che passare un nuovo object item, si può utilizzare lo spread operator "..." per passare l'object direttamente a props diviso già in singole prop come le passassimo noi singolarmente.

Riportiamo quindi anche il Component HeroSection attivo.

## 26. Build an AirBnb Experiences Clone | Section 2 Solo Project

Eseguito e Corretto :white_check_mark:

## 27. Build an AirBnb Experiences Clone | Section 2 Recap

• Props and React - uno degli argomenti più importanti per il concetto di Composable e Reusable
• Mapping Data - usare i dati per creare il guidare il codice e usare map su i dati.

## 1. Build a Meme generator | Section Intro and Figma File

• Impareremo qui come creare web app interattive in React.js

Le differenze tra Static Web Sites e Dynamic Web Apps:

- le static web pages:
  • Sono Read-only, nessun cambiamento nei dati
  • Esempi possono essere i blog, news sites, recipes ecc.
  • Non permettono di cambiare alcun contenuto ma solo di consumarlo, leggerlo.

- le dynamic web apps:
  • Read & Write - lo user ha l'abilità di cambiare i dati che guida l'app
  • Altamente interattive
  • Invece di mostrare lo stesso contenuto per tutti gli utenti, visualizza i dati specifici per ogni utente.
  • Esempi possono essere Bank Website, Airbnb...

Impareremo:

- Gli Event Listeners e come aggiungere degli aspetti interattivi alla nostra web app
- State
- Conditional Rendering
- Forms, come ottenere dati dallo User
- Side Effect, come gestire i side effects in React.js

## 2. Build a Meme generator | Meme Generator: Header

Challange:
Creare sezione Header

Da ripassare: controlla sempre  
• import React from "react";

Corretto :white_check_mark:
Leggere differenze in CSS come ovvio.

## 3. Build a Meme generator | Meme Generator: Form

Challange:
Creare il Form component, senza le funzionalità attive ma con tutti gli elements necessari.

Corretto :white_check_mark:
Leggere differenze in CSS come ovvio.

## 4. Build a Meme generator | Project Analysis

Per permettere ad uno User di interagire con il sito o la web app dobbiamo per prima cosa cogliere gli events (Listen) e reagire a questi Events quando avvengono.

La prima cosa che avviene quando l'app viene avviata é una richiesta ad un'API chaimata imageFlip che restituisce un Array di 100 Meme tra i più popolari del momento. Poi clickando sul button "Get new meme image" verrà selezionato in modo random uno tra i 100 elements dell'Array, e verrà usato il testo nei due Input Box per generare il text nella parte superiore ed inferiore dell'immagine.

La prima cosa che faremo sarà inserire un Event Listener nel Button così potremo eseguire una logica quando il Button verrà clickato.

## 5. Build a Meme generator | Event Listeners

La prima cosa che differenzia uno Static Web Site da una Web Apllication é la possibilità per lo User di interagire con ciò che vede nel display.

Per indicare in un element JSX un Event listener si usa qualcosa di molto similare a quando si scrive un attribute Event Listener in un element HTML, solo scritto in camelCase:

<code>
<button onClick={function(){}}>Click Me</button>
</code>

O meglio:

<code>
export default function App() {
	function handleClick(){
		console.log('Clicked');
	}
	return (
		<div className="App">
		<button onClick={?}>Click Me</button>
		</div>
	);
}
</code>

Challange:
Completare esempio precedente.

<code>
export default function App() {
	function handleClick(){
		console.log('Clicked');
	}
	return (
		<div className="App">
		<button onClick={handleClick}>Click Me</button>
		</div>
	);
}
</code>

Corretto :white_check_mark:

Lista completa Events Listeners da documentation
React.js:

https://reactjs.org/docs/events.html#mouse-events

Challange:
Inserire un Event Listener ad un element in modo che avvanga un cambiamento quando il muose ci passa sopra (hover). Aggiungere anche del CSS per rendere il passaggio visivamente più immediato.

<code>
export default function Header() {
	function hoverMe() {
		console.log("It's Hover Me!");
	}
	return (
		<header onMouseEnter={hoverMe} className="header">
			<div className="titleHeader">
				<img src={memeImg} />
				<h2>Meme generator</h2>
			</div>
			<h3>React Course - Project 3</h3>
		</header>
	);
}
</code>

Nota: possibile usare sia onMouseEnter che onMouseOver

Corretto :white_check_mark:

## 6. Build a Meme generator | Project: Get random meme

Challange:
Ottieni al Click un URL sempre diverso tramite il metodo random.

<code>
export default function Meme() {
	function getURL() {
		const memesArray = memesData["data"]["memes"];
		const randomNumber = (Math.random() * memesArray.length).toFixed(0);
		const url = memesArray[randomNumber].url;
		// Mia soluzione -->
		// console.log(
		// 	memesData["data"]["memes"][(Math.random() * 100).toFixed(0)]["url"]
		// );

    	console.log(url);
    }
    return (
    	<main>
    		<div className="form">
    			<input
    				type="text"
    				className="formInputs inputOne"
    				placeholder="Top text"
    			/>
    			<input
    				type="text"
    				className="formInputs inputTwo"
    				placeholder="Bottom text"
    			/>
    			<button onClick={getURL} className="formButton">
    				Get a new meme image 🖼
    			</button>
    		</div>
    	</main>
    );

}

</code>

Corretto :white_check_mark:

Differenza: il tutorial salva su variabili i vari step.

## 7. Build a Meme generator | Our current conundrum

Qui ci concentreremo su come far aggiornare la UI a React.js quando per esempio la URL dello scorso esercizio cambia valore, restituendo una nuova URL al click del Button.

Challange:
Usa map su un Array per generare un element "p" per ogni item dell'Array al click del Button. Genera i "p" sotto il Button.

<code>
export default function App() {
	const thingsArray = ["Thing 1", "Thing 2"];
	const mappedArray = thingsArray.map((item) => {
		return <p key={item}>{item}</p>;
	});

    return (
    	<div className="App">
    		<div className="container">
    			<Header />
    			<Meme />
    			{mappedArray}
    		</div>
    	</div>
    );

}
</code>

Corretto :white_check_mark:

Challange:
Al click del button aggiungi un nuovo element all'Array e usa console.log per visualizzare l'Array con l'element aggiunto.

<code>
export default function Meme() {
    const thingsArray = ["Thing 1", "Thing 2"];
    const mappedArray = thingsArray.map((item) => {
    	return <p key={item}>{item}</p>;
    });

    function addItem() {
    	thingsArray.push(`Thing ${thingsArray.length + 1}`);
    	console.log(thingsArray);
    }

    return (
    	<main>
    		<div className="form">
    			<input
    				type="text"
    				className="formInputs inputOne"
    				placeholder="Top text"
    			/>
    			<input
    				type="text"
    				className="formInputs inputTwo"
    				placeholder="Bottom text"
    			/>
    			<button onClick={addItem} className="formButton">
    				Get a new meme image 🖼
    			</button>
    			{mappedArray}
    		</div>
    	</main>
    );

}
</code>

Corretto :white_check_mark:

Al momento React.js renderizza nella UI solo l'Array predente al momento dell'avvio dell'app e non rileva il cambiamento dell'Array al click del Button.

Per far si che React.js reagisca al cambio di dati, come per esempio l'aggiunta di un element ad un Array come sopra, abbiamo bisogno dello "state".

Ogni azione dello User cambia lo state, che possono essere un click per far espandere una porzione di una pagina, oppure mandare un messaggio al database quando si clicka sul Button like di una playlist.
Tutte queste azioni e altre aggiornano lo "state" di React.js e gli permettono di aggiornare la User Interface reagendo ad un'azione.

Possiamo fare questo tramite il metodo React.useState.

## 8. Build a Meme generator | Props vs. State: Props

Una delle differenze più importanti da capire é quella tra Props e State.

Quando ci riferiamo alle "Props" intendiamo le proprietà che vengono passate ad un Component in un determinato ordine per farle funzionare correttamente, in modo similare a come una funzione riceve dei parametri:
"from above".
Un Component che riceve delle props non ha il permesso di modificare tali props (sono immutabili).

<code>
function addTwoNumbers(a, b){
	return a + b;
}

addTwoNumbers(1, 2)
</code>

Qui a e b sono due parametri passati "from above".
Non si dovrebbe mai cambiare il valore di un parametro all'interno del body di una function come:

<code>
function addTwoNumbers(a, b){
	a = 42;
	return a + b;
}

addTwoNumbers(1, 2)
</code>

E così non si dovrebbe mai riassegnare il valore di una prop nel body della creazione di un Component come:

<code>
function Navbar(props){
	props.coverImage = "something else";
}

<Navbar coverImage="some-value" />
</code>

Qui si dovrebbe sempre mantenere il valore delle props fornito dalla dichiarazione:
<code>
<Navbar coverImage="some-value" />
</code>
E non in props.coverImage... all'interno della function.

## 9. Build a Meme generator | Props vs. State: State

Mentre le props vengono ricevute "from above", e non dovrebbero mai essere cambiate.

Le "State" variables invece vengono definite all'interno di un Component ed essenzialmente dovrebbero cambiare.

"State" si riferisce a delle values che vengono gestite dal Component, in modo similare alle variabili dichiarate dentro ad un function. Ogni qualvolta si debba cambiare le values che dovrebbero essere salvate e/o visualizzate, si dovrebbe usare gli "State".

Un equivalente in JavaScript viene svolto nella Challange.

Challange:
Crea una funzione in JavaScript che vari il saluto in base all'ora corrente.

<code>
function sayHello(name) {
		const date = new Date();
		const hours = date.getHours();

    	let moment;

    	if (hours > 4 && hours < 12) {
    		moment = "morning";
    	} else if (hours > 12 && hours < 17) {
    		moment = "afternoon";
    	} else if (hours > 17 && hours < 20) {
    		moment = "evening";
    	} else {
    		moment = "night";
    	}

    	return `Good ${moment}, ${name}`;
    }

    console.log(sayHello("Alex"));

</code>

Corretto :white_check_mark:

In questa funzione é corretto aspettarsi che il parametro "name" non cambi, a differenza delle variabili dichiarate nel body della function come "moment".

In React.js le variabili create dalla function / Component vengono di solito gestite con lo "State".

Ora vedremo come implementare lo State in React.js.

## 10. Build a Meme generator | Props vs. State: Quiz

1- Lo State é ciò che gestisce le variabili e le values dichiarate all'interno di un Component, il modo in qui React ricorda le values salvate all'interno di un Component.

Corretto :white_check_mark:

2- Le props vengono usate per passare parametri "from above", cioé al momento della dichiarazione di un Component, che non dovrebbero essere cambiate nel corpo di una funzione che crea tale Component.

SBAGLIATO.

Le props vengono usate per passare dati all'interno di un Component in modo che questo determini cosa dev'essere visualizzato sul display.

3- Lo state invece deve venire usato per gestire le variabili che dichiariamo all'interno della creazione di un Component, che quindi possono cambiare value in vari momenti.

Corretto :white_check_mark:

4- "Immutable" significa che non possono cambiare valore, nessuna delle due é forzatamente immutabile, né props né state. Le props comunque non dovrebbero mai essere riassegnate e dovrebbero di prassi restare immutabili in quanto fornite dalla dichiarazione (from above).

Corretto :white_check_mark:

## 11. Build a Meme generator | useState

Come parte della libreria React.js per dichiarare delle variabili (similari) vi é il metodo React.useState().

"useState" é uno dei tanti metodi chiamati "Hooks" in React.js.

Possiamo dichiarare degli State semplicemente usando
React.useState().

<code>

import Header from "./components/Header";
import Meme from "./components/Meme";

export default function App() {
React.useState()
return (

<div className="App">
<div className="container">
<Header />
<Meme />
</div>
</div>
);
}

</code>

Oppure destrutturato nell'import statement e richiamato alla creazione del Component:

import React, { useState } from "react";
import Header from "./components/Header";
import Meme from "./components/Meme";

export default function App() {
useState();
return (

<div className="App">
<div className="container">
<Header />
<Meme />
</div>
</div>
);
}

Nel metodo React.useState(param1, param2), il primo parametro sarà la value di default per la State Variable che voglio salvare.

Challange:
Sostituire una value hard-coded con una creata usando useState.

<code>
import React from "react";
import memeImg from "../images/Troll Face.png";

export default function Header() {
const result = React.useState("Meme creator");

function hoverMe() {
console.log("It's Hover Me!");
}
return (

<header onMouseEnter={hoverMe} className="header">
	<div className="titleHeader">
	<img src={memeImg} />
	<h2>{result[0]}</h2>
	</div>
	<h3>React Course - Project 3</h3>
</header>
);
}

</code>

Corretto :white_check_mark:

Nella sezione sottostante si imparerà come capiremo cos'altro fare con l'Array generato da
React.useState(param1, param2) e come permettere allo User di interagire con lo State e cambiare value da solo.

## 12. Build a Meme generator | useState Array destructuring

Come visto, il primo parametro di React.useState é una value di default, come fosse una normale variabile inizializzata con tale value e il secondo parametro é una function.

Essendo il risultato di React.useState un Array, possiamo destrutturarlo fin da subito:

<code>
export default function Header() {
const [result, func] = React.useState("Meme creator");

function hoverMe() {
console.log("It's Hover Me!");
}
return (

<header onMouseEnter={hoverMe} className="header">
	<div className="titleHeader">
	<img src={memeImg} />
	<h2>{result[0]}</h2>
	</div>
	<h3>React Course - Project 3</h3>
</header>
);
}
</code>

Destrutturando in questo modo l'Array...
<code>
const [result, func] = React.useState("Meme creator");
</code>
...otterremo già una variabile result con value uguale al primo parametro del metodo useState(param1, param2).

## 13. Build a Meme generator | Changing State

Ora osserviamo la funzione corrispondente al secondo parametro di React.useState(result, func).

Se volessimo cambiare value ad una normale variabile come...
<code>
let isImportant = "Yes";
isImportant = "No";
</code>
...potremmo farlo. In React.js per cambiare value al primo parametro di useState, la funzione che forniremo come secondo parametro ci permetterà di effettuare questi cambiamenti.

La convenzione per il naming del secondo parametro é usare set + nameFirstParam

<code>
	const [result, setResult] = React.useState("Meme creator");
</code>

Questa nuova function, in questo caso setResult(), potrà essere chiamata nella creazione del Component, e ciò che vi sarà qui come argument sarà la nuova version di State.

In genere si chiama questa funzione per impostare o cambiare lo State quando qualcosa di specifico avviene nella pagina.

Challange:
Associare ad un element l'Event Click con relativa funzione ed usare una tale funzione con useState() per cambiare un valore.

<code>
export default function Header() {
	const [result, setResult] = React.useState("Meme creator");
	console.log(result);
	function hoverMe() {
		console.log("It's Hover Me!");
	}

    function handleClick() {
    	console.log("Clicked");
    	setResult("Meme generator");
    }
    return (
    	<header onMouseEnter={hoverMe} onClick={handleClick} className="header">
    		<div className="titleHeader">
    			<img src={memeImg} />
    			<h2>{result}</h2>
    		</div>
    		<h3>React Course - Project 3</h3>
    	</header>
    );

}
</code>

Corretto :white_check_mark:

Nella fattispecie ci si concentra sul secondo element nel destructuring:
const [result, setResult] = React.useState("Meme creator");

Qui setResult chiamato nella funzione handleClick quando l'element viene clickato, permette tramite il suo argument di cambiare il valore del parametro impostato a result tramite la funzione React.useState(param).

## 14. Build a Meme generator | useState - Counter Practice

Challange:
Creare un Counter usando il CSS fornito. Utilizzare useState per la modifica del valore nell'h1.

Nota: in React.js mai usare count++, visto che la modifica dello State direttamente é specificatamente proibita, e count++ si traduce infatti nel riassegnamento count = count + 1. Quindi in setState mai usare un riassegnamento come setState(count = count + 1) o shorthands vari.

Corretti :white_check_mark: TUTTI i passaggi.

Purtroppo questa usata non é proprio una best practice. Nella prossima sezione si vedrà una setter function di usaState per aggiornare la value del nostro State.

## 15. Build a Meme generator | useState - Changing state with a Callback Function

Determinare una nuova versione di State utilizzando una vecchia versione dello State, come sopra dove abbiamo usato la value attuale di count per aumentarne o diminuirne il valore, é considerato una pratica sbagliata.

Abbiamo visto quindi come fornire una nuova value a setCount. Possiamo però fornire una nuova value a questa setter function (setCount) utilizzando una callback. Quando forniamo come parametro una funzione alla setter function (setCount in questo caso), la funzione deve restituire (return) la nuova value che vogliamo assegnare allo State.

Inoltre utilizzando come parametro una funzione, React.js passerà come value del primo parametro proprio la vecchia value dello State, come reference. Per esempio:

Da questo...

<code>

    function plusClick() {
    	setCount(count + 1);
    }

</code>

...a questo:

<code>

    function plusClick() {
    	setCount(function(oldValue) {
    		return oldValue +1;
    	});
    }

</code>

Quindi se si necessita di utilizzare la vecchia value dello State per determinare la nuova value dello State bisogna sempre usare come parametro della funzione setter (setCount in questo caso) una funzione callback, definita anche updater function, e sfruttare il primo parametro di questa. Si può usare anche una Arrow function per questo scopo:

<code>

    function plusClick() {
    	setCount((oldValue) => oldValue + 1);
    }

</code>

Come norma usare il prefisso prev come naming per la vecchia value dello State come:

<code>

    function plusClick() {
    	setCount((prevCount) => prevCount + 1);
    }

</code>

Challange:
Modificare anche la funzione di sottrazione nel valore.

<code>
function minusClick() {
		setCount((prevCount) => prevCount - 1);
	}
</code>

Corretto :white_check_mark:

Questa nuova versione delle funzioni rispetto alla precedente viene considerata una best practice.

Challange:
Prova a cancellare il codice delle varie funzioni e a ricrearlo.

Corretto :white_check_mark:

## 16. Build a Meme generator | Changing state Quiz!

1- Una nuova value direttamente oppure una callback function che restituisca la nuova value.

Corretto :white_check_mark:

2- Quando si vuole riassegnare la value dello State direttamente, senza considerare la value precendete dello State.

Corretto :white_check_mark:

3- Quando si vuole riassegnare la value dello State ma sfruttando anche la prevValue dello State avendolo disponibile come primo parametro della funzione callback automaticamente da React.js.

Corretto :white_check_mark:

## 17. Build a Meme generator | Project: Add images to the meme generator

Challange:
Salva l'URL random del meme nello state, partendo da un'empty string, aggiungendo un element img per visualizzare l'immagine sotto il div form.

<code>
export default function Meme() {
	const [memeImage, setMemeImage] = React.useState("");

    function getMemeImage() {
    	const memesArray = memesData["data"]["memes"];
    	const randomNumber = (Math.random() * memesArray.length).toFixed(0);
    	setMemeImage(memesArray[randomNumber].url);
    }

    return (
    	<main>
    		<div className="form">
    			<input
    				type="text"
    				className="formInputs inputOne"
    				placeholder="Top text"
    			/>
    			<input
    				type="text"
    				className="formInputs inputTwo"
    				placeholder="Bottom text"
    			/>
    			<button onClick={getMemeImage} className="formButton">
    				Get a new meme image 🖼
    			</button>
    		</div>
    		<img src={memeImage} className="memeImage" />
    	</main>
    );

}
</code>

Corretto :white_check_mark:

## 18. Build a Meme generator | Challange: Ternary Practice

Challange:
Riscrivi il codice dato usando il Ternary Operator.

<code>
const isGoingOut = true;

let answer;

    // if (isGoingOut === true) {
    // 	answer = "Yes";
    // } else {
    // 	answer = "No";
    // }

isGoingOut ? (answer = "Yes") : (answer = "No");

</code>

MEGLIO FORMA PIU' CONTRATTA:

<code>
let answer = isGoingOut === true ? "Yes" : "No"
</code>

O meglio ancora:
<code>
let answer = isGoingOut ? "Yes" : "No"
</code>

Challange:
Muovi il Ternary Operator all'interno di un Element JSX.

<code>
<button onClick={getMemeImage} className="formButton">
					Get a new meme image {isGoingOut ? "Yes!" : "No!"} 🖼
</button>
</code>

Corretto :white_check_mark:

## 19. Build a Meme generator | Challange: flipping State back and forth

Challange:
Inizializzare lo State per isGoingOut come un boolean.
Fai in modo che clickando su un element la value cambi da false a true o da true a false.
Mostra "Yes" o "No" in un Element.

<code>

const [isGoingOut, setIsGoingOut] = React.useState(true);

    function getMemeImage() {
    	const memesArray = memesData["data"]["memes"];
    	const randomNumber = (Math.random() * memesArray.length).toFixed(0);
    	setMemeImage(memesArray[randomNumber].url);

    	setIsGoingOut((prevIsGoingOut) => !prevIsGoingOut);
    }

    return (
    	<main>
    		<div className="form">
    			<input
    				type="text"
    				className="formInputs inputOne"
    				placeholder="Top text"
    			/>
    			<input
    				type="text"
    				className="formInputs inputTwo"
    				placeholder="Bottom text"
    			/>
    			<button onClick={getMemeImage} className="formButton">
    				Get a new meme image -- {isGoingOut ? "Yes!" : "No!"} 🖼
    			</button>
    		</div>
    		<img src={memeImage} className="memeImage" />
    	</main>
    );

}

</code>

Un'alternativa può essere, anche se di più difficile lettura:

<code>
	<button
					onClick={() => setIsGoingOut((prevIsGoingOut) => !prevIsGoingOut)}
					className="formButton"
				>
					Get a new meme image -- {isGoingOut ? "Yes!" : "No!"} 🖼
	</button>
</code>

Corretto :white_check_mark:

Challange:
Inserire il Ternary Operator direttamente in un Element.

<code>
	<button onClick={getMemeImage} className="formButton">
					Get a new meme image -- {isGoingOut ? "Yes!" : "No!"} 🖼
	</button>
</code>

Corretto :white_check_mark:

## 20. Build a Meme generator | Complex State Array

Challange:
Converti il codice di qualche sezione fa con l'Array thingsArray in modo che sia salvato nello State invece che in una variabile locale. Inizializzalo con gli stessi due items iniziali.

<code>
const [thingsArray, setThingsArray] = React.useState[("Thing 1", "Thing 2")];

    function addItem() {

    }

</code>

Corretto :white_check_mark:

Challange:
Cosa ci sarebbe di sbagliato nell'usare nella funzione addItem il metodo thingsArray.push?

Che si userebbe la variabile salvata all'esterno, considerate una bad practice, non si modifica mai direttamente il nostro State.

Corretto :white_check_mark:

Utilizzeremo quindi setThingsArray().

Challange:
Quali sono le due opzioni che possiamo utilizzare in questo metodo?

Direttamente una value o una funzione callback che restituisca la value modificata, dove é possibile sfruttare prevThingsArray, la value precedente dello State.

Corretto :white_check_mark:

Challange:
Quale di queste due opzioni é meglio utilizzare?

L'opzione con la callback, in modo da usare la vecchia value e restituirne una modificata.

Corretto :white_check_mark:

Challange:
Cosa devo far restituire alla funzione?

<code>
function addItem() {
		setThingsArray((prevThingsArray) => {
			return prevThingsArray.push(`Thing ${prevThingsArray.length + 1}`);
		});
	}
</code>

ERRATO
Così facendo si modificherebbe lo stesso direttamente la vecchia versione dello State.
Usiamo invece la spread sintax con il secondo parametro:
<code>
function addItem() {
setThingsArray((prevThingsArray) => {
return [...prevThingsArray, `Thing ${prevThingsArray.length + 1}`];
});
}
</code>

Challange:
Testare codice scritto fin'ora e sistemare in caso.

<code>
const [thingsArray, setThingsArray] = React.useState(["Thing 1", "Thing 2"]);

    function addItem() {
    	setThingsArray((prevThingsArray) => {
    		return [...prevThingsArray, `Thing ${prevThingsArray.length + 1}`];
    	});
    }

    const mappedArray = thingsArray.map((item) => {
    	return <p key={item}>{item}</p>;
    });

</code>

Corretto :white_check_mark:

Vi sono anche altri modi per non modificare il nostro State originale direttamente, come per esempio un for loop aggiungendo alla fine il nuovo element.

Challange:
Prova a cancellare e riscrivere tutto.

Corretto :white_check_mark:

## 21. Build a Meme generator | Complex State: Objects

Ora vedremo come usare un object semplice nello State.

Challange:
Crea la Card e riempila con i dati provenienti dallo State invece che quelli hard coded.

<code>
export default function App() {
	const [contact, setContact] = React.useState({
		firstName: "John",
		lastName: "Doe",
		phone: "+1 (719) 555-1212",
		email: "itsmyrealname@example.com",
		isFavorite: false
	});

    function toogleFavorite() {
    	console.log("Toggle Favorite");
    }
    return (
    	<div className="App">
    		<div className="container">
    			<Header />
    			<Meme />
    			<article className="card">
    				<img src={userImg} className="card--image" />
    				<div className="card--info">
    					<img
    						src={starEmptyImg}
    						className="card--favorite"
    						onClick={toogleFavorite}
    					/>
    					<h2 className="card--name">
    						{contact.firstName} {contact.lastName}
    					</h2>
    					<p className="card--contact">{contact.phone}</p>
    					<p className="card--contact">{contact.email}</p>
    				</div>
    			</article>
    		</div>
    	</div>
    );

}
</code>

Corretto :white_check_mark:

Challange:
Usa il ternary operator per determinare quale immagine per la starIcon usare, considera le differze tra Scrimba e React App.

<code>
export default function App() {
	const [contact, setContact] = React.useState({
		firstName: "John",
		lastName: "Doe",
		phone: "+1 (719) 555-1212",
		email: "itsmyrealname@example.com",
		isFavorite: false
	});

    let starIcon = contact.isFavorite ? starFilledImg : starEmptyImg;

    function toogleFavorite() {
    	console.log("Toggle Favorite");
    }
    return (
    	<div className="App">
    		<div className="container">
    			<Header />
    			<Meme />
    			{/* <Counter /> */}
    			<article className="card">
    				<img src={userImg} className="card--image" />
    				<div className="card--info">
    					<img
    						src={starIcon}
    						className="card--favorite"
    						onClick={toogleFavorite}
    					/>
    					<h2 className="card--name">
    						{contact.firstName} {contact.lastName}
    					</h2>
    					<p className="card--contact">{contact.phone}</p>
    					<p className="card--contact">{contact.email}</p>
    				</div>
    			</article>
    		</div>
    	</div>
    );

}
</code>

Corretto :white_check_mark:

Nella prossima sezione vedremo come aggiornare lo State quando questo é un object.

## 22. Build a Meme generator | Complex State: Updating State objects

Ora per aggiornare isFavorite, o una qualsisi singola value di un object, occorre considerare che non vogliamo aggiornare le altre value ne modificarle in alcun modo.

Challange:
Aggiornando la singola proprietà dello State con:
<code>

function toogleFavorite() {
setContact((prevContact) => {
return {
isFavorite: !prevContact.isFavorite
};
});
}

</code>

In quale problema posso imbattermi?
Senza vedere la console: l'object può essere totalmente riscritto con una singola key/value isFavorite.

Corretto :white_check_mark:

Se invece usiamo lo spread operator possiamo:
<code>

    function toogleFavorite() {
    	setContact((prevContact) => {
    		return {
    		...prevContact,
    		isFavorite: !prevContact.isFavorite
    		};
    	});
    }

</code>

Così facendo prendiamo tutte le properties dell'object con lo spread operator, e con il secondo argument andiamo a sovrascrivere quella che ci interessa, in questo caso isFavorite.

Challange:
Cancella e riscrivi la function toggleFavorite.

Corretto :white_check_mark:

## 23. Build a Meme generator | Project: Refactor State

Challange:
Crea un object per salvare i dati relativi al meme con le properties elencate.
Crea la nuova State variabile allMemesImages con value di default memesData importato sopra.
Aggiorna getMemeImage e il markup per adattarsi ai nuovi cambiamenti.

<code>
const [meme, setMeme] = React.useState({
		topText: "",
		bottomText: "",
		randomImage: ""
	});

const [allMemeImages, setAllMemesImages] = React.useState(memesData);

function getMemeImage() {
const memesArray = allMemeImages["data"]["memes"];
const randomNumber = (Math.random() \* memesArray.length).toFixed(0);
setMeme((prevMeme) => {
return {
...prevMeme,
randomImage: memesArray[randomNumber].url
};
});

    	// setIsGoingOut((prevIsGoingOut) => !prevIsGoingOut);
    }

</code>

## 24. Build a Meme generator | Passing state ad props

Ora impareremo dei modi per unire State e Props e usarli insieme.

Challange:

Modifichiamo il counter in modo da passare il nostro State count in un nuovo Component Count con una prop chiamata number con value uguale alla value dello state count.
Creare Component Count.js separato da Counter anche se non specificato nella consegna della Challange.

<code>
function Count(props) {
	return (
		<div className="counter--count">
			<h1>{props.number}</h1>
		</div>
	);
}

export default function Counter() {
const [count, setCount] = React.useState(0);

    function plusClick() {
    	setCount((prevCount) => prevCount + 1);
    }

    function minusClick() {
    	setCount((prevCount) => prevCount - 1);
    }

    return (
    	<div className="counter">
    		<button onClick={minusClick} className="counter--minus">
    			-
    		</button>
    		<Count number={count} />
    		<button onClick={plusClick} className="counter--plus">
    			+
    		</button>
    	</div>
    );

}
</code>

Corretto :white_check_mark:

Questa separazione in genere viene usata quando un Component dev'essere usato e riusato più volte.

Ora stiamo inizializzando uno State che verrà poi passato come props al Component Count, combinando così i due concetti.

Facciamo la prova inserendo due console.log sia in App.js che in Count.js:
console.log("Count Component rendered");
console.log("App Component rendered");

Clickando sui Buttons possiamo notare che App.js viene renderizzato solo la prima volta all'avvio dell'app, mentre a essere renderizzato più volte al click é solamente il component Count.

Questa é una caratteristica peculiare di React.js, ogni volta che lo State cambia, vengono renderizzati nuovamente i child components, ma non quello principale.

Questo é anche un esempio di un child Component che riceve una State value attraverso le Props.

Nella prossima sezione vedremo come un Child Component possa avere la possibilità di avere l'accesso per effettuare cambiamenti allo State del suo Parent Component.

## 25. Build a Meme generator | Setting State from child components

Challange:
Crea un Component separato per la img star della Card creata in precedenza.

Gestione degli URL per via del Create-React-App diverso, ma funzionante Corretto :white_check_mark:

Sistemato aggiungendo import images a Star.js.

Questo ci porta all'argomento di questa sezione: come possiamo fare per far cambiare la value, visto che clickando non otteniamo alcun risultato.

Ora abbiamo l'istanza del child Component che riceve la value di contact.isFavorite ma non riceve l'abilità di cambiare tale State (da true a false e viceversa).

Come posso fare a dare al Component Star.js l'abilità di effettuare cambiamenti allo State che vive all'interno del parent Component, che in questo caso é App.js?

Challange:
Ipotizzare una soluzione.
Risposta:
Collegando lo State del parent Component al Child Component.
Ma come?
Forse con un Event Listener.
Forse inviando lo state del parent al child e inserendo la callback per l'event onClick nel child.

Partiamo dal fatto che l'Event Listener deve essere inserito in un native element come un div o un img.

Era corretto il fatto di inserire l'Event Listener nel child Component.
Nell'istanza del Component Star inserendo un onClick sarà sempre una custom prop, con un Event Listener a tutti gli effetti.
Cambiamolo quindi in handleClick=... per differenziare ed evitare confusione.

<code>
						<Star isFilled={contact.isFavorite} handleClick={toogleFavorite} />
</code>

Quindi nel Child Component posso aggiungere un Event Listener onClick reale dove la value sarà la chiamata a props.handleClick che richiamerà la funzione:

<code>
<img
			src={props.isFilled ? starFilledImg : starEmptyImg}
			className="card--favorite"
			onClick={props.handleClick}
		/>
</code>

In questo caso il component App.js sta passando la funzione toggleFavorite al child Component permettendo a questo child Component di eseguirla quando un certo Event avviene, in questo caso un click.

L'abilità di passare delle State Setter functions (come toggleFavorite) in giù un un Child Component é cruciale in React.js. Questa é dovuta al fatto che il Component reagisce alla gerarchia impostata quando si passano dei dati.

## 26. Build a Meme generator | Passing data around

Ricordare che i Component siblings non conoscono nemmeno la loro reciproca esistenza, quindi non si possono passare dati o cambi di State tra questi. Per passare uno State da un Component Sibling all'altro occorre passare per il Parent Component ed usando le props si può ottenere la rilevazione dei cambiamenti di State e trasmetterli tra un Component Child all'altro (Siblings tra loro).

Una soluzione alternativa, soprattutto visto che si potrebbe risalire di molto nei Parent components per la trasmissione di dati, é il Context: é una soluzione di gestione di terze parti, come Redux, che possono aiutare a risolvere questi problemi in grandi gerarchie. Questo é fuori dall'obiettivo di questa parte di Tutorial.

Challange:
Passare i dati dal Component Header ad App.js e poi al Component Body.

Corretto :white_check_mark:

Capire che questo é il modo che i dati scorrono in React.js può essere cruciale nel progettare l'architettura dell'Applicazione in modo da condividere gli State solo tra i components che necessitano di questi.
Infatti vi é un'importante distinzione da fare a questo punto: non sarebbe una grande idea inizializzare degli State in cima a tutto se non vi sono dei Child Components lungo il Tree che ne necessitano.

Come principio: é meglio tenere lo State il più Local possibile, il più vicino possibile al Component che ne necessita.

## 27. Build a Meme generator | Boxes Challange Part 1

Challange:
Creare i dati e inizializzare lo State con la default value dell'array in boxes.js e inserirli nell'App come boxes vuote.

Ricorda per id unico negli elements usare property key.

Corretto :white_check_mark:

## 28. Build a Meme generator | Dynamic Styles

Prima di proseguire con Challanges occore conoscere la Style Prop.

Nell'attribute style="" in HTML possiamo inserire del CSS, come già sappiamo.

Possiamo la stessa cosa in React.js e considerando che ci troviamo in un ambiente JavaScript, cambiare dinamicamente lo style basandoci per esempio sulla property on delle nostre boxes nei dati.

Per cambiare dinamicamente lo style si può aggiungere una prop style al div della box ma in React.js si metterà una string come value ma si fornirà un object. Per farlo dovremo prima usare la solita coppia di parentesi grafe per passare all'inserimento di JavaScript e poi un'altra coppia per fornire l'object.

<code>

    const squareElements = squares.map((square) => {
    return <div style={{}} key={square.id} className="emptyBox"></div>;
    });

</code>

Per evitare confusione si può optare per creare l'object esternamente e poi fornirlo all'attribute style={obj}:

<code>

const styles = {};

    const squareElements = squares.map((square) => {
    		return <div style={styles} key={square.id} className="emptyBox"></div>;
    		});

</code>

Una cosa da notare in questi styles é che devono essere scritti in camelCase, come quanto usiamo la property style in JavaScript:
document.getElementById('x').style.backgroundColor = 'black'

Questo può essere utile in sostituzione del CSS perché non vi saranno bisogno di value hard coded ma piuttosto si potranno inserire styles dinamici.

Supponiamo che vi sia una prop fornita ad App chiamata darkmode impostata con value true.

Challange:
Usa un ternary operator per determinare se la prop darkMode é impostata su true o false e cambia di conseguenza il colore dello sfondo del component App.
Nota: i valori in HEX devono essere strings.

<code>

root.render(<App darkMode={false} />);

const styles = {
backgroundColor: props.darkMode ? "#222222" : "CCCCCC"
};

    const squareElements = squares.map((square) => {
    	return <div style={styles} key={square.id} className="emptyBox"></div>;
    });

</code>

Corretto :white_check_mark:

## 29. Build a Meme generator | Boxes Challanges Part 2

Challange:
Creare un nuovo Box Component e renderizzalo. Passa al Component una prop chiamata on con la value corrispondente dai dati creati precedentemente. Nel Component Box, applica il dynamic style per determinare il background color. Se é on #222222, se off "none".

<code>
const squareElements = squares.map((square) => {
		return <Box key={square.id} on={square.on} />;
	});

export default function Box(props) {
const styles = {
backgroundColor: props.on ? "#222222" : "none"
};
return <div style={styles} key={props.id} className="emptyBox"></div>;
}

</code>

Corretto :white_check_mark:

## 30. Build a Meme generator | Boxes Challanges Part 3.1 - Local State

In questa sezione vedremo come un Component Child come può essere Box/ colga la prop in arrivo e grazie ad un proprio State cambi la value della prop on per variare il backgroundColor. Così facendo ogni Box Component avrà l'abilità di modificare il proprio State.

Challange:
Creare uno State all'interno del Box Component, determinare l'initial value basandosi sulla value di props.on e creare un Event Listener che tramite una funzione cambi il valore di tale State al click. Modificare il ternary operator per usare non più la value di props.on ma quella locale basata sullo State.

<code>
export default function Box(props) {
	const [painted, setPainted] = React.useState(props.on);

    function tooglePainted() {
    	setPainted((prevPainted) => {
    		return !prevPainted;
    	});
    }

    const styles = {
    	backgroundColor: painted ? "#222222" : "transparent"
    };

    return (
    	<div
    		style={styles}
    		key={props.id}
    		onClick={tooglePainted}
    		className="emptyBox"
    	></div>
    );

}
</code>

Corretto :white_check_mark:

In questo modo abbiamo dato al singolo Component Child Box in controllo sulla propria value.

Questo stesso principio si può applicare per esempio ad una ToDoList.

Esistono situazioni nelle quali questo modo di gestire gli State per singolo Component funziona, ma altre invece, e anche come approccio generale preferito, necessitano e conviene utilizzare uno State unificato nel Parent Component. Come vedremo nella prossima sezione.

## 31. Build a Meme generator | Boxes Challanges Part 3.2 - Unified state

Nella sezione precedente abbiamo inizializzato uno State per ogni singolo Component dando come value di default la incoming prop on e poi modificando tale State per aggiornare la property dell'object passato all'attribute style.

Questo tipo di State basato su una prop in arrivo é detto DERIVED STATE.

Questo tipo di approccio può causare però dei problemi, come spiegato nel link della Documentation allegato.
https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html

Il problema sussiste nel fatto molteplici fonti di verità: quando vado a modificare lo State nei singoli Child Components la value singola potrebbe differenziare dalla value che risiede per esempio in App /, visto che il singolo Component non va a modificare la value originale ma solo il Local State che deriva dalla prop in arrivo.

Vi sono comunque delle circostanze nelle quali il Derived State ha senso di esistere, anche se non é affato comune usarlo, vedi link precedente.

Ora affrontiamo il problema originale da un altro punto di vista:
Invece che inserire uno State dentro ad ogni Component Box /, useremo lo State che già esiste nel nostro file App /.

Creeremo quindi una funzione chiamata toggle() nel nostro App/ Component e la passeremo ad ogni istanza di Box /.
Ogni volta che un Box / Component verrà clickato eseguirà la function toggle() e dirà all'App / Component che lo State che sta mantenedo deve cambiare. Poi quando lo State cambierà, React.js renderizzerà nuovamente il Component App / visto il cambio di State, e inoltre renderizzerà di nuovo i Components Box / ma ora con la value che é variata aggiornata.
Questo modo é chiaramente più articolato e complesso del precedente ma é una practice migliore usare questa detta MANAGER STATE rispetto alla Derived State.

La Challange successiva imposterà il lavoro che si continuerà in seguito guidati.

Challange:
Creare la funzione toggle() che loggherà "clicked!".
Si passi tale funzione ad ogni Box / Component

<code>
Box.js

import React from "react";

export default function Box(props) {
const styles = {
backgroundColor: props.on ? "#222222" : "transparent"
};

    return (
    	<div
    		style={styles}
    		key={props.id}
    		onClick={props.func}
    		className="emptyBox"
    	></div>
    );

}
</code>

<code>
App.js
function toggle() {
		console.log("Clicked!");
	}

    const squareElements = squares.map((square) => {
    	return <Box key={square.id} on={square.on} func={toggle} />;
    });

</code>

Corretto :white_check_mark:

Il problema ora sussiste nel far capire quale in quale Box / é stata chiamata la funzione toggle(), visto che non derivando da un Local State la funzione toggle() in App / non ne ha idea.
In App / quindi se vorrò usare setSquare per modificare lo State dovrò identificare quale square nell'Array ha eseguito la funzione in modo da modificare quello corretto lasciando gli altri esattamente com'erano.

Un modo di farlo é dare come parametro alla funzione toggle l'id dello square. Per farlo nella maniera corretta dobbiamo anche modificare l'Event Listener onClick nel Component Box / in modo da poter accettare dei parametri in entrata, solo così riusciremo ad identificare l'id dello square.

<code>
App.js

function toggle(id) {
console.log(id);
}
</code>

<code>
Box.js

export default function Box(props) {
const styles = {
backgroundColor: props.on ? "#222222" : "transparent"
};

    return (
    	<div
    		style={styles}
    		key={props.id}
    		onClick={() => props.toggle()}
    		className="emptyBox"
    	></div>
    );

}
</code>

In questo modo onClick={() => props.toggle()} può ricevere l'event onClick={(event) => props.toggle()} e determinare le value dei parametri.

Nota: non si può sfruttare la prop key, ma occorre creare una nuova prop id.
<code>
const squareElements = squares.map((square) => {
return (
<Box key={square.id} id={square.id} on={square.on} toggle={toggle} />
);
});
</code>

Quindi loggando props.id nel Component Box/ otterrò l'id di ogni square. Mentre passando props.id alla funzione props.toggle(props.id) otterrò l'id dello square clickato.

<code>
export default function Box(props) {
	const styles = {
		backgroundColor: props.on ? "#222222" : "transparent"
	};

    return (
    	<div
    		style={styles}
    		key={props.id}
    		onClick={() => props.toggle(props.id)}
    		className="emptyBox"
    	></div>
    );

}
</code>

Ora posso usare questo id per aggiornare il corretto square nella funzione setSquares dello State di App /.

## 32. Build a Meme generator | Boxes Challanges Part 4

Challange:
Usare la setSquares function per aggiornare lo square corretto nell'Array.
Assicurarsi di non modificare direttamente lo State.

Soluzione molto similare al tutorial.

<code>
Soluzione:

function toggle(id) {
console.log(squares);
setSquares((prevSquares) => {
for (let elem of prevSquares) {
if (elem.id === id) {
elem.on = !prevSquares[id - 1].on;
}
}

    		return [...prevSquares];
    	});
    }

</code>

<code>
Soluzione Tutorial:

function toogle(id){
setSquares((prevSquares)=> {
const newSquares = []:

    		for (let i = 0; i < prevSquares.length; i++){
    			const currentSquare = prevSquares[i];
    			if(currentSquare.id === id){
    				const updatedSquare = {
    					...currentSquare,
    					on: !currentSquare.on
    				}
    				newSquares.push(updatedSquare);
    			} else {
    				newSquares.push(currentSquare);
    			}
    		}
    	})
    }

</code>

Tuttavia entrambe queste soluzioni sono molto incentrate su una modalità IMPERATIVE (vedi inizio tutorial). Ora vedremo delle soluzioni che sfruttino meglio la parte DECLERATIVE di React.js.

## 33. Build a Meme generator | Boxes Challanges Part 5

Un modo perché il codice sia più Declerative consiste nell'usare l'Higher Order Function .map(), abbastanza esplicativo.

<code>
function toggle(id) {
		setSquares((prevSquares) => {
			return prevSquares.map((square) => {
				return square.id === id ? { ...square, on: !square.on } : square;
			});
		});
	}
</code>

Usando .map posso mappare ogni singolo square ed inserire la condizione con il Ternary Operator che se l'id dell'object square é uguale al parametro della funzione inverta la value della property on.

Challange:
Cancella la toggle function e ricreala da zero.

Corretto :white_check_mark:

## 34. Build a Meme generator | Conditional Rendering: &&

Continuamo con l'app Joke.

Challange:
Creare, nel file Joke.js lo State isShown con default false.
Aggiungere un Button che scambi la value.

Errato, Ripassare.

Challange:
Visualizzare il paragraph di risposta solo se isShown é true sfruttando il template sopra.

<code>
export default function Joke(props) {
	console.log(props);

    const [isShown, setIsShown] = React.useState(false);

    function toggleShown() {
    	setIsShown((prevShown) => {
    		return !prevShown;
    	});
    }

    return (
    	<div>
    		<h1>Joke:</h1>
    		{props.setup && <h3>{props.setup}</h3>}
    		{isShown && <p>{props.punchline}</p>}
    		<button onClick={toggleShown}>Show Me!</button>
    		<hr />
    	</div>
    );

}
</code>

Corretto :white_check_mark:

Questo funziona perché occorre con un Conditions che entrambe le value siano truthy. Se la prima value in un conditional é false, la seconda dopo l'&& verrà completamente ignorata.

Possiamo sfruttare questo per visualizzare o meno degli elements in React.js. Se la condizione precedente a questo é false, l'element non verrà visualizzato.

## 35. Build a Meme generator | Conditional Rendering && Practice

Challange:
Visualizza un h1 solo se l'array messages dello state contiene degli elements.
Poi visualizza il numero di messages nell'h1.

<code>
export default function App() {

    const [messages, setMessages] = React.useState(["a", "b"]);

    const jokeElements = jokesData.map((joke) => {
    	return <Joke setup={joke.setup} punchline={joke.punchline} />;
    });
    return (
    	<div className="container">
    		{messages.length > 0 && <h1>You have _ unread messages</h1>}
    		{jokeElements}
    	</div>
    );

}
</code>

Corretto :white_check_mark:

## 36. Build a Meme generator | Conditional Rendering: ternary

Nell'esempio Joke possiamo chiaramente notare che l'indicazione del Button resta invariata anche quando la risposta é visibile.

Sapendo ora cos'é il Conditional rendering proviamo ad ipotizzare una soluzione a questo problema.

Ipotesi:

1-
<code>

    <button onClick={toggleShown}>{isShown ? "Hide Answer" : "Show Answer"}</button>

</code>

2- Inserire due label che si alternino in base a isShown.

Da tutorial:
Si potrebbero inserire due button con isShown && button1 o isShown && button2.
Ma si può fare meglio.

Perfetta prima soluzione.

Corretto :white_check_mark:

Di norma il Conditional Rendering con && é ottimo quando si vuole che qualcosa sia visualizzato o non visualizzato ad una determinata condizione, il Ternary Operator quando si vogliono alternare due cose da mostrare, ma delle quali almeno una sarà visualizzata.
Se la condizione o le possibilità nel Ternary Operator si presentano molto complesse é meglio optare per una struttura if...else prima del return in JavaScript.

## 37. Build a Meme generator | Conditional Rendering Practice

Challange:
Visualizza un h1 se non vi sono messaggi (elements nell'Array) e un'altro con il numero di messages, considerando anche una versione per il singolare.

<code>
export default function App() {
	// function toggle(show) {
	// 	console.log(show);
	// 	setIsShown((prevShow) => {
	// 		// const showBefore = prevShow;
	// 		return !show;
	// 	});
	// }
	// console.log(jokesData);

    const [messages, setMessages] = React.useState(["a", "b"]);

    const jokeElements = jokesData.map((joke) => {
    	return <Joke setup={joke.setup} punchline={joke.punchline} />;
    });
    return (
    	<div className="container">
    		{messages.length === 0 ? (
    			<h1>You're all caught up!</h1>
    		) : (
    			messages.length > 0 && (
    				<h1>
    					You have {messages.length} unread message
    					{messages.length > 1 ? "s" : ""}
    				</h1>
    			)
    		)}
    		{jokeElements}
    	</div>
    );

</code>

Forse leggermente più chiara quella del tutorial ma soluzione perfetta.

<code>
Da Tutorial:

const [messages, setMessages] = React.useState(["a", "b"]);

    const jokeElements = jokesData.map((joke) => {
    	return <Joke setup={joke.setup} punchline={joke.punchline} />;
    });
    return (
    	<div className="container">
    		{messages.length === 0 ? (
    			<h1>You're all caught up!</h1>
    		) : (
    			messages.length > 0 && (
    				<h1>
    					You have {messages.length} unread
    					{messages.length > 1 ? " messages" : " message"}
    				</h1>
    			)
    		)}
    		{jokeElements}
    	</div>
    );

</code>

Corretto :white_check_mark:

## 38. Build a Meme generator | Conditional Rendering Quiz!

1- E' il rendering di un Component basato su una certa condizione, per esempio una value true o false, in cui si utilizza l'operatore &&.

Corretto :white_check_mark:

2- Quando si vuole renderizzare o non renderizzare (visualizzare) un element ad una determinata condizione.

Corretto :white_check_mark:

3- Quando si vuole scegliere un'alternativa tra due elements da renderizzare ad una determinata condizione. Se una value é true visualizza una cosa se é false un'altra.

Corretto :white_check_mark:

4- Conviene utilizzare una struttura if...if else nella parte superione.

Corretto :white_check_mark:

Nota: La differenza tra && e ternary e una struttura if...else é anche quella che i primi due sono inline nel JSX mentre l'if...else bisogna basarsi su una variabile che come value abbia del JSX differente da restituire in base alle molteplici soluzioni.

## 39. Build a Meme generator | React Forms Intro

Ora spenderemo del tempo per gestire ed interagire con i forms.
Ricordiamo i form in HTML che si basavano su link php e quelli in JavaScript che con un event listener nel form, ad esempio con submit, mandano del codice con i dati al server. Qui tutti i dati vengono presi immediatamente e mandati al momento del submit.

La differenza con React.js sta nel fatto che invece di aspettare l'intera compilazione del form, il submit tramite il tasto Submit e solo poi raccogliere i dati, creeremo degli State che ad ogni modifica dell'input, delle checkbox, dei radio button ecc, verranno modificati. Al momento del Submit i dati saranno già stati raccolti, non vi sarà altro lavoro da fare. I dati quindi verranno invitati (submit) all'API passando lo State o gli State che abbiamo tracciato per tutto il tempo.

LETTURA DOCUMENTATION FORMS REACT.JS --> Lettura rapida fatta, approfondire

## 40. Build a Meme generator | Watch for input changes in React.js

Passiamo ora alla comprensione della gestione di un Form in React.js.

Partiamo dal Component Form:
<code>
import React from "react";

export default function Form() {
return (

<form>
<input type="text" placeholder="First Name" />
</form>
);
}

</code>

Come sappiamo già in JavaScript puro ci sarebbe un Button submit con una funzione per l'event handler che coglierebbe tutti i dati presenti al momento dell'event.

In React.js invece manteniamo aggiornato lo State per ogni cambiamento che avviene in ogni input nel nostro Form.

Creaimo quindi il nostro State.

<code>
import React from "react";

export default function Form() {
const [firstName, setFirstName] = React.useState("");

    return (
    	<form>
    		<input type="text" placeholder="First Name" />
    	</form>
    );

}

</code>

Quale Event dovrei aggiungere all'input per permettere questo aggiornamento dello State ad ogni cambiamento?

onChange.

Corretto :white_check_mark:

<code>
export default function Form() {
	const [firstName, setFirstName] = React.useState("");

    function handleChange() {
    	console.log("Changed.");
    }

    return (
    	<form>
    		<input type="text" placeholder="First Name" onChange={handleChange} />
    	</form>
    );

}
</code>

Così facendo ogni tasto premuto verrà colto l'Event onChange ed eseguita la funzione handleChange.

Nella funzione eseguita all'Event onChange, chiamata qui handleChange, si può passare un parametro e tale parametro di default sarà l'object event.

<code>
function handleChange(event) {
		console.log(event);
	}
</code>

Questo verrà denominato da React.js SyntheticBaseEvent.
Le varie properties di questo object sono molto similari all'object Event passabile negli eventListeners in JavaScript.

Come in JavaScript abbiamo infatti una delle più importanti properties che é event.target.
Questo restituisce l'element HTML dov'é avvenuto l'event, per la precisione il DOM object, con conseguenti properties e metodi.
Una di queste proprietà é event.target.value.

Challange:
Fai in modo che lo state firstName si aggiorni ogni volta che viene premuto un tasto.

<code>
export default function Form() {
const [firstName, setFirstName] = React.useState("");

    console.log(firstName);

    function handleChange(event) {
    	setFirstName(event.target.value);
    }

    return (
    	<form>
    		<input type="text" placeholder="First Name" onChange={handleChange} />
    	</form>
    );

}
</code>

Corretto :white_check_mark:

## 41. Build a Meme generator | Form inputs practice

Challange:
Crea un input per il last name.

Soluzione 1:
<code>
export default function Form() {
const [firstName, setFirstName] = React.useState("");

    const [lastName, setLastName] = React.useState("");

    console.log(firstName);

    console.log(lastName);

    function handleChange(event) {
    	if (event.target.placeholder === "First Name") {
    		setFirstName(event.target.value);
    	} else if (event.target.placeholder === "Last Name") {
    		setLastName(event.target.value);
    	}
    }

    return (
    	<form>
    		<input type="text" placeholder="First Name" onChange={handleChange} />
    		<br />
    		<input type="text" placeholder="Last Name" onChange={handleChange} />
    	</form>
    );

}
</code>

Alternativa creare doppia funzione.

Tuttavia neanche questa é una soluzione ottimale, soprattutto nei Form con molti input box. Nei capitoli seguenti vedremo come combinare i vari State in un object e come usare il parametro event che riceviamo nelle funzione di handler per determinare quale proprietà di tale object dovrebbe essere aggiornata.

## 42. Build a Meme generator | Form State Object

Vediamo come migliorare il nostro Form e come gestire lo State così che quando vi saranno molti input non vi sia eccessiva ripetitività nel codice.

Conviene quindi salvare lo State in un object invece che in variabili separate.
Creiamo una funzione unica invece che due separate. Ora lo State. Invece che avere una value string vuota come value di default, usiamo un object.

<code>
const [formData, setFormData] = React.useState({
		firstname: "",
		lastname: ""
	});
</code>

Nella funzione handler dell'event useremo event.target per identificare l'input nel quale avviene l'event.
event.target identificherà proprio il DOM object nel quale avviene, perciò avremo a disposizione varie properties da poter utilizzare.

A questo punto non possiamo semplicemente usare setFormData con event.target.value perché sovrascriverebbe l'object nel metodo useState. E visto che stiamo usando la stessa function handleChange su entrambi gli input dovrò fornire un modo per distinguere tra i due in quale avviene l'event.

E' buona norma aggiungere una property name ad entrambi gli input (come attribute name in HTML), ed in React.js questo assume un ruolo speciale.
Facciamo quindi corrispondere la property name con il property name salvato nell'object (la key dell'object deve corrispondere con il name dell'attribute nell'element HTML input).

<code>
return (
		<form>
			<input
				type="text"
				placeholder="First Name"
				onChange={handleChange}
				name="firstName"
			/>
			<br />
			<input
				type="text"
				placeholder="Last Name"
				onChange={handleChange}
				name="lastName"
			/>
		</form>
	);
</code>

Così facendo nella funzione handleChange avremmo accesso alla property event.target.name.

<code>

    function handleChange(event) {
    	console.log(event.target.name);
    }

</code>

Ora possiamo usare setFormData conoscendo sia la property name che quella value di event.target.
Consideriamo la necessità di sapere la value precedente della property. Usiamo le computed properties, cioé la property non in "" tra delle square brackets, ([property] : value ):

<code>
export default function Form() {
	const [formData, setFormData] = React.useState({
		firstName: "",
		lastName: ""
	});

    console.log(formData);

    function handleChange(event) {
    	setFormData((prevFormData) => {
    		return {
    			...prevFormData,
    			[event.target.name]: event.target.value
    		};
    	});
    }

    return (
    	<form>
    		<input
    			type="text"
    			placeholder="First Name"
    			onChange={handleChange}
    			name="firstName"
    		/>
    		<br />
    		<input
    			type="text"
    			placeholder="Last Name"
    			onChange={handleChange}
    			name="lastName"
    		/>
    	</form>
    );

}
</code>

## 43. Build a Meme generator | Form State Object practice

Challange aggiungi un field email e associalo al nostro Form.

<code>
export default function Form() {
	const [formData, setFormData] = React.useState({
		firstName: "",
		lastName: "",
		email: ""
	});

    console.log(formData);

    function handleChange(event) {
    	setFormData((prevFormData) => {
    		return {
    			...prevFormData,
    			[event.target.name]: event.target.value
    		};
    	});
    }

    return (
    	<form>
    		<input
    			type="text"
    			placeholder="First Name"
    			onChange={handleChange}
    			name="firstName"
    		/>
    		<br />
    		<input
    			type="text"
    			placeholder="Last Name"
    			onChange={handleChange}
    			name="lastName"
    		/>
    		<br />
    		<input
    			type="email"
    			placeholder="Email"
    			onChange={handleChange}
    			name="email"
    		/>
    	</form>
    );

}
</code>

Corretto :white_check_mark:

Da documentazione letta, questi non sono dei Controlled Inputs. Nella prossima sezione impareremo cosa sono più di preciso e come trasformare in nostri Uncontrolled inputs in Controlled.

## 44. Build a Meme generator | Controlled Inputs

Osservando nella documentazione sui Form, nel paragrafo dei Controlled components, vi é il concetto di "single source of truth". Questo sta ad indicare che quando dobbiamo mantenere uno State questo dovrebbe essere l'unica fonte di verità, questo fa riferimento alla possibile divisione degli state nei singoli Components, come abbiamo visto nell'esempio delle Box dove il valore di uno State veniva modificato nei singoli Box nel Derived State e invece modificato con un modo più articolato nel Manager State. Nel Derived State potevano esserci due state con on con diversa value, ma non dovevano per forza corrispondere. In altre parole non c'era la Single Source of Truth.

Abbiamo un concetto simile che sta avvendendo nel nostro esempio attuale: ogni input effettivamente sta ospitando il proprio State al momento.
Anche se qui abbiamo impostato le cose perché si rispecchino, l'input element contiene un proprio State mentre l'object del metodo useState ne contiene un altro.

Una buona pratica in React.js consiste nel fatto che lo State di React.js (useState) sia ciò che guidi lo State visibile dentro agli input.

Per fare questo basta aggiungere una property value ad i nostri elements input, con value {state.property}, ad esempio:

<code>
return (
<form>
<input
				type="text"
				placeholder="First Name"
				onChange={handleChange}
				name="firstName"
				value={formData.firstName}
			/>
<br />
<input
				type="text"
				placeholder="Last Name"
				onChange={handleChange}
				name="lastName"
				value={formData.lastName}
			/>
<br />
<input
				type="email"
				placeholder="Email"
				onChange={handleChange}
				name="email"
				value={formData.email}
			/>
</form>
);
</code>

Visivamente non si noterà alcuna differenza. Concettualmente d'altro canto, quando andrò ad inserire del testo in un input, la value non sarà più controllata dall'element input ma piuttosto da React.js e dal suo State.

Per fasi: ogni cambiamento che avverrà nel Form, attiverà la funzione handleChange, che modificherà il corretto pezzo di State (l'object), che renderizzerà nuovamente il Form impostando come value dell'input ciò che sarà stato inserito nello State.

Semplificando, con i Controlled Inputs sarà lo State a dire all'input cosa essere come value piuttosto che l'input che diceva allo State cosa essere.

## 45. Build a Meme generator | Forms in React.js: Textarea

I Form hanno una varietà di elements con i quali interagire, come i radio buttons, le checkboxes e le textareas per citarne alcune. Ognuno di questi ha delle considerazioni particolari da tenere a mente quando li usiamo in React.js.

A differenza di HTML la textarea in React.js é un element selfclosing, e vi possiamo aggiungere una value property come un input visto precedentemente.
Per il resto é molto similare agli input appena visti come comportamento e properties.

Challange:
Aggiungere una textarea per i "comments". Assicurarsi che si aggiorni lo State quando avvengono dei cambiamenti.

<code>
export default function Form() {
	const [formData, setFormData] = React.useState({
		firstName: "",
		lastName: "",
		email: "",
		comments: ""
	});

    console.log(formData);

    function handleChange(event) {
    	setFormData((prevFormData) => {
    		return {
    			...prevFormData,
    			[event.target.name]: event.target.value
    		};
    	});
    }

    return (
    	<form>
    		<input
    			type="text"
    			placeholder="First Name"
    			onChange={handleChange}
    			name="firstName"
    			value={formData.firstName}
    		/>
    		<br />
    		<input
    			type="text"
    			placeholder="Last Name"
    			onChange={handleChange}
    			name="lastName"
    			value={formData.lastName}
    		/>
    		<br />
    		<input
    			type="email"
    			placeholder="Email"
    			onChange={handleChange}
    			name="email"
    			value={formData.email}
    		/>
    		<textarea
    			placeholder="Comment here..."
    			onChange={handleChange}
    			name="comments"
    			value={formData.comments}
    		/>
    	</form>
    );

}
</code>

Corretto :white_check_mark:

## 46. Build a Meme generator | Forms in React.js: Checkboxes

Ora osserviamo l'element Checkbox.
Non <checkbox> ma:
<code>
<input type="checkbox" />
</code>

Le checkbox sono fondamentalmente diverse da quanto visto fin'ora, visto che ospitano delle value di tipo Boolean. Non vi saranno quindi delle value di tipo string ma delle properties checked.

Partiamo dall'esempio:

<code>
	<input type="checkbox" id="isFrindly" />
	<label htmlFor="isFriendly">Are you friendly?</label>	
</code>

Osserviamo per un momento l'element label e nalla precisione la property (attribute) htmlFor.
Quando abbiamo qualcosa come può essere una label, che é legata ad un input, vi sono un paio d'opzioni:
possiamo inserire l'input direttamente all'interno dell'element label oppure usare la property htmlFor con value l'id dell'element da legare.

Ora l'input checkbox: abbiamo una checkbox e vogliamo che la sua value venga mantenuta nello State.
Aggiungiamo la property isFriendly all'object di useState con value true.
Per associare la value dell'input non useremo qui una value property ma piuttosto una checked property, siccome una checkbox può essere o checked o unchecked la value inserita dovrà essere un boolean o una value o altro che possa essere interpretato come un boolean:

<code>
return (
		<form>
			<input
				type="text"
				placeholder="First Name"
				onChange={handleChange}
				name="firstName"
				value={formData.firstName}
			/>
			<br />
			<input
				type="text"
				placeholder="Last Name"
				onChange={handleChange}
				name="lastName"
				value={formData.lastName}
			/>
			<br />
			<input
				type="email"
				placeholder="Email"
				onChange={handleChange}
				name="email"
				value={formData.email}
			/>
			<br />
			<textarea
				placeholder="Comment here..."
				onChange={handleChange}
				name="comments"
				value={formData.comments}
			/>
			<br />
			<input type="checkbox" id="isFrindly" checked={formData.isFriendly} />
			<label htmlFor="isFriendly">Are you friendly?</label>
		</form>
	);
</code>

Risposta rapida: Checked.
Corretto :white_check_mark:

Il problema ora é che non possiamo cambiare la value clickando sulla checkbox. Creeremo quindi una modifica a handleChange per utilizzare anche la property event.target.checked oltre a event.target.value.

Partiamo da una best practice: é sempre meglio salvare l'object event destrutturandolo nelle property che ci servono, come per esempio name e value, modificando quindi anche il return:

<code>

    function handleChange(event) {
    	const [name, value] = event.target;
    	setFormData((prevFormData) => {
    		return {
    		...prevFormData,
    		[name]: value
    		};
    	});
    }

</code>

Oltre a queste due usiamo anche la property type. Questo ci aiuterà ad individuare la checkbox, per esempio, e anche la property checked per individuarne la relativa value che darà true o false in base alla scelta fatta.

Ora modifichiamo il return della funzione in modo che se il type sarà checkbox, la value salvata proverrà dalla property checked. Per fare questo sfrutteremo il Ternary Operator.

<code>
function handleChange(event) {
		const [name, value, type, checked] = event.target;
		setFormData((prevFormData) => {
			return {
				...prevFormData,
				[name]: type === "checkbox" ? checked : value
			};
		});
	}
</code>

Così facendo però avremo un bug.
Challange:
Cosa manca?
La property name nell'input.
Corretto :white_check_mark:

## 47. Build a Meme generator | Forms in React.js: Radio Buttons

In React.js i Radio Buttons sono un'interessante combinazione di checkbox e text inputs.

Partiamo dal codice:
<code>

    <fieldset>
    				<legend>Current employment status</legend>
    				<input type="radio" id="unemployed" />
    				<label htmlFor="unemployed">Unemployed</label>
    				<br />
    				<input type="radio" id="part-time" />
    				<label htmlFor="part-time">Part-Time</label>
    				<br />
    				<input type="radio" id="full-time" />
    				<label htmlFor="full-time">Full-Time</label>
    				<br />
    </fieldset>

</code>

Ora lo connettiamo al nostro State:
<code>

    const [formData, setFormData] = React.useState({
    	firstName: "",
    	lastName: "",
    	email: "",
    	comments: "",
    	isFriendly: true,
    	employment: ""
    });

</code>

In modo similare agli input quando una checkbox é true o false, viene assegnata una text value.
In pratica quando l'utente preme su un radio button, la value di tale radio button viene salvata nella property employment come string value.

Per fare in modo di associare tale value con l'object e impedire che si possano selezionare anche tutti i radio button contemporaneamente, si ha bisogno di assegnare una property name ad ognuno degli input. Queste property name dovranno essere tutte uguali e nel nostro caso avere value employment:

<code>
<fieldset>
				<legend>Current employment status</legend>
				<input type="radio" id="unemployed" name="employment" />
				<label htmlFor="unemployed">Unemployed</label>
				<br />
				<input type="radio" id="part-time" name="employment" />
				<label htmlFor="part-time">Part-Time</label>
				<br />
				<input type="radio" id="full-time" name="employment" />
				<label htmlFor="full-time">Full-Time</label>
				<br />
			</fieldset>
</code>

Questo viene fatto per impedire la selezione multipla ed assegnare una sola value per volta alla property employment nell'object State, basata sull'input selezionato.

Assegneremo poi una property value ai vari input con value corrispondente alla value dell'id.

Aggiungeremo anche la possibilità di cogliere gli events change quindi aggiungeremo un onChange event listener con value {handleChange}.

<code>
<fieldset>
				<legend>Current employment status</legend>
				<input
					type="radio"
					id="unemployed"
					name="employment"
					value="unemployed"
					onChange={handleChange}
				/>
				<label htmlFor="unemployed">Unemployed</label>
				<br />
				<input
					type="radio"
					id="part-time"
					name="employment"
					value="part-time"
					onChange={handleChange}
				/>
				<label htmlFor="part-time">Part-Time</label>
				<br />
				<input
					type="radio"
					id="full-time"
					name="employment"
					value="full-time"
					onChange={handleChange}
				/>
				<label htmlFor="full-time">Full-Time</label>
				<br />
			</fieldset>
</code>

Parlando tecnicamente adesso i Radio Buttons sono aggangiati (Hooked Up) correttamente allo State.

Qui arriva la differenza tra checkboxes e radio buttons: per controllare la value salvata dovrò usare una property checked, ma non protrà avere la stessa value {formData.employment} allo stesso modo della checkbox visto che vi é una text value e non boolean, ma possiamo usare una comparazione con la value dello stesso input per ottenere un Boolean, come:

<code>
<fieldset className="radioContainer">
				<legend>Current employment status</legend>
				<input
					type="radio"
					id="unemployed"
					name="employment"
					value="unemployed"
					checked={formData.employment === "unemployed"}
					onChange={handleChange}
				/>
				<label htmlFor="unemployed">Unemployed</label>
				<br />
				<input
					type="radio"
					id="part-time"
					name="employment"
					value="part-time"
					checked={formData.employment === "part-time"}
					onChange={handleChange}
				/>
				<label htmlFor="part-time">Part-Time</label>
				<br />
				<input
					type="radio"
					id="full-time"
					name="employment"
					value="full-time"
					checked={formData.employment === "full-time"}
					onChange={handleChange}
				/>
				<label htmlFor="full-time">Full-Time</label>
				<br />
			</fieldset>
</code>

Ora React.js é in grado di controllare questi input piuttosto che questi input abbiano un proprio State.

## 48. Build a Meme generator | Forms in React.js: Select & Option

L'ultimo Form Element di cui parleremo é la Select Box con le sue Options.

Questo sarebbe come dovrebbe essere nell'HTML, come già visto.
<code>

    <select id="favColor">
    	<option value="red">Red</option>
    	<option value="orange">Orange</option>
    	<option value="yellow">Yellow</option>
    	<option value="green">Green</option>
    	<option value="blue">Blue</option>
    	<option value="indigo">Indigo</option>
    	<option value="violet">Violet</option>
    </select>

</code>

In React.js si é optato per qualcosa di più simile agli input box.

Aggiungiamo la property favColor="" all'object State.
<code>

const [formData, setFormData] = React.useState({
firstName: "",
lastName: "",
email: "",
comments: "",
isFriendly: true,
employment: "",
favColor: ""
});

</code>

Quindi nell'element aggiungiamo sia la property value con value {formData.favColor} che l'event handler onChange come per gli altri input:

<code>
						<select id="favColor" value={formData.favColor} onChange={handleChange}>
</code>

Per essere sicuri che handleChange funzioni correttamente occorre aggiungere inoltre una property name come per gli altri input con la value che rispecchi la property nell'object:

<code>
			<select
				id="favColor"
				value={formData.favColor}
				onChange={handleChange}
				name="favColor"
			>
</code>

Ora tutto funziona correttamente e l'object State viene aggiornato ad ogni option selezionata.

Ora sistemiamo un piccolo bug: anche se l'object State viene inizializzato con value vuota "" non abbiamo comunque un option con una value vuota.

Una semplice soluzione é quella di aggiungere come prima option, una nuova option:
<code>

    <option value="">--- Choose Color ---</option>

</code>

Ora per l'argomento Form resta solo come Submit un Form.

## 49. Build a Meme generator | Forms in React.js: Submit a form

Ora che abbiamo modo di raccogliere queste informazioni dai nostri utenti, dobbiamo essere in grado di Inviare il Form.

In HTML é comune l'input type submit, che altro non é che un button, in HTML5 é stata inserita la possibilità di aggiungere un semplice Button che agirà allo stesso modo senza la necessità di altre properties, visto che avrà come type di default "submit" se si trova all'interno del form element.

Anche in React.js creeremo il semplice button come HTML5, senza bisogno di altre complicazioni.
Aggiungeremo inoltre un event handler onSubmit con value una nuova funzione, chiamandola handleSubmit per restare coerenti.

<code>
return (
		<form onSubmit={handleSubmit}>
			<input
				type="text"
				placeholder="First Name"
				onChange={handleChange}
				name="firstName"
				value={formData.firstName}
			/>
			<br />
			<input
				type="text"
				placeholder="Last Name"
				onChange={handleChange}
				name="lastName"
				value={formData.lastName}
			/>
			<br />
			<input
				type="email"
				placeholder="Email"
				onChange={handleChange}
				name="email"
				value={formData.email}
			/>
			<br />
			<textarea
				value={formData.comments}
				placeholder="Comment here..."
				onChange={handleChange}
				name="comments"
			/>
			<br />
			<div className="checkboxContainer">
				<input
					type="checkbox"
					id="isFriendly"
					checked={formData.isFriendly}
					onChange={handleChange}
					name="isFriendly"
				/>
				<label htmlFor="isFriendly">Are you friendly?</label>
			</div>
			<br />
			<fieldset className="radioContainer">
				<legend>Current employment status</legend>
				<input
					type="radio"
					id="unemployed"
					name="employment"
					value="unemployed"
					checked={formData.employment === "unemployed"}
					onChange={handleChange}
				/>
				<label htmlFor="unemployed">Unemployed</label>
				<br />
				<input
					type="radio"
					id="part-time"
					name="employment"
					value="part-time"
					checked={formData.employment === "part-time"}
					onChange={handleChange}
				/>
				<label htmlFor="part-time">Part-Time</label>
				<br />
				<input
					type="radio"
					id="full-time"
					name="employment"
					value="full-time"
					checked={formData.employment === "full-time"}
					onChange={handleChange}
				/>
				<label htmlFor="full-time">Full-Time</label>
				<br />
			</fieldset>
			<br />
			<br />
			<select
				id="favColor"
				value={formData.favColor}
				onChange={handleChange}
				name="favColor"
			>
				<option value="">--- Choose Color ---</option>
				<option value="red">Red</option>
				<option value="orange">Orange</option>
				<option value="yellow">Yellow</option>
				<option value="green">Green</option>
				<option value="blue">Blue</option>
				<option value="indigo">Indigo</option>
				<option value="violet">Violet</option>
			</select>
			<br />
			<br />
			<button>Submit</button>
		</form>
	);
</code>

Invece di far cogliere tutti i dati all'ultimo secondo e mandarli ad un'API per esempio, noi possiamo usare infine l'object State che é già stato aggiornato con tutti i dati raccolti di volta in volta per ogni input compilato o selezionato.

Un problema da risolvere é che quando viene clickato il Button Submit, di default la pagina viene riaggiornata. Questo comportamento risale ai vecchi tempi.
Per risolverlo cogliamo l'object event in entrata come paramento alla funzione handleSubmit e utilizziamo il metodo
event.preventDefault(). Questo impedirà il ricaricamento e quindi che l'App venga renderizzata nuovamente.

Tale funzione handleSubmit sarà:

<code>

    function handleSubmit(event) {
    	event.preventDefault();
    		// submitToApi(formData); Immaginaria
    	console.log(formData);
    }

</code>

## 50. Build a Meme generator | Forms in React.js: Form Quiz!

1- Quando viene clickato il button Submit avviene la raccolta dei dati compilati, appena prima che il form venga inviato.

Corretto :white_check_mark:

2- Ad ogni inserimemto di dati in un qualsiasi input viene aggiornato lo State, quindi al momento del submit tutti i dati sono già pronti per essere inviati.

Corretto :white_check_mark:

3- (No Value) Name deve corrispondere con il name della property salvata nell'object State.

SBAGLIATO --> Name!!!

4- Nelle checkbox ci si basa sulla property checked invece che su quella value, visto che i valori salvati sono boolean.

Corretto :white_check_mark:

5- Con un onSubmit event handler, con un semplice button inserito all'interno dell'element form che di default attiverà l'event submit al click. Occorre ricordare il prevent default nella funzione handler dell'event per evitare il reload dell'App.

Corretto :white_check_mark:

## 51. Build a Meme generator | Forms in React.js: Sign up form practice

Challange:
Connettere il Form dato con uno Local State ed aggiornare tale State ogni volta che l'utente interagisce con tale form.
Creare una singola handleChange function che gestisca lo State di tutti gli input e li imposti correttamente.
Quando viene clickato "Sign up" eseguire un controllo se la password e la confermation corrispondono. Se sì, log Successfully signed up altrimenti passwords do not match.
Quando il Form verrà inviato (Submit) se la checkbox é selezionata log "Thanks for signing up for our newsletter!"

<code>
export default function FormChallange() {
	const [formData, setFormData] = React.useState({
		email: "",
		password: "",
		confPassword: "",
		okayToEmail: false
	});

    function handleSubmit(event) {
    	event.preventDefault();
    	if (
    		formData.password &&
    		formData.confPassword &&
    		formData.password === formData.confPassword
    	) {
    		console.log("Successfully signed up");
    		formData.okayToEmail &&
    			console.log("Thanks for signing up for our newsletter!");
    	} else {
    		console.log("Passwords do not match");
    	}
    }

    function handleChange(event) {
    	const { name, value, type, checked } = event.target;
    	setFormData((prevFormData) => {
    		return {
    			...prevFormData,
    			[name]: type === "checkbox" ? checked : value
    		};
    	});
    }
    return (
    	<div className="form-container">
    		<form className="form" onSubmit={handleSubmit}>
    			<input
    				type="email"
    				placeholder="Email address"
    				className="form--input"
    				onChange={handleChange}
    				name="email"
    				value={formData.email}
    			/>
    			<input
    				type="password"
    				placeholder="Password"
    				className="form--input"
    				onChange={handleChange}
    				name="password"
    				value={formData.password}
    			/>
    			<input
    				type="password"
    				placeholder="Confirm password"
    				className="form--input"
    				onChange={handleChange}
    				name="confPassword"
    				value={formData.confPassword}
    			/>

    			<div className="form--marketing">
    				<input
    					type="checkbox"
    					id="okayToEmail"
    					checked={formData.okayToEmail}
    					onChange={handleChange}
    					name="okayToEmail"
    				/>
    				<label htmlFor="okayToEmail">I want to join the newsletter</label>
    			</div>
    			<button className="form--submit">Sign up</button>
    		</form>
    	</div>
    );

}
</code>

Corretto :white_check_mark:

## 52. Build a Meme generator | Project: Add text to Image

Ora che abbiamo imparato a salvare i dati inseriti in un text field nello State, siamo vicini al completamento dell'App Meme Generator.

Challange:
Imposta lo State e gli elements in modo che venga salvato il testo scritto nelle relative variabili già esistenti.
Sostituisci le value hard coded degli input con i valori delle variabili salvate.

<code>
export default function Meme() {

    const [meme, setMeme] = React.useState({
    	topText: "",
    	bottomText: "",
    	randomImage: ""
    });

    console.log(meme);

    const [allMemeImages, setAllMemesImages] = React.useState(memesData);

    function getMemeImage() {
    	const memesArray = allMemeImages["data"]["memes"];
    	const randomNumber = (Math.random() * memesArray.length).toFixed(0);
    	setMeme((prevMeme) => {
    		return {
    			...prevMeme,
    			randomImage: memesArray[randomNumber].url
    		};
    	});

    	// setIsGoingOut((prevIsGoingOut) => !prevIsGoingOut);
    }

    function handleChange(event) {
    	const { name, value } = event.target;
    	setMeme((prevMeme) => {
    		return {
    			...prevMeme,
    			[name]: value
    		};
    	});
    }

    return (
    	<main>
    		<div className="form">
    			<input
    				type="text"
    				className="form--input"
    				placeholder="Top text"
    				name="topText"
    				value={meme.topText}
    				onChange={handleChange}
    			/>
    			<input
    				type="text"
    				className="form--input"
    				placeholder="Bottom text"
    				name="bottomText"
    				value={meme.bottomText}
    				onChange={handleChange}
    			/>
    			<button onClick={getMemeImage} className="form--button">
    				Get a new meme image 🖼
    			</button>
    		</div>
    		<div className="meme">
    			<img src={meme.randomImage} className="meme--image" />
    			<h2 className="meme--text top">{meme.topText}</h2>
    			<h2 className="meme--text bottom">{meme.bottomText}</h2>
    		</div>
    	</main>
    );

}
</code>

Corretto :white_check_mark:
Perfetto.

## 53. Build a Meme generator | Making API Calls

Una delle cose più comuni che si fanno in un React.js App é comunicare con un'API che vive all'esterno della nostra Applicazione.
Di solito si richiedono informazioni ad un'API o si inviano infomazioni ad un'API. E solitamente quando le si richiede vogliamo usare tali informazioni in qualche modo.

Richiedere informazioni ad un'API in React.js consiste di solito in due parti:

- GET the Data - si usa fetch o altri tool come Axios
- Save the Data - si salvano i dati nello State

Una volta salvati nello State i dati possono essere analizzati, visualizzati e tutto ciò di cui abbiamo bisogno.

Analizziamo con degli errori e capiamo perché non funzionerà questo primo metodo.

Come test useremo la Star Wars API.

Usiamo fetch:
<code>

    fetch("https://swapi.dev/api/people/1")
    	.then((res) => res.json())
    	.then((data) => console.log(data));

</code>

Creiamo lo State:
<code>

    const [starWarsData, setStarWarsData] = React.useState({});

</code>

Quindi:
<code>

    fetch("https://swapi.dev/api/people/1")
    	.then((res) => res.json())
    	.then((data) => setStarWarsData(data));

</code>

I dati vengono ricevuti, ma il problema é che l'App viene renderizzata in un Loop infinito.

Challange:
Perché avviene questo?
Perché fetch restituisce sempre una promise, che si esegue dopo i flow principale, modificando di conseguenza lo State, che porta a renderizzare di nuovo l'App e conseguentemente eseguire il codice ed eseguire un altro fetch.

Corretto :white_check_mark:

Il problema non si presentava quando non usavamo setStarWarsData per modificare lo State, tornando al console.log iniziale infatti non si avrà quest'effetto.

Questo ci porta all'argomento successivo, gestire i side effects in React.js.

## 54. Build a Meme generator | Intro to useEffect

Qui impareremo a gestire i Side Effects, un argomento molto importante in React.js.

Per capire cosa sono di preciso i Side Effects, capiamo quali sono le task primarie di React.js:

- Per prima cosa React.js é incaricato di lavorare con il DOM del browser per renderizzare una User Interface nella pagina

- React.js inoltre gestisce lo State per noi tra i vari cicli di render. Le value dello State vengono ricordate tra un render e un altro. Noi siamo in grado di agganciarci con lo State tramite l'Hook useState.

- La combinazione dei due precedenti serve per mantenere la User Interface aggiornata quando avvengono dei cambiamenti nello State

Quindi cosa React.js non é capace di gestire da solo?

- Ogni tipo di (Out)side Effects - ogni cosa che vive fuori dalla Preview (detta anche Reach) di React.js. Alcuni esempi possono essere:

• Il localStorage - si può aggiungere del codice per accedere al localStorage ma React.js non interagisce nella gestione del localStorage

• API / database interactions - possiamo scrivere del codice per gestire tali API ma React.js non sarà incaricato di tale con quel codice, o meglio React.js non sarà in grado sapere quale API stiamo cercando di raggiungere

• Subscriptions - come possono essere i websockets

• Sincronizzazione di due diversi State interni - può intergire con entrambi gli State, ma non modifiche tra i due State

• Tutto ciò per cui React.js non é incaricato

Per gestire problemi come quelli dell'esempio di API visto in precedenza é stato creato un Hook chiamato useEffect().
Nella documentazione viene chiamato l'"Effect Hook".
Questo é un tool, che similarmente ad un Canvas bianco, ci permette di interagire fuori dall'ecosistema di React.js, che in modo ridotto consiste nello State, nelle Props e la User Interface che viene visualizzata nella pagina.
Occorre immaginare useEffect() come un tool che ci permette di sincronizzare lo State di React.js con questi sistemi esterni, come localStorage o un'API ecc.

Link da studiare:

https://reactjs.org/docs/hooks-effect.html

Non necessario, per approfindire in seguito:
https://overreacted.io/a-complete-guide-to-useeffect/

Una volta studiato il link della documentazione andreamo a capire come gestire questi Side Effects in React.js.

Da documentazione:

Distinzione dei Side Effects - che necessitano il Cleanup o che non lo necessitano.
A volte vogliamo eseguire del codice addizionale dopo che React.js ha aggiornato il DOM. Le richieste di rete (Network requests), le mutazioni manuali del DOM ed il logging sono esempi comuni di Side Effects che non necessitano del Cleanup.
Queste possono essere eseguite immediatamente e poi possiamo dimenticarcene.

  <code>
  function Example() {

      const [count, setCount] = useState(0);

      	useEffect(() => {
      		document.title = `You clicked ${count} times`;
      	});

return (

  <div>
  <p>You clicked {count} times</p>
  <button onClick={() => setCount(count + 1)}>
  Click me
  </button>
  </div>
  );
  }
  </code>

Cosa fa useEffect in quest'esempio?

Usando questo Hook si va a dire a React.js che il Component ha bisogno di fare qualcosa dopo il render. React.js ricorderà la funzione passata (a cui ci si riferisce come Side Effect / Effect), e la chiamerà dopo aver eseguito gli aggiornamenti del DOM. In quest'esempio abbiamo impostato il titolo del document, ma possiamo anche eseguire un data fetching o chiamare altre API imperative.

Perché useEffect viene chiamato all'interno di un Component?

Inserire useEffect dentro un Component ci permette di accedere alla State variable "count" o qualsiasi altra prop esattamente dalla funzione Side Effect / Effect. Non avremo bisogno di una qualche API per leggerla, é già nello scope della funzione. Gli Hook abbracciano il principio delle Closure in JavaScript ed evitano di introdurre API specifiche di React.js dove JavaScript fornisce già una soluzione.

L'Hook useEffect si esegue dopo ogni render?
Sì, Di default si esegue sia prima del primo render che dopo ogni aggiornamento del DOM. In seguito si parlerà di come modificare questo comportamento. Invece di pensare in termini di "Mounting" e "Updating", si può trovare più facile pensare al fatto che gli Effects avvengono "dopo il render". React.js garantisce che il DOM sia caricato in tempo prima che si eseguano gli Effects.

Basandoci sull'esempio soprastante:

- dichiariamo la nostra State variable count
- diciamo a React.js che abbiamo bisogno di usare un Effect
- passiamo la funzione all'Hook useEffect(), questa sarà esattamente il nostro Effect
- dentro l'Effect impostiamo il titolo usando l'API del browser. Possiamo leggere lo State count dentro l'Effect perché é nello scope della nostra function.
- quando React.js renderizza il nostro Component si ricorda dell'Effect che abbiamo usato, e lo esegue dopo aver aggiornato il DOM.
- questo avviene per ogni render, incluso il primo

Un particolarità rispetto ad altri metodi sta nel fatto che useEffect non blocca il browser dall'aggiornare lo schermo. Questo rende l'App più Responsive.
La maggior parte degli Effects non necessita che accada in modo sincrono. Nei casi non comuni dove lo si necessita, come per esempio la misurazione del layout, esiste un Hook separato denominato setLayoutEffect con un API identica a useEffect.

Questo era tutto inerente ai Side Effects che non necessitano del Cleanup. Ora tratteremo quelli che lo necessitano. Per esempio vorremmo impostare una sottoscrizione a qualche sorgente dati esterna. In tale caso é importante usare il Cleanup, in modo che non ci porti ad una perdita di memoria.
Anche se concettualmente si potrebbe pensare di separare l'Effect dal Cleanup, useEffect é disegnato per mantenerli insieme. Se l'Effect restituisce una funzione, React.js la eseguirà al momento del Cleanup.

Per esempio, diciamo di avere un modulo ChatAPI che ci permetta di sottoscriverci allo status online di un amico. Ecco come potremmo sottoscriverci a tale status e disiscriverci nella fase di Cleanup:

<code>

    function FriendStatus(props) {
    	const [isOnline, setIsOnline] = useState(null);

    	useEffect(() => {
    		function handleStatusChange(status) {
    		setIsOnline(status.isOnline);
    		}
    		ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    		// Specify how to clean up after this effect:
    		return function cleanup() {
    			ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    		};
    });

    if (isOnline === null) {
    return 'Loading...';
    }
    return isOnline ? 'Online' : 'Offline';
    }

</code>

Perché si restituisce (return) una funzione dal nostro Side Effect?

Questo é un meccanismo opzionale di Cleanup per gli effects. Ogni Effect può restituire una funzione che usa il Cleanup dopo si questo. Questo ci permette di mantenere le logiche per aggiungere e rimuovere le Subscriptions vicine tra di loro, visto che sono parte dello stesso Effect.

Quando esattamente React.js usa il Cleanup su un Effect?

React.js esegue il Cleanup quando si smontano dei Components. Comunque, come imparato prima, gli effects si eseguono per ogni render, non solo per il primo. Per questo motivo React.js esegue il Cleanup negli Effects anche dal precedente render prima di eseguire l'Effect la volta successiva.
Si discuterà del perché aiuti nell'evitare bug e come ovviare a questo comportamento in una fase successiva.
La funzione restituita dall'Effect non deve avere un name per forza. Si può restituire anche una Arrow function o chiamarla in un altro modo.

<code>
useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };

});
</code>

Esiste un secondo parametro per useEffect. Visto che un comportamento comune é quello di saltare un Effect se qualcosa NON é cambiato, impostando la State variable come secondo parametro, useEffect rileverà se questa é stata aggiornata o meno e se lo fosse stata esguirà l'Effect, altrimenti no. Se la State variable fosse un Array, l'Effect si esguirebbe a che se solo uno degli elements si tale Array si fosse modificato.
Il secondo parametro funziona anche con Effects che restituiscono una funzione di Cleanup.
Occorre sempre assicurarsi in caso di Array che tutte le values a cui fa riferimento siano nello Scope del Component, altrimenti potrebbero fare riferimento a values del render precedente.
Se si vuole eseguire un Effect e la fase di Cleanup solo una volta basta passare un Empty array [] come secondo argument. Questo dirà a React.js che l'Effect non dipende da nessuna value dalle Prop o dallo State, quindi non avrà mai bisogno di rieseguirsi.

Fine appunti da Documentazione.

## 55. Build a Meme generator | useEffect() sintax and default behavior

Ora rifattorizzeremo l'esempio iniziale usando l'Hook useEffect.

Nel nostro esempio fetch é un Side Effect, visto che va a richiedere qualcosa all'esterno dell'ecosistema di React.js, ma inoltre imposta un State nel processo.

Useremo quindi:
<code>

    React.useEffect(() => {
    	fetch("https://swapi.dev/api/people/1")
    		.then((res) => res.json())
    		.then((data) => setStarWarsData(data));
    });

</code>

Questo però é solo metà del processo, per evitare il loop infinito dovremo usare il secondo parametro di useEffect.
Se non forniamo questo parametro questa continuerà a ripetersi non distinguendo se la variabile é già aggiornata o no.

## 56. Build a Meme generator | useEffect dependencies array

Modifichiamo il nostro esempio per notare effettivamente che il Side Effect di useEffect si esegue dopo il render del Component:

<code>
const [starWarsData, setStarWarsData] = React.useState({});

const [count, setCount] = React.useState(0);

    console.log("Component rendered");

    React.useEffect(() => {
    	console.log("Effect ran");
    	// fetch("https://swapi.dev/api/people/1")
    	// 	.then((res) => res.json())
    	// 	.then((data) => setStarWarsData(data));
    });

</code>

Aggiungiamo inoltre:
<code>
<button onClick={() => setCount(prevCount => prevCount + 1)}>Add</button>
</code>

Questo per aggiornare il count e di conseguenza modificarne la value e renderizzare nuovamente il Component.

Nell'ordine:
• Al click viene aggiornato lo State che passa da 0 a 1.
• Avviene l'aggiornamento della UI, così viene mostrato il corretto valore di "count"
• Viene eseguito l'Effect con il relativo console.log

Qui entra in gioco il secondo parametro, che é qualcosa che viene inserito quasi sempre. Viene chiamato il Dependecies Array.

Questo come visto sopra é un Array di values che se cambiano causano l'esecuzione del Side Effect. Limita il numero di volte in cui l'Effect viene eseguito, determina quando viene eseguito invece di essere eseguito per ogni render.
Lasciando un Array vuoto imposta l'esecuzione dell'Effect solo al primo render.

Per verificarlo basta clickare il button e basarsi sui log.

<code>
React.useEffect(() => {
		console.log("Effect ran");
		// fetch("https://swapi.dev/api/people/1")
		// 	.then((res) => res.json())
		// 	.then((data) => setStarWarsData(data));
	}, []);
</code>

Per far eseguire l'Effect ad ogni modifica del count dovrò includerlo nelle dependencies come element dell'Array:

<code>
React.useEffect(() => {
		console.log("Effect ran");
		// fetch("https://swapi.dev/api/people/1")
		// 	.then((res) => res.json())
		// 	.then((data) => setStarWarsData(data));
	}, [count]);
</code>

Challange:
Cosa avviene se imposto una hard coded value di 0 nell'Array?

Al click del button non viene eseguito il Side Effect.

Questo avviene perché la value di 0 sarà sempre comparata con 0, nella comparazione immaginaria, visto che non verrà eseguito altre volte dopo la prima.

Challange:
Riscrivi useEffect in modo che esegua il console.log solo alla modifica della value di count.

<code>
React.useEffect(() => {
		console.log("Effect function ran");
	}, [count]);
</code>

Corretto :white_check_mark:

Come nota: si può destrutturare useEffect in:
import React, {useState, useEffect} from "react"

Per chiarezza useremo il precendete modo.

## 57. Build a Meme generator | useEffect Quiz!

1. Un Side Effect é una funzione, passata in genere a useEffect(), che si esegue dopo che la UI é stata renderizzata.
   Alcuni esempi possono essere il fetch di dati da un'API o il salvataggio di dati sul localStorage o la modifica imperative del DOM tramire la browser API.
   In sintesi un Side Effect é tutto ciò che esce dall'ecosistema di React.js.

   Altri esempi websocket.

Corretto :white_check_mark:

Tutto il codice che crea degli effetti su un sistema esterno.

2. Non é un Side Effect tutto ciò che rientra nell'ecosistema di React.js, come renderizzare i vari Component.
   Mantenere lo State, sincronizzare la UI con i dati.

Corretto :white_check_mark: 1/2

3. useEffect viene eseguito ogni volta che il component é stato renderizzato, se vi é una modifica allo State al quale viene associato.
   In ogni caso viene sempre eseguito al primo render del Component al quale viene associato.
   Per facilitare questa operazione si sfrutta nella maggior parte dei casi il secondo parametro di useEffect, dove la prima é l'Effect stesso, che altro non é che una variabile, o un Array detto Dependencies Array, che verrà monitorato e in caso di cambiamenti della value che porterà al rieseguirsi o meno del Side Effect.

Corretto :white_check_mark:

4. Un dependencies Array é il secondo parametro di useEffect, un Array formato da tutte le variabili convolte nel processo, le quali in caso di cambiamento porteranno alla riesecuzione del Side Effect, vedi sopra.

Corretto :white_check_mark:

## 58. Build a Meme generator | useEffect for fetching data

Challange:
Cosa succede se imposto useEffect in questo modo?
<code>
React.useEffect(() => {
// console.log("Effect function ran");
fetch("https://swapi.dev/api/people/1")
.then((res) => res.json())
.then((data) => console.log(data));
}, [count]);
</code>

Risposta senza guardare console:
Vengono richiesti e ricevuti i dati al primo render, visualizzandoli nella console, poi di nuovo fecthati per ogni click del button Add.

Corretto :white_check_mark:

Challange:

E con questo?
<code>
React.useEffect(() => {
// console.log("Effect function ran");
fetch("https://swapi.dev/api/people/1")
.then((res) => res.json())
.then((data) => console.log(data));
}, [count]);
</code>

Risposta senza guardare console:
Vengono richiesti e ricevuti i dati al primo render, visualizzandoli nella UI, poi di nuovo fetchati e reinseriti nell UI per ogni click del button Add.
Non si otterrà il loop visto che ora useEffect si basa sulla variabile count.
Non dimenticare che lo State viene aggiornato come fase mentale dei passaggi.

Corretto :white_check_mark:

Challange:

Per essere corretto completamente, cosa dovrebbe esserci al posto della variabile count in useEffect?

Forse un parametro dell'URL salvato in una variabile esterna ma sempre nello Scope dell'Effect
Forse i dati stessi, in modo che se variano vengano renderizzati nuovamente, ma troppo articolato.
Di certo non la variabile dello State, altrimenti cadremo nuovamente nel loop.

ERRATO.

Risposta corretta:
Se si vuole ricavare i dati solo una volta all'avvio dell'App occorre inserire [].

## 59. Build a Meme generator | useEffect: when to use dependencies

Challange:
Combinare il "count" con la URL della request. Premendo il Button si otterrà così un nuovo character dall'API.
Non dimenticare di considerare il Dependencies Array.

<code>
React.useEffect(() => {
		// console.log("Effect function ran");
		fetch(`https://swapi.dev/api/people/${count}`)
			.then((res) => res.json())
			.then((data) => setStarWarsData(data));
	}, [count]);
</code>

Corretto :white_check_mark:

Mini Challange:
Che non si otterrà il next character, il Side Effect con [] viene eseguito solo al primo render.

Corretto :white_check_mark:

## 60. Build a Meme generator | Project: Get memes from API

Ottieni i dati per il Meme component da un'API invece che dal file di dati.
Salva solo la parte dell'Array memes.
Ci sono dependencies?

Soluzione:
No non ci sono dependencies: secondo argument [].
Non ci sono motivi per avere variabili che al loro change di value si necessiti un nuovo render.

Corretto :white_check_mark:

<code>
const [meme, setMeme] = React.useState({
		topText: "",
		bottomText: "",
		randomImage: ""
	});

    console.log(meme);

    const [allMemes, setAllMemes] = React.useState();

    React.useEffect(() => {
    	fetch("https://api.imgflip.com/get_memes")
    		.then((res) => res.json())
    		.then((data) => {
    			console.log(data);
    			setAllMemes(data["data"]["memes"]);
    		});
    }, []);

    function getMemeImage() {
    	const randomNumber = (Math.random() * allMemes.length).toFixed(0);
    	setMeme((prevMeme) => {
    		return {
    			...prevMeme,
    			randomImage: allMemes[randomNumber].url
    		};
    	});

    	// setIsGoingOut((prevIsGoingOut) => !prevIsGoingOut);
    }

    function handleChange(event) {
    	const { name, value } = event.target;
    	setMeme((prevMeme) => {
    		return {
    			...prevMeme,
    			[name]: value
    		};
    	});
    }

</code>

Corretto :white_check_mark:

Challange:

Risolvi il bug.

Già risolto nella soluzione sopra:
Levare la variabile memesArray che salvava la value data["data"]["memes"], usare per il calcolo random lo State allMemes.

Corretto :white_check_mark:

Si sarebbe tentati si usare async await per la fetch, ma con la semplice modifica della funzione Effect non funzionerebbe.
Capiremo perché nella prossima sezione.

## 61. Build a Meme generator | State and Effect Practice

Challange:

Creare, con le impostazioni dei Component date, uno State "show" con value di default true.
Quando il Button viene premuto, toogle sulla value di "show".
Si visualizzi il Component WindowTracker se "show" ha value true.

<code>
const [show, setShow] = React.useState(true);

    function toggleShow() {
    	setShow((prevShow) => {
    		return !prevShow;
    	});
    }

    	<div className="windowTrackerContainer">
    				<button onClick={toggleShow}>Toggle WindowTracker</button>
    				{show && <WindowTracker />}
    	</div>

</code>

Corretto :white_check_mark:

Ora qualcosa da osservare:
Se faccio scomparire il Component e ridimensiono la pagina, quando lo farò ricomparire otterrò la dimensione effettiva della pagina, non la value precedente.
Questo avviene quando il Component viene fatto scomparire viene per definizione "unmounted" (smontato), cioé completamente rimosso dal DOM. Quando lo facciamo ricomparire (remounted) viene rieseguita la property window.innerWidth che mi fornisce una versione aggiornata della value.

Si può comunque fare meglio: potremmo aggiungere un Event Listener resize alla window, in modo che al resize, grazie anche all'aggiunta di uno State nel Component, ci fornisca la value attuale della innerWidth.

Visto che dobbiamo aggiungere un Event Listener alla window occorre del codice Imperative più articolato.
Dobbiamo interagire quindi con un sistema esterno al WindowTracker Component, cioé la window stessa.

Challange:
Quale tool fornisce React.js per interagire con sistemi esterni e mantenere il local State sincronizzato con questi?

useEffect().

Corretto :white_check_mark:

Quindi imposto un Effect.
Come secondo parametro per useEffect non posso utilizzare window.innerWidth, questa é una value costante che non si aggiorna da sola, quindi non é utile.

Quindi aggiungiamo nell'Effect un Event Listener nell'object window con un semplice console.log per indicare il resize.

<code>
React.useEffect(() => {
		window.addEventListener("resize", () => {
			console.log("resized");
		});
	}, []);
</code>

NOTA: aggiungere un Event Listener direttamente sull'object window in JavaScript é una Bad Practice, va bene solo per scopi didattici.

Challange:
Crea uno State chiamato windowWidth, con value di default window.innerWidth.
Quando la width della window cambia, si aggiorni lo State.
Si visualizzi la window width nell'h1 in modo che si aggiorni ogni volta che la dimensione della pagina subisce una variazione.

<code>
export default function WindowTracker() {
	const [windowWidth, setWindowWidth] = React.useState(window.innerWidth);

    React.useEffect(() => {
    	window.addEventListener("resize", () => {
    		console.log("resized");
    		setWindowWidth(window.innerWidth);
    	});
    }, []);

    return <h1>Window width: {windowWidth}</h1>;

}
</code>

Corretto :white_check_mark:

Ora osserviamo un piccolo bug che sopraggiunge:
Ricordiamo che il render del Component WindowTracker é condizionato dalla value della variabile show, quindi se tale variabile é false il Component non sarà montato (mounted). Ogni volta che la pagina viene ridimensionata l'Event Listener resize eseguirà la funzione. Quella funzione é registrata con il DOM stesso, quindi anche se farà scomparire il Component e ridimensionerò la pagina avrò un Warning nella console che ci segnalerà la mancata registrazione dell'Event Listener a causa del Component unmonuted.
Quindi il Component non sarà parte del DOM, ma il browser stesso é ancora in fase di Listening per l'Event resize e proverà ad impostare lo State in un Component unmounted.
Questo tipo di bug viene chiamato "Memory Leak".
E' chiaro che non lo si vuole.

Nella prossima sezione affronteremo questo problema e vedremo cosa fare per risolverlo.

## 62. Build a Meme generator | useEffect cleanup function

Il Memory Leak é una problematica nella quale si rischia di imbattersi ogni qualvolta si imposta un Side Effect.
Per questo é importante la fase di Cleanup vista nella documentazione.

Oltre a questo che stiamo vedendo un altro esempio potrebbe essere durante la creazione delle connessioni di un websocket con una chat API un una chat App che aggiorna lo schermo o i messaggi non appena un nuovo messaggio é disponibile. Quando si crea una subscription alla chat API e poi si prova ad unmonuted il Component é sempre una buona idea separare tale connessione al Websocket come un modo per pulire (cleanup) l'Effect creato nel useEffect.
Qui si tratterà infatti la fase di Cleanup.

Pertendo dal nostro esempio:
<code>
export default function WindowTracker() {
const [windowWidth, setWindowWidth] = React.useState(window.innerWidth);

    React.useEffect(() => {
    	window.addEventListener("resize", () => {
    		console.log("resized");
    		setWindowWidth(window.innerWidth);
    	});
    }, []);

    return <h1>Window width: {windowWidth}</h1>;

}
</code>

Abbiamo una function come primo parametro di useEffect, l'Effect stesso, che però non restituisce nulla.
Possiamo restituire una funzione che sarà infatti detta di Cleanup.
Tale funzione verrà infatti usata da useEffect per pulire l'Effect creato.
In genere é sempre uno specchio dell'Effect stesso, quindi nel nostro esempio la Cleanup function comprenderà un removeEventListener.
Con removeEventListener abbiamo bisogno di passare la stessa esatta funzione che abbiamo aggiunto con addEventListener, quindi abbiamo bisogno di separare la callback presente nell'addEventListener per riutilizzarla.

<code>
React.useEffect(() => {
		function watchWidth() {
			console.log("Setting resize Event");
			setWindowWidth(window.innerWidth);
		}
		window.addEventListener("resize", watchWidth);
		return () => {
			console.log("Cleaning up resize Event");
			window.removeEventListener("resize", watchWidth);
		};
	}, []);
</code>

Così facendo sistemiamo il Memory Leak incontrato prima.

Per altri Effect non é necessario impostare una funzione di Cleanup, non é una parte necessaria di useEffect per farlo funzionare.

Tutto questo ci aiuterà anche a capire l'argomento dal quale siamo partiti: come usare async/await in useEffect.

## 63. Build a Meme generator | Using an async function inside useEffect

Come menzionato nelle parti precendenti, non siamo in grado di far funzionare con async / await il nostro Effect semplicemente aggiungendo un async davanti a tale funzione.
Come sappiamo aggiungendo un async davanti alla dichiarazione della funzione alteriamo il modo in cui tale funzione funziona.
Qualunque cosa io restituisca da una funzione async non restituisce una value pura che possiamo salvare normalemente in una variabile, ma si ottiene invece automaticamente e sempre una promise.
Proprio per questo motivo, se React.js si aspetta una funzione che venga restituita dall'Effect, si troverà di fronte a qualcosa di inaspettato in caso di una promise non sarà capace di eseguire il Cleanup nel modo che lo si vuole.
Questo si può sistemare definendo un'ulteriore funzione all'interno dell'Effect (come ipotizzato).
Partendo quindi da questo:
<code>

    React.useEffect(() => {
    	fetch("https://api.imgflip.com/get_memes")
    		.then((res) => res.json())
    		.then((data) => {
    			console.log(data);
    			setAllMemes(data["data"]["memes"]);
    		});
    	}, []);

</code>

Scriviamo la definizione funzione async:
<code>

    async function getMemes() {
    	const res = await fetch("https://api.imgflip.com/get_memes");
    	const data = await res.json();
    	setAllMemes(data["data"]["memes"]);
    }

</code>

E poi chiamiamola:

<code>
React.useEffect(() => {
		async function getMemes() {
			const res = await fetch("https://api.imgflip.com/get_memes");
			const data = await res.json();
			setAllMemes(data["data"]["memes"]);
		}
		getMemes();
	}, []);
</code>

Riassunto useEffect async:

useEffect prende una funzione come suo parametro (l'Effect stesso). Se tale funzione restituisce qualcosa, ha bisogno un una funzione di Cleanup. Altrimenti non dovrebbe restituire null. Se rendiamo tale funzione una funzione async restituirà automaticamente una promise invece di una funzione o niente.
Comunque, se si vuole usare delle operazioni async dentro a useEffect, si avrà bisogno di definire la funzione separatamente dentro alla funzione di callback (l'Effect) come mostrato.

## 64. Build a Meme generator | Section 3 Recap

In questo capitolo abbiamo studiato:

- Event Listener
- State
- Conditional Rendering
- Forms
- Side Effects

## 1. Build a Notes App and Tenzies Game | Section 4 Intro

Questa sezione é dedicata alla pratica, molta pratica.

Lavoreremo a tre progetti.

- Rivisitazione ReactFacts da prima sezione con inserimento Dark Mode con Button per toggle.

- Note App con salvataggio su Local Storage

- Tenzies Game

## 2. Build a Notes App and Tenzies Game | Warm-up: Add Dark/Light modes to ReactFacts Site

Crea una DarkMode per l'Info Site della prima sezione basandoti su CSS e Condizionali forniti nei Components per trovare la soluzione.

Soluzione:
State e funzione necessari solo in App.js:

<code>
export default function App() {
	const [darker, setDarker] = React.useState(false);

    function toggle() {
    	setDarker((prevDarker) => {
    		return !prevDarker;
    	});
    }

    return (
    	<div className="container">
    		<Navbar darkMode={darker} toggleDarkMode={toggle} />
    		<Main darkMode={darker} toggleDarkMode={toggle} />
    	</div>
    );

}
</code>

Funzionante :white_check_mark:v

## 3. Build a Notes App and Tenzies Game | Notes App Intro

Challange 1:
Ricreare il codice e capire come funziona effettivamente.
Ricreato: Funzionante :white_check_mark:

## 4. Build a Notes App and Tenzies Game | Notes App: Features to add

Le funzionalità che vogliamo implementare nella nostra Notes App:

- Sincronizzare le Notes con il localStorage - non salveremo nulla su un Database in questo progetto, ma almeno avremo qualcosa su cui salvare i dati ed i cambiamenti tra un ricaricamento e l'altro

- Aggiungere un Note Summary ed usarlo come Title nel menu, in realtà prendendo la prima riga della Note

- Ad ogni modifica far muovere nel menu la Note modificata in cima

Aggiungere la capacità di cancellare delle Notes

## 5. Build a Notes App and Tenzies Game | Notes App: sync notes with localStorage

La prima feature che andremo ad inserire sarà l'uso del localStorage.

Come visto tempo fa, per interagire con l'API localStorage useremo i metodi:

localStorage.getItem("key")

e

localStorage.setItem("key", value)

Nell'uso semplice di setItem, la value deve essere una String.
Se value fosse una value più complessa come un Object o un Array, occorrerà trasformarla in una String con:
JSON.stringify(value). Per poter utilizzare tale value dopo il getItem occorrerà quindi usare:
JSON.parse(stringifiedValue).

Challange:
Salvare nel localStorage l'Array "notes" ad ogni cambiamento. Usare JSON.stringify per la value.
Al primo caricamento dell'App, lo State "notes" dovrà essere inizializzato con i dati salvati nel localStorage.

<code>
const [notes, setNotes] = React.useState(
		JSON.parse(localStorage.getItem("notes") || [])
	);
	const [currentNoteId, setCurrentNoteId] = React.useState(
		(notes[0] && notes[0].id) || ""
	);

    React.useEffect(() => {
    	console.log("Hey");
    	localStorage.setItem("notes", JSON.stringify(notes));
    	console.log(localStorage);
    }, [notes]);

</code>

Corretto :white_check_mark:

Chiaramente localStorage non é un sostituto di un Database ma comunque abbiamo una persistenza di dati come feature inserita.

## 6. Build a Notes App and Tenzies Game | Lazy State Initialization

Quando inizializziamo uno State, come ad esempio nella Notes App dove otteniamo la value del localStorage per inizializzare la variabile "notes", otteniamo un comportamento da osservare.
Questo State viene mantenuto internamente da React.js.
Ogni qualvolta cambierò la value degli altri State, si ottiene questo comportamento per esempio inserendo una nuova note, l'intero Component App.js verrà renderizzato nuovamente. Questo significa che tutto il codice all'interno di App.js verrà eseguito nuovamente, anche il riassegnamento degli altri State non coinvolti nella modifica. Anche se nel background molto spesso questa operazione viene ignorata, vi é comunque del codice che viene rieseguito. Un esempio é appunto il getItem dal localStorage o un semplice console.log.
Sarebbe quindi da evitare questo comportamento, visto che consuma risorse e magari anche un numero considerevole nel nostro caso, e possiamo farlo usando:
il LAZY STATE INITIALIZATION.
Usando questa tecnica lo State verrà inizializzato solo una volta. Per utilizzarlo basta invece di fornire una value, inserire una funzione che restituisca una value:
<code>
const [notes, setNotes] = React.useState(
() => JSON.parse(localStorage.getItem("notes")) || []
);
</code>

Challange:
Dotare di Lazy State Initialization la variabile "notes"
<code>
const [notes, setNotes] = React.useState(
() => JSON.parse(localStorage.getItem("notes")) || []
);
</code>

Corretto :white_check_mark:

Nella prossima sezione di tratterà la feature del summary miniaturizzato.

## 7. Build a Notes App and Tenzies Game | Notes App: Note Summary

Challange:
Modifica l'algoritmo usato per formare il nome nella Note:

<code>

    const noteElements = props.notes.map((note, index) => (

    <div key={note.id}>
    		<div
    		className={`title ${
    							note.id === props.currentNote.id ? "selected-note" : ""
    						}`}
    		onClick={() => props.setCurrentNoteId(note.id)} >
    		<h4 className="text-snippet">Note {index + 1}</h4>
    		</div>
    </div>
    ));

</code>

Soluzione:
<code>

const noteElements = props.notes.map((note, index) => {
return (

    	<div key={note.id}>
    		<div
    		className={`title ${
    								note.id === props.currentNote.id ? "selected-note" : ""
    							}`}
    		onClick={() => props.setCurrentNoteId(note.id)} >
    		<h4 className="text-snippet">{note.body.split(/\r?\n/)[0]}</h4>
    		</div>
    	</div>
    	);
    });

</code>

Corretto :white_check_mark:

Probabilmente ora desidereremmo che la Note che stiamo modificando si sposti all'inizio della lista, ed é la feature che aggiungeremo nella prossima sezione.

## 8. Build a Notes App and Tenzies Game | Notes App: Bump Recent Note to the top

Challange:
Aggiungi la feature dello spostamento della Note in fase di editing in cima alla lista della Sidebar.

<code>

    function updateNote(text) {
    		setNotes((oldNotes) => {
    			let elem = oldNotes.splice(
    				oldNotes.findIndex((note) => note.id === currentNoteId),
    				1
    			)[0];
    			oldNotes.splice(0, 0, elem);
    			return oldNotes.map((oldNote) => {
    				return oldNote.id === currentNoteId
    					? { ...oldNote, body: text }
    					: oldNote;
    			});
    		});
    	}

</code>

Funzionante :white_check_mark:

Soluzione tutorial sfrutta un loop per creare un nuovo Array:
<code>

    function updateNote(text) {
    	setNotes((oldNotes) => {
    		const newArray = [];
    		for (let i = 0; i < oldNotes.length; i++) {
    			const oldNote = oldNotes[i];
    			if (oldNote.id === currentNoteId) {
    			newArray.unshift({ ...oldNote, body: text });
    			} else {
    			newArray.push(oldNote);
    			}
    		}
    		return newArray;
    	});
    }

</code>

La prossima feature che andremo ad inserire sarà quella della possibilità di cancellare delle Notes.

## 9. Build a Notes App and Tenzies Game | Notes App: Delete Note

Modifiche al codice principale da tutorial.
Aggiunto button con icon.

Challange:
Dato l'inizio funzione:
<code>

    function deleteNote(event, noteId) {
    	event.stopPropagation();
    }

</code>

Completare la funzione e si capisca come passare i due parametri durante l'event handler di onClick.

<code>
In App.js:

    function deleteNote(event, noteId) {
    	event.stopPropagation();
    	setNotes((prevNotes) => {

    	const arr = prevNotes.filter((note) => {
    	return note.id !== noteId;
    	});
    	return arr;
    	});
    }

return (

<main>
{notes.length > 0 ? (
<Split sizes={[30, 70]} direction="vertical" className="split">
<Sidebar
						notes={notes}
						currentNote={findCurrentNote()}
						setCurrentNoteId={setCurrentNoteId}
						newNote={createNewNote}
						deleteNote={deleteNote}
					/>
{currentNoteId && notes.length > 0 && (
<Editor currentNote={findCurrentNote()} updateNote={updateNote} />
)}
</Split>
) : (
<div className="no-notes">
<h1>You have no notes</h1>
<button className="first-note" onClick={createNewNote}>
Create one now
</button>
</div>
)}
</main>
);

</code>

<code>
In Sidebar.js

<button
className="delete-btn"
onClick={(event) => {
return props.deleteNote(event, note.id);
}}
<i className="gg-trash trash-icon"></i>
</button>
</code>

Funzionante :white_check_mark:
Quasi identico a tutorial

Ricordare:
Passando la callback in questo modo:
onClick={(event) => {
return props.deleteNote(event, note.id);
}}

Possiamo passare tutti i parametri che vogliamo dall'Event Handler onClick alla funzione inserendoli nella seconda parentesi tonda e passando come parametro nelle prime event.

Siamo arrivati alla fine della Notes App.

## 10. Build a Notes App and Tenzies Game | Tenzies Project Intro

Impostiamo la nuova React.js App con il codice dato, utilizziamo il design fornito su Scrimba.
Spiegazione progetto.

## 11. Build a Notes App and Tenzies Game | Tenzies Setup

Challange:
Creare App Component e style di base.

## 12. Build a Notes App and Tenzies Game | Tenzies: Components

Challange:
Creare il Die Component in modo che prenda una value prop.
Creare 10 istanze nel main.
Fornire Style.

Corretto :white_check_mark:

## 13. Build a Notes App and Tenzies Game | Tenzies: Generate array of 10 random numbers

Scrivi una funzione allNewDice che restituisca un Array di dieci numeri random in modo che siano tra 1 e 6.
Loggare l'Array nella console per ora.

<code>

    function allNewDice() {
    		let arr = [];
    		for (let i = 0; i < 10; i++) {
    			arr.push(Math.ceil(Math.random() * 6));
    		}
    		console.log(arr);
    		return arr;
    	}
    	allNewDice();

</code>

## 14. Build a Notes App and Tenzies Game | Tenzies: Map Array to Die Components

Challange:
Creare uno State che contenga in nostro Array.
Inizializzarlo chiamando allNewDice in modo che carichi tutti i nuovi Dice appena l'app viene caricata.
Mappare tra lo State i numeri generati dall'Array in modo da renderizzare questi al posto dei Die elements scritti manualmente.

<code>
const [dice, setDice] = React.useState(allNewDice());

    function allNewDice() {
    	let arr = [];
    	for (let i = 0; i < 10; i++) {
    		arr.push(Math.ceil(Math.random() * 6));
    	}
    	// console.log(arr);
    	return arr;
    }

    let diceElements = dice.map((die) => {
    	return <Die value={die} />;
    });

</code>

Corretto :white_check_mark:

Il problema della key nei Die components verrà risolto più avanti al refactor della funzione allNewDice.

## 15. Build a Notes App and Tenzies Game | Tenzies: Roll dice button

Challange:
Creare il Roll Button e visualizzare i numbers ottenuti dal click del Button nei Dice.

<code>

const [dice, setDice] = React.useState(allNewDice());

    function allNewDice() {
    	let arr = [];
    	for (let i = 0; i < 10; i++) {
    		arr.push(Math.ceil(Math.random() * 6));
    	}
    	// console.log(arr);
    	return arr;
    }

    function rollUnheldDice() {
    	setDice(allNewDice);
    }

    const diceElements = dice.map((die) => {
    	return <Die value={die} />;
    });

<button className="roll-dice" onClick={rollUnheldDice}>
				Roll
			</button>
</code>

Qui sul setDice(allNewDice), allNewDice funziona anche senza la chiamata effettiva allNewDice().

Da prestare attenzione: creare nuova funzione per utilizzare la funzione set dello State (qui setDice).

## 16. Build a Notes App and Tenzies Game | Tenzies: Changing dice to objects

Per far avere ad ogni Die l'informazione se essere bloccato o meno occorre trasformare gli integers in Objects.
Ogni object nell'Array dovrà contenere una property value, dove la value sarà il numero random e una isHeld settata su false di default. Eseguire gli opportuni cambiamenti anche nel resto del codice per far funzionare l'App come prima del cambiamento.

<code>
const [dice, setDice] = React.useState(allNewDice());

    function allNewDice() {
    	let arr = [];
    	for (let i = 0; i < 10; i++) {
    		const obj = {};
    		obj.value = Math.ceil(Math.random() * 6);
    		obj.isHeld = false;
    		arr.push(obj);
    	}
    	console.log(arr);
    	return arr;
    }

    function rollUnheldDice() {
    	setDice(allNewDice());
    }

    const diceElements = dice.map((die) => {
    	return <Die value={die.value} />;
    });

</code>

Corretto :white_check_mark:

Soluzione tutorial più sintetica:
<code>

    arr.push({
    value: Math.ceil(Math.random() \* 6),
    isHeld: false
    });

</code>

Ora risolviamo il problema con la key.
Questa viene richiesta da React.js per mantenere le varie istanze di un Component nel corretto ordine. Se ci trovassimo ad utilizzare i dati da un'API potremmo utilizzare gli id degli objects forniti da questa, ma nel nostro caso conviene invece invece aggiungere un pacchetto nanoid per generare un id univoco.
Importando il package dopo averlo installato avremo quindi la possibilità di creare un id univoco negli objects dell'Array e poi usare tale id come key nelle istanze del Component Die:

<code>
function allNewDice() {
		let arr = [];
		for (let i = 0; i < 10; i++) {
			arr.push({
				value: Math.ceil(Math.random() * 6),
				isHeld: false,
				id: nanoid()
			});
		}
		return arr;
	}

    function rollUnheldDice() {
    	setDice(allNewDice());
    }

    const diceElements = dice.map((die) => {
    	return <Die key={die.id} value={die.value} />;
    });

</code>

## 17. Build a Notes App and Tenzies Game | Tenzies: Styling Held Dice

Challange:
Aggiungere un Conditional Styling al Component Die in modo che quando isHeld é true il background color cambi in verde #59E391.
Occorre anche passare un modo al Component per sapere se isHeld é true o false.

<code>

In App.js

    const diceElements = dice.map((die) => {
    	return <Die key={die.id} value={die.value} isHeld={die.isHeld} />;
    });

In Die.js

    export default function Die(props) {
    const style = {
    backgroundColor: props.isHeld ? "#59E391" : "#FFFFFF"
    };

    	return (

    		<div className="die-face" style={style}>
    		<h2 className="die-num">{props.value}</h2>
    		</div>
    	);
    }

</code>

Corretto :white_check_mark:

## 18. Build a Notes App and Tenzies Game | Tenzies: Hold Dice Part 1

Nelle sezioni passate abbiamo trattato il Derived State e di come nella maggior parte dei casi non venga usato.

In questo progetto abbiamo un App Component che ospita un Array di Objects e avviene un map su tale Array per creare le istanze del nostro Die Component. Viene poi passata ad ogni Component la property isHeld così da variare il colore in verde al cambio della value o no.
Ogni Die Component ottiene il proprio State dalla prop isHeld e ha l'abilità di passare da true a false e viceversa.
Questo impedirebbe al parent Component App di conoscere la value corretta al cambio di State e qui abbiamo bisogno di osservare ogni singolo Die per sapere quando fermare il gioco.

Invece dovremmo mantenere lo State nel nostro App Component, per questo creeremo una funzione chiamata holdDice() e tale funzione sarà passata ad ogni Die Component.
Qui abbiamo bisogno di sapere quale Die clicka Hold così che la funzione di hold riceva un id come parametro, che é unico grazie ad package nanoid spiegato in precedenza.

Challange:
Creare la funzione holdDice che prenda come parametro "id". Per ora basta che la funzione logghi l'id.

<code>

In Die.js

    export default function Die(props) {
    	const styles = {
    		backgroundColor: props.isHeld ? "#59E391" : "#FFFFFF"
    	};
    	return (
    		<div
    			className="die-face"
    			style={styles}
    			onClick={() => props.holdDice(props.id)}
    		>
    			<h2 className="die-num">{props.value}</h2>
    		</div>
    	);
    }

In App.js

function holdDice(id) {
console.log(id);
}

    const diceElements = dice.map((die) => {
    	return (
    		<Die
    			key={die.id}
    			id={die.id}
    			value={die.value}
    			isHeld={die.isHeld}
    			holdDice={holdDice}
    		/>
    	);

</code>

Corretto :white_check_mark:

Nonostante la correttezza della soluzione viene illustrato un modo per saltare un passaggio:
Invece di passare l'id come prop ulteriore posso rendere la prop holdDice una funzione anonima già dall'istanza nel Component App.js.

<code>

In App.js

    const diceElements = dice.map((die) => {
    	return (
    		<Die
    		key={die.id}
    		value={die.value}
    		isHeld={die.isHeld}
    		holdDice={() => holdDice(die.id)}
    		/>
    	);
    });

In Die.js

    export default function Die(props) {
    	const styles = {
    		backgroundColor: props.isHeld ? "#59E391" : "#FFFFFF"
    	};

    	return (

    	<div className="die-face" style={styles} onClick={props.holdDice}>
    		<h2 className="die-num">{props.value}</h2>
    	</div>
    	);
    }

</code>

Nella parte successiva della Challange, una volta identificato l'id del Die che viene clickato, saremo in grado di aggiornate la value di isHeld nello State solo per il corretto Die.

## 19. Build a Notes App and Tenzies Game | Tenzies: Hold Dice Part 2

Challange:
Aggiornare la funzione holdDice in modo che scambi la value di isHeld nell'object dell'Array che viene clickato, in base alla prop id passata alla funzione.

<code>

    function holdDice(id) {
    		setDice((prevVal) => {
    			let arr = prevVal.map((elem) => {
    				if (elem.id === id) {
    					return (elem = { ...elem, isHeld: !elem.isHeld });
    				} else {
    					return elem;
    				}
    			});
    			// console.log(arr);
    			return [...arr];
    		});
    	}

</code>

Da tutorial alternativa leggermente più sintetica con Ternary Operator:

<code>
	die.id === id ? { ...die, isHeld: !die.isHeld } : die
</code>

Corretto :white_check_mark:

## 20. Build a Notes App and Tenzies Game | Tenzies: Hold Dice Part 3

Challange:
Modificare la funzione rollDice in modo che invece di creare sempre dei nuovi Dice si considerino i Dice con isHeld true e non vengano cambiati.

Soluzione 1:

<code>

    function rollUnheldDice() {
    		setDice((oldDice) => {
    			return oldDice.map((die) => {
    				return die.isHeld ? die : {
    				...die,
    				value: Math.ceil(Math.random() \* 6)
    			};
    		});
    	});
    }

</code>

Soluzione 2:

<code>

    function rollUnheldDice() {
    		setDice((oldDice) => {
    			return oldDice.map((die) => {
    				return die.isHeld
    					? die
    					: {
    							value: Math.ceil(Math.random() * 6),
    							isHeld: false,
    							id: nanoid()
    						};
    			});
    		});
    	}

</code>

Prima soluzione ottimale :white_check_mark:

Nel tutorial viene creata una nuova funzione per generare un nuovo die object, che va a sostituire l'argument del push in allNewDice. Tuttavia generare di continuo nuovi elements consuma risorse, quindi é poreferibile la Soluzione 1.

La prossima Sezione sarà incentrata su come finire il gioco quando tutti i Die sono bloccati con lo stesso valore.

## 21. Build a Notes App and Tenzies Game | Endgame Part 1

Challange:
Aggiungere un nuovo State chiamato "tenzies" con default false. Rappresenterà se il giocatore ha vinto al momento o no.
Create inoltre un Effect che si esegua ogni volta che lo State dice, l'Array, cambia. Per ora inserire solo un console.log nell'Effect.

<code>

    const [tenzies, setTenzies] = React.useState(false);

    React.useEffect(() => {
    console.log("Dice State changes");
    }, [...dice]);

o

    React.useEffect(() => {
    console.log("Dice State changes");
    }, [dice]);

</code>

Corretto :white_check_mark:

## 22. Build a Notes App and Tenzies Game | Endgame Part 2

Challange:
Dentro all'useEffect invece del console.log si controlli l'Array dice per delle condizioni di vittoria.
Le condizioni saranno:

    • Se tutte i Dice sono held e
    • Tutti i Dice hanno la stessa value.

Se tutte le condizioni sono true allora console.log('You Won!')

<code>

React.useEffect(() => {
const holds = dice.every((elem) => elem.isHeld);
let value;
dice.map((elem) => (value = elem.value));
const allSameValue = dice.every((die) => die.value === value);
if (holds && allSameValue) {
setTenzies(true);
console.log("You Won");
}
}, [dice]);
</code>

Funzionante :white_check_mark:

Molto simile a tutorial:

<code>
React.useEffect(() => {
		const allHelds = dice.every((elem) => elem.isHeld);
		const firstValue = dice[0].value;
		const allSameValue = dice.every((die) => die.value === firstValue);
		if (allHelds && allSameValue) {
			setTenzies(true);
			console.log("You Won");
		}
	}, [dice]);
</code>

## 23. Build a Notes App and Tenzies Game | Endgame Part 3

Challange:
Quando tenzies diviene true, cambiare il text nel Button da Roll a New Game.
Se tenzies diviene true nello State inoltre usare il packeage di React Confetti per renderizzare un Component Confetti.
Guardare la documentazione per il render del Confetti Component.

<code>
return (
		<main>
			{tenzies && <Confetti />}
			<h1 className="title">Tenzies</h1>
			<p className="instructions">
				Roll until all dice are the same. Click each die to freeze it at its
				current value between rolls.
			</p>
			<div className="die-container">{diceElements}</div>
			<button className="roll-dice" onClick={rollUnheldDice}>
				{tenzies ? "New Game" : "Roll"}
			</button>
		</main>
	);
</code>

Perfetto :white_check_mark:
Senza vedere indicazioni nel return

## 24. Build a Notes App and Tenzies Game | Tenzies: New Game

Challange:
Definisci i passaggi che permetteranno all'utente di giocare una nuova partita quando il Button verrà clickato e questo ha già vinto.

• Spostare value tenzies da true a false
• Usare holdDice su tutti i dice contemporaneamente
• Cambiare value del button da New game a Roll
• Rimescolare i dati con allnewDice in setDice

<code>

    function restartGame() {
    setTenzies(false);
    	for (let die of dice) {
    	holdDice(die.id);
    	}
    setDice(allNewDice());

}
return (

    <main>
    	{tenzies && <Confetti />}
    	<h1 className="title">Tenzies</h1>
    	<p className="instructions">
    		Roll until all dice are the same. Click each die to freeze it at its
    		current value between rolls.
    	</p>
    	<div className="die-container">{diceElements}</div>
    	<button
    	className="roll-dice"
    	onClick={tenzies ? restartGame : rollUnheldDice} >
    	{tenzies ? "New Game" : "Roll"}
    	</button>
    </main>
    );

</code>

Funzionante :white_check_mark:

Nel tutorial modifica a rollUnhandledDice o button con conditional su tenzies.

## 25. Build a Notes App and Tenzies Game | Tenzies: Extra Credit Ideas

• CSS: aggiungere dei veri puntini come nei dadi
• Tracciare il numero di rolls per vincere il gioco
• Tracciare il tempo messo per vincere
• Salvare il moglior tempo sul localStorage

## 26. Build a Notes App and Tenzies Game | Section 4 Solo Project

Creare una Trivia App chiamata Quizzical Trivia.
Da una schermata aperta con un button per cominciare, recupera le domande da un database, visualizzandone 5 come dei brevi quiz a risposte multiple, una volta selezionate le risposte clicka il Button Check Answers indicando le risposte errate in rosso, quelle corrette in verde e indica il punteggio ottenuto. Trasforma il button in "new game" resettando il gioco.
Vedi tre screen nel Figma file.

Requirements:

• Dividere in due sezioni dalla prima schermata (Start Quiz) alla seconda (Domande quiz) renderizzate con un Conditional Rendering.

• Ottenere 5 domande dalla OTDB API (Link su Scrimba)

• Evidenziare le risposte corrette dopo che il Button "Check Answers" viene clickato, mostrando in basso il numero delle risposte corrette

• Guardare documentazione Open Trivia DataBase

FARE PROGETTO

# Seconda parte - ADVANCED

## 1. Starter Overview

In questa parte della guida si parlerà di:

• useState
• useEffect
• Conditional Rendering
• Forms
• useRef
• useReducer
• Prop drilling
• Context API - useContext

## 2. useState - Simple Use Case

Per dimostrare l'utilità ed il funzionamento di useState partiremo dal Component ErrorExample:

<code>

    import React from "react";

    const ErrorExample = () => {
    	return <h2>useState error example</h2>;
    };

    export default ErrorExample;

</code>

Importiamo il Component in App.js con il nome di Setup (data struttura differente del tutorial).

Qui implementeremo la logica in modo che premendo un Button si cambierà un name.

Qui useremo un React.Fragment per creare il Component.

<code>
	<React.Fragment></React.Fragment>
</code>

NOTA: si apporteranno modifiche al codice per equiparare al precedente tutorial e al mio personale stile di Coding.
Per esempio | Function Expressions -> Function Declarations

<code>

import React from "react";

const ErrorExample = () => {
let title = "random title";

    function handleClick() {
    title = "Hello People"
    console.log(title);
    }

    	return (
    		<React.Fragment>
    				<h2>{title}</h2>
    			<button type="button" className="btn" onClick={handleClick}>
    					Change Title
    			</button>
    		</React.Fragment>
    	);

};

export default ErrorExample;

</code>

Question:
Clickando il button verrà cambiato il title?
Answer:
No, la variabile non viene riassegnata, occore che avvenga un nuovo render. Per farlo si usa lo State.

Perfetto :white_check_mark:

Utilizziamo quindi lo useState Hook.
Per importarlo ed usarlo un altro modo rispetto a React.useState é:
import React, { useState } from "react";

In questo modo basterà usare il metodo useState.

Come sappiamo useState() restituisce una value e una setter function in un Array : [value, function]

Ricordare convenzione:
const [text, setText] = useState()

<code>

import React, { useState } from "react";

const useStateExample = () => {

    const [text, setText] = useState("random title");

    return (
    	<React.Fragment>
    		<h1>{text}</h1>
    	</React.Fragment>
    );

};

export default useStateExample;

</code>

Ora qualunque cosa passeremo a setText, in questo caso "Hello World", sarà la nuova value di text. Per ottenere il nuovo render basterà clickare sul button, la funzione verrà chiamata, lo State cambierà e quindi React.js effettuerà un re-render.

<code>

import React, { useState } from "react";

const useStateExample = () => {

    const [text, setText] = useState("random title");

    function handleClick() {
    	setText("Hello World");
    }

    return (
    	<React.Fragment>
    		<h1>{text}</h1>
    		<button type="button" className="btn" onClick={handleClick}>
    			Change Title
    		</button>
    	</React.Fragment>
    );

};

export default useStateExample;

</code>

## 3. General Rules of Hooks

• Gli Hooks cominciano con use... (useEffect, useMemo, useCallback, useState...)

• I Components devono avere la lettera maiuscola, altrimenti si avrà un errore

• Gli Hooks devono trovarsi nel body di un Component, all'esterno non funzioneranno e si avrà un errore

• Gli Hooks non possono essere chiamati in modo Conditinal. Sì alla funzione set... ma non l'intero Hook "const hook = [value, setValue]" all'interno di un if per esempio.

## 4. useState - Array Example

Setup di base con import di dati da un file \*.js con Hook useState chiamato senza l'import da React:

<code>

import React from "react";
import {data} from "../assets/data";

    const useStateArray = () => {
    	const [people, setPeople] = React.useState([]);

    		return <>{

    		}</>;

    };

    export default useStateArray;

</code>

Come regola generale si usa...
const [people, setPeople] = React.useState([]);
...quando si usa un Hook una sola volta nel codice.

Nota: La parte di codice...

return <>{

}</>;

...si usa al posto di React.Fragment.

Usiamo ora i dati per mostrare i nomi dell'Array contenuto in data.js:

<code>
const useStateArray = () => {
	const [people, setPeople] = React.useState(data);

    return (
    	<>
    		{people.map((person) => {
    			const { id, name } = person;
    			return (
    				<div key={id} className="item">
    					<h4>{name}</h4>
    				</div>
    			);
    		})}
    	</>
    );

};

export default useStateArray;
</code>

Aggiungiamo ora un Button che cancelli tutti gli items, chiamando direttamente setPeople dall'onClick

<code>
<button type="button" className="btn" onClick={() => setPeople([])}>
Clear Items
</button>
</code>

Ora aggiungiamo un Button per rimuovere gli items singolarmente:

<code>
const useStateArray = () => {
	const [people, setPeople] = React.useState(data);

    function removeItem(id) {
    	setPeople((prevPeople) => {
    		return prevPeople.filter((person) => person.id !== id);
    	});
    }
    return (
    	<>
    		{people.map((person) => {
    			const { id, name } = person;
    			return (
    				<div key={id} className="item">
    					<h4>{name}</h4>
    					<button onClick={() => removeItem(id)}>Remove</button>
    				</div>
    			);
    		})}
    		<button type="button" className="btn" onClick={() => setPeople([])}>
    			Clear Items
    		</button>
    	</>
    );

};

export default useStateArray;
</code>

Ricordare che nell' onClick viene usata una Arrow function per poter passare gli arguments a tale funzione oltre che per fare in modo che la funzione venga chiamata solamente al click del Button.

Soluzione migliore, diversa da tutorial.

## 5. useState - Multiple State Values - Objects Example

Partiamo da una base similare al codice precedente.
Inseriamo però come value a person un objects tramire useState.

<code>

    const useStateObjects = () => {
    	const [person, setPerson] = useState({
    		name: "Peter",
    		age: 34,
    		message: "random message"
    		});
    	console.log(person);
    	return (
    	<>
    	<h3>{person.name}</h3>
    	<h3>{person.age}</h3>
    	<h3>{person.message}</h3>
    	</>
    		);
    };

    export default useStateObjects;

</code>

Inseriamo quindi un Button per cambiare il message:

<code>

const useStateObjects = () => {
const [person, setPerson] = useState({
name: "Peter",
age: 34,
message: "random message"
});

    	function changeMessage() {
    			setPerson((prevPerson) => {
    				return { ...prevPerson, message: "Hello World" };
    		});
    	}

    	return (
    			<>
    				<h3>{person.name}</h3>
    				<h3>{person.age}</h3>
    				<h3>{person.message}</h3>
    				<button className="btn" onClick={changeMessage}>
    					Change Message
    				</button>
    			</>
    		);

    };

export default useStateObjects;

</code>

Nota: nel tutorial nella funzione changeMessage all'interno del setPerson viene sfruttata la variabile person direttamente. Questa é da considerarsi una Bad Practice, meglio usare la previousValue qui chiamata prevPerson fornita da React.js.

Invece di un object viene mostrato la gestione di più State, uno per property, con setMessage per cambiare il message.

In caso di objects ricordarsi di preservare le vecchie values con ...person.

## 6. useState - Simple Counter Example

In questa parte si userà la funzione al posto di una value nella funzione setter di useState.

Partiamo dal codice:

<code>
const useStateCounter = () => {
	const [value, setValue] = React.useState(0);

    function reset() {
    	setValue(0);
    }
    return (
    	<>
    		<section style={{ margin: "4rem 0" }}>
    			<h2>Regular Counter</h2>
    			<h1>{value}</h1>
    			<button className="btn" onClick={() => setValue(value - 1)}>
    				Decrease
    			</button>
    			<button className="btn" onClick={reset}>
    				Reset
    			</button>
    			<button className="btn" onClick={() => setValue(value + 1)}>
    				Increase
    			</button>
    		</section>
    	</>
    );

};

export default useStateCounter;

</code>

## 7. Functional Update Form

Creiamo una section identica con dello spazio per distinguere le due forme. Qui si tratterà dell'utilizzo di una funzione all'interno della funzione setter dello State e delle Previous Value dello State.

Utilizzando come event handler function complexIncrease:

<code>
complexIncrease() {
		setTimeout(() => {
			setValue(value + 1);
		}, 2000);
	}
</code>

Otterremo che anche se clickiamo molte volte ripetutamente il Button, otterremo sempre la value 1.
Questo accade perché per aggiornare lo State usando la value precedente occorre la funzione, altrimenti in caso di funzioni asincrone si otterrà un problema. Occorre quindi usare la prevValue fornita di default.
Ciò che si restituirà nella funzione sarà la nuova value. Questa deve essere una value, non undefined.

Nota: In ogni caso in quest'esempio non viene rispettato il delay.

Questo metodo si può usare in tutti i metodi precedenti, e bisognerebbe visto che é considerata una Best Practice.

Questo metodo viene detto Functional Approach.

## 8. Matching Projects

Progetto consigliato.

## 9. useEffect - Basics

Il secondo Hook più usato é useEffect().

useEffect come sappiamo permette di eseguire un Side Effect (detto anche Effect). Questo può essere una chiamata ad un'API, un salvataggio su localStorage o altro. In sintesi ogni funzionalità esterna al Component e quindi a React.js. L'Effect é la funzione all'interno di useEffect.

Gli Effect si eseguono ad ogni render compreso il primo.

Con l'esempio possiamo notare il funzionamento della chiamata a useEffect e il render del Component:

<code>

    import React, { useState, useEffect } from "react";

    const useEffectBasics = () => {
    	useEffect(() => {
    		console.log("call useEffect");
    	});
    	console.log("render Component");

    	return (
    	<>
    		<h2>useEffect Example</h2>
    	</>
    	);
    };

    export default useEffectBasics;

</code>

NOTA: Il motivo della doppia chiamata ad entrambi i console.log é che viene usato in index.js il React.StrictMode

Possiamo usare useEffect per accedere alla DOM API, per esempio:

<code>

import React, { useState, useEffect } from "react";

const useEffectBasics = () => {
const [value, setValue] = useState(0);

    		useEffect(() => {
    			console.log("call useEffect");
    		});

    		console.log("render Component");

    		return (
    			<>
    				<h1>{value}</h1>
    				<button className="btn" onClick={() => setValue(value + 1)}>
    					click me
    				</button>
    			</>
    		);

    };

export default useEffectBasics;

</code>

Con questo codice si ottengono molti re-render, visto che ad ogni aggiornamento dello State ne avviene uno, e qui lo State viene aggiornato con la funzione setter ad ogni click del Button.
Inoltre si ottiene per ogni render l'esecuzione dell'Effect, visto che non viene impostato nessun secondo parametro Dependency (Array).

## 10. useEffect - Conditional

Non si può usare useEffect all'interno di un if(){useEffect()}.
Questo causerà un errore, vedi regole generali degli Hooks.

Si può però inserire una struttura if...else all'interno dell'Effect.

<code>
import React, { useState, useEffect } from "react";

const useEffectBasics = () => {
const [value, setValue] = useState(0);

    useEffect(() => {
    	console.log("call useEffect");
    	if (value > 1) {
    		document.body.append(
    			(document.createElement("p").textContent = `New Messages(${value})`)
    		);
    	}
    });
    console.log("render Component");
    return (
    	<>
    		<h1>{value}</h1>
    		<button className="btn" onClick={() => setValue(value + 1)}>
    			click me
    		</button>
    	</>
    );

};

export default useEffectBasics;
</code>

Usando questo metodo l'Effect viene eseguito ma non la chiamata alla DOM API.

## 11. useEffect - Dependency List

Il secondo parametro di useEffect é il Dependency Array.
Questo osserva i cambi di value di ogni element al suo interno e se vi é un cambiamento l'Effect viene rieseguito.
Come già visto lasciando un Array vuoto indichiamo che l'Effect dev'essere eseguito solo nel render iniziale.
Nell'esempio sopra riportato, con il secondo parametro lasciato vuoto, non viene rieseguito l'Effect o aggiornato il DOM nemmeno se avviene il click sul Button.

Così facendo, inserendo la variabile State all'interno del Dependency Array, l'Effect verrà rieseguito ad ogni cambio della value, perciò ad ogni click:

<code>
const useEffectBasics = () => {
	const [value, setValue] = useState(0);

    useEffect(() => {
    	console.log("call useEffect");
    	if (value > 1) {
    		document.body.append(
    			(document.createElement("p").textContent = `New Messages(${value})`)
    		);
    	}
    }, [value]);
    console.log("render Component");
    return (
    	<>
    		<h1>{value}</h1>
    		<button className="btn" onClick={() => setValue(value + 1)}>
    			click me
    		</button>
    	</>
    );

};

export default useEffectBasics;
</code>

Nota: Si possono avere quanti useEffect vogliamo.

## 12. useEffect - Cleanup Function

In quest'esempio utilizzeremo le misure della pagina.

<code>
const useEffectCleanUp = () => {
	const [size, setSize] = useState(window.innerWidth);
	
	function changeSize() {
		setSize(window.innerWidth);
	}
	useEffect(() => {
		window.addEventListener("resize", changeSize);
	});
	return (
		<>
			<h2>window</h2>
			<h1>{size} px</h1>
		</>
	);
};

export default useEffectCleanUp;

</code>

In questo modo abbiamo ottenuto il risultato, ma non essendoci una Cleanup Function si va incontro ad un memory leak, in quando vi é un continuo rerender dovuto al continuo aggiornamento di size ad ogni render.

La Cleanup function diviene ancora più essenziale quando si parla di Conditional Rendering.

## 13. useEffect - Fetch Data

Regole da ricordare usando il fetch in useEffect:

• non si può tramutare una funzione Effect in async / await perché restituiscono una promise, si può però dichiarare all'interno di un Effect una funzione asincrona e chiamare tale funzione.

Esempio funzionante solo con console.log:
<code>
const url = "https://api.github.com/users";

const useEffectFetch = () => {
const [users, setUsers] = useState([]);

    async function getUsers() {
    	const response = await fetch(url);
    	const users = await response.json();
    	console.log(users);
    }

    useEffect(() => {
    	getUsers();
    });
    return (
    	<>
    		<h2>github users</h2>
    	</>
    );

};

export default useEffectFetch;
</code>

Problema dell'infinite loop / memory leak.
Si può risolvere aggiungendo il Dependency Array vuoto.

Corretto e completo:
<code>
const url = "https://api.github.com/users";

const useEffectFetch = () => {
const [users, setUsers] = useState([]);

    async function getUsers() {
    	const response = await fetch(url);
    	const json = await response.json();
    	// console.log(users);
    	setUsers(json);
    }

    useEffect(() => {
    	getUsers();
    }, []);
    return (
    	<>
    		<h2>github users</h2>
    		<ul className="users">
    			{users.map((user) => {
    				const { id, login, avatar_url, html_url } = user;
    				return (
    					<li key={id}>
    						<img src={avatar_url} alt={login} />
    						<div>
    							<h4>{login}</h4>
    							<a href={html_url}>profile</a>
    						</div>
    					</li>
    				);
    			})}
    		</ul>
    	</>
    );

};

export default useEffectFetch;
</code>

• Se si vuole utilizzare più volte un Side Effect assicurarsi sempre di avere un Dependency Array, altrimenti sorgeranno sicuramente problemi di memoria.

## 14. Multiple Returns - Conditional Rendering

In una funzione / Component possiamo avere nessun return, uno o più returns basati su qualche tipo di Condition:

<code>
import React, { useState, useEffect } from "react";

const MultipleReturns = () => {
const [loading, setLoading] = useState(true);

    if (loading) {
    	return <h2>Loading...</h2>;
    }
    return <h2>Multiple Returns</h2>;

};

export default MultipleReturns;

</code>

## 15. Multiple Returns - Fetching Data

Un esempio avanzato ma basilare con fetch per mostrare le possibilità del Multiple Returns:

<code>
const MultipleReturns = () => {
	const [isLoading, setIsLoading] = useState(false);
	const [isError, setIsError] = useState(false);
	const [user, setUser] = useState("default user");

    useEffect(() => {
    	setIsLoading(true);
    	fetch(url)
    		.then((res) => {
    			if (res.status >= 200 && res.status <= 299) {
    				return res.json();
    			} else {
    				setIsLoading(false);
    				setIsError(true);
    				throw new Error(res.statusText);
    			}
    		})
    		.then((user) => {
    			const { login } = user;
    			setUser(login);
    			setIsLoading(false);
    		})
    		.catch((err) => console.log(err));
    }, []);

    if (isLoading) {
    	return (
    		<div>
    			<h2>Loading...</h2>
    		</div>
    	);
    }
    if (isError) {
    	<div>
    		<h2>Error...</h2>
    	</div>;
    }
    return (
    	<div>
    		<h2>{user}</h2>
    	</div>
    );

};

export default MultipleReturns;

</code>

## 16. Short Circuit Evaluation

Non potendo far restituire una value da un if vi sono dei metodi alternativi per renderizzare qualcosa in modo condizionale.
Esempi && e ||:

<code>

import React, { useState, useEffect } from "react";

    const url = "https://api.github.com/users/QuincyLarson";

    const ShortCircuit = () => {
    		const [text, setText] = useState("X");
    		const firstValue = text || "Hello World";
    		const secondValue = text && "hello World";

    		return (
    			<>
    				{/* <h2>{firstValue}</h2>
    				<h2>value: {secondValue}</h2> */}
    				<h1>{text || "John Doe"}</h1>
    				{text && <h1>Hello All the World</h1>}
    				{!text && <h1>Hello World</h1>}
    			</>
    		);
    };

export default ShortCircuit;

</code>

Notare la differenza: con || valuto una value e la cambio, con && valuto il rendering di un Component.

## 17. Ternary Operator

Esempio che continua dal precedente aggiungendo il Ternary Operator:

<code>
const ShortCircuit = () => {
	const [text, setText] = useState("X");
	const [isError, setIsError] = useState(false);

    const firstValue = text || "Hello World";
    const secondValue = text && "hello World";

    return (
    	<>
    		{/* <h2>{firstValue}</h2>
    		<h2>value: {secondValue}</h2> */}
    		<h1>{text || "John Doe"}</h1>
    		<br />
    		{text && <h1>Hello All the World</h1>}
    		{!text && <h1>Hello World</h1>}
    		<br />
    		<button className="btn" onClick={() => setIsError(!isError)}>
    			toggle error
    		</button>
    		<br />
    		{/* {isError && <h1>Error...</h1>} */}
    		{isError ? <h2>Error...</h2> : <h2>There is no Error</h2>}
    	</>
    );

};
</code>

Non vi é limite a quello che possono essere le due possibilità del Ternary, possono essere anche Components molto complessi, basta che siano racchiusi in un singolo div o altro.

## 18. Show/Hide Component

In quest'esempio si mostrerà come far apparire e scomparire un Component React.js, con anche un esempio pratico della Cleanup Function:

<code>

const ShowHide = () => {
const [show, setShow] = useState(false);
return (
<>
<button className="btn" onClick={() => setShow(!show)}>
show/hide
</button>
{show && <Item />}
</>
);
};

const Item = () => {
const [size, setSize] = useState(window.innerWidth);

    	function checkSize() {
    		setSize(window.innerWidth);
    	}

    	useEffect(() => {
    		window.addEventListener("resize", checkSize);
    		return () => {
    		window.removeEventListener("resize", checkSize);
    		};
    	}, []);

    return (
    	<div style={{ marginTop: "2rem" }}>
    		<h1>window</h1>
    		<h2>size: {size} px</h2>
    	</div>
    );

};

export default ShowHide;

</code>

Qui senza la Cleanup Function si avrebbe un memory leak.

## 19. Form Basics

Partiamo dal codice con un problema:

<code>

const ControlledInputs = () => {

    function handleSubmit() {
    	console.log("Submit");
    }

    return (
    	<>
    		<article>
    			<form className="form" onSubmit={handleSubmit}>
    				<div className="form-control">
    					<label htmlFor="firstName">Name : </label>
    					<input type="text" id="firstName" name="firstName" />
    				</div>
    				<div className="form-control">
    					<label htmlFor="email">Email : </label>
    					<input type="text" id="email" name="email" />
    				</div>
    				<button type="submit">add person</button>
    			</form>
    		</article>
    	</>
    );

};

export default ControlledInputs;

</code>

Qui per prima cosa non serve il type del Button, ma più importante é che occorre prevenire il comportamento di default del form, cioè che quando viene premuto il button i campi degli input vengono azzerati, non venendo salvati, perché avviene un nuovo render.
Occorre quindi usare event.preventDefault nella funzione Event Handler:

<code>
function handleSubmit(event) {
		event.preventDefault();
		console.log("Submit");
	}
</code>

Questo comportamento sarebbe uguale anche se, invece di un event submit nel form, usassimo un event click nel button.

## 20. Controlled Inputs

Qui vedremo come connettere i vari input allo State (già visto, Object), creando quindi del Controlled Inputs.

Qui aggiungeremo quindi agli input una property value che si riferisce al relativo State.

<code>
const ControlledInputs = () => {
	const [firstName, setFirstName] = useState("");
	const [email, setEmail] = useState("");

    function handleSubmit(event) {
    	event.preventDefault();
    	console.log("Submit");
    }

    return (
    	<>
    		<article>
    			<form className="form" onSubmit={handleSubmit}>
    				<div className="form-control">
    					<label htmlFor="firstName">Name : </label>
    					<input
    						type="text"
    						id="firstName"
    						name="firstName"
    						value={firstName}
    					/>
    				</div>
    				<div className="form-control">
    					<label htmlFor="email">Email : </label>
    					<input type="text" id="email" name="email" value={email} />
    				</div>
    				<button type="submit">add person</button>
    			</form>
    		</article>
    	</>
    );

};

export default ControlledInputs;

</code>

Così facendo chiaramente gli input rimarranno vuoti e non si potranno cambiare fino al momento dell'aggiunta di un onChange Event, in quanto controllati dal relativo State:

<code>

const ControlledInputs = () => {
const [firstName, setFirstName] = useState("");
const [email, setEmail] = useState("");

    function handleSubmit(event) {
    	event.preventDefault();
    	console.log("Submit");
    	console.log(firstName);
    	console.log(email);
    }

    return (
    	<>
    		<article>
    			<form className="form" onSubmit={handleSubmit}>
    				<div className="form-control">
    					<label htmlFor="firstName">Name : </label>
    					<input
    						type="text"
    						id="firstName"
    						name="firstName"
    						value={firstName}
    						onChange={(event) => setFirstName(event.target.value)}
    					/>
    				</div>
    				<div className="form-control">
    					<label htmlFor="email">Email : </label>
    					<input
    						type="text"
    						id="email"
    						name="email"
    						value={email}
    						onChange={(event) => setEmail(event.target.value)}
    					/>
    				</div>
    				<button type="submit">add person</button>
    			</form>
    		</article>
    	</>
    );

};
</code>

Ora ad ogni cambio di value negli input, grazie all'event onChange e alla reference tramite la property value con lo State, la value inserita verrà salvata nel relativo State.

## 21. Add Item To The List

Partendo dall'esempio precedente capiamo come aggiungere degli Items ad una lista.

Creiamo un nuovo State "people", in modo da usarlo come Array contenitore dei dati che prenderemo da "firstName" ed "email".

Agiamo sulla funzione handleSubmit, per salvare i dati ottenuti e poi aggiungerli ad un Array:

<code>
const ControlledInputs = () => {
	const [firstName, setFirstName] = useState("");
	const [email, setEmail] = useState("");
	const [people, setPeople] = useState([]);

    console.log(people);

    function handleSubmit(event) {
    	event.preventDefault();

    	if (firstName && email) {
    		const person = {
    			firstName: firstName,
    			email: email
    		};
    		setPeople((oldPeople) => {
    			return [...oldPeople, person];
    		});
    		setFirstName("");
    		setEmail("");
    	} else {
    		console.log("empty values");
    	}
    }
    return (
    	<>
    		<article>
    			<form className="form" onSubmit={handleSubmit}>
    				<div className="form-control">
    					<label htmlFor="firstName">Name : </label>
    					<input
    						type="text"
    						id="firstName"
    						name="firstName"
    						value={firstName}
    						onChange={(event) => setFirstName(event.target.value)}
    					/>
    				</div>
    				<div className="form-control">
    					<label htmlFor="email">Email : </label>
    					<input
    						type="text"
    						id="email"
    						name="email"
    						value={email}
    						onChange={(event) => setEmail(event.target.value)}
    					/>
    				</div>
    				<button type="submit">add person</button>
    			</form>
    			{people.map((person) => {
    				const { id, firstName, email } = person;
    				return (
    					<div key={id} className="item">
    						<h4>{firstName}</h4>
    						<p>{email}</p>
    					</div>
    				);
    			})}
    		</article>
    	</>
    );

};
</code>

## 22. Multiple Inputs

Vediamo ora uno use case con molti input, senza avere il corrispettivo numero di State.
Partendo dall'esempio precedente rifattorizzeremo il codice.

<code>
const MultipleInputs = () => {
	const [person, setPerson] = useState({
		firstName: "",
		email: "",
		age: ""
	});
	const [people, setPeople] = useState([]);

    console.log(people);

    function handleChange(event) {
    	const name = event.target.name;
    	const value = event.target.value;
    	setPerson((prevPerson) => {
    		return { ...prevPerson, [name]: value };
    	});
    }

    function handleSubmit(event) {
    	event.preventDefault();
    	if (person.firstName && person.email && person.age) {
    		const newPerson = { ...person, id: new Date().getTime().toString() };
    		setPeople((prevPeople) => {
    			return [...prevPeople, newPerson];
    		});
    		setPerson({ firstName: "", email: "", age: "" });
    	}
    }

    return (
    	<>
    		<article>
    			<form className="form">
    				<div className="form-control">
    					<label htmlFor="firstName">Name : </label>
    					<input
    						type="text"
    						id="firstName"
    						name="firstName"
    						value={person.firstName}
    						onChange={handleChange}
    					/>
    				</div>
    				<div className="form-control">
    					<label htmlFor="age">Age : </label>
    					<input
    						type="text"
    						id="age"
    						name="age"
    						value={person.age}
    						onChange={handleChange}
    					/>
    				</div>
    				<div className="form-control">
    					<label htmlFor="email">Email : </label>
    					<input
    						type="text"
    						id="email"
    						name="email"
    						value={person.email}
    						onChange={handleChange}
    					/>
    				</div>

    				<button type="submit" onClick={handleSubmit}>
    					add person
    				</button>
    			</form>
    			{people.map((person) => {
    				const { id, firstName, email } = person;
    				return (
    					<div key={id} className="item">
    						<h4>{firstName}</h4>
    						<p>{email}</p>
    					</div>
    				);
    			})}
    		</article>
    	</>
    );

};
</code>

## 23. useRef

Vi sono molteplici cose che possiamo fare con useRef, la più comune é localizzare (targeting) i DOM elements.
useRef funziona in modo molto similare a useState ma con alcune differenze:

• preserva le value
• NON avvia il re-render
• localizza i DOM elements

<code>
import React, { useState, useEffect, useRef } from "react";

const url = "https://api.github.com/users/QuincyLarson";

const userRefBasics = () => {
const refContainer = useRef(null);

    function handleSubmit(event) {
    	event.preventDefault();
    }

    console.log(refContainer);

    return (
    	<>
    		<form className="form" onSubmit={handleSubmit}>
    			<div>
    				<input type="text" ref={refContainer} />
    				<button>Submit</button>
    			</div>
    		</form>
    	</>
    );

};

export default userRefBasics;
</code>

Come si può notare per usare useRef si usa:
const refContainer = useRef(null);

La variabile viene inizializzata a null e, per darle un valore, si usa la property ref nell'element desiderato:

<input type="text" ref={refContainer} />

Si otterrà un object con key "current" e value "null".
Inserendo il console.log all'interno della funzione handleSubmit si otterrà un object con key "current" e value "input" (l'elements al quale é associta la property ref) che sarà a sua volta un object e del quale potremo analizzare la value.

Nota: la property type del button o viene lasciata vuota e allora diviene automaticamente submit se é all'interno di un form oppure specificare type="submit".

<code>
const url = "https://api.github.com/users/QuincyLarson";

const UseRefBasics = () => {
const refContainer = useRef(null);

    function handleSubmit(event) {
    	event.preventDefault();
    	console.log(refContainer.current.value);
    }

    return (
    	<>
    		<form className="form" onSubmit={handleSubmit}>
    			<div>
    				<input type="text" ref={refContainer} />
    				<button type="submit">Submit</button>
    			</div>
    		</form>
    	</>
    );

};

export default UseRefBasics;
</code>

l'Hook useRef si può utilizzare in qualunque element, non solo negli input.

Quindi se si vuole fare qualcosa di specifico con un DOM node, invece di usare la DOM API con useEffect possiamo usare useRef per semplificare l'azione di targeting.

Possiamo anche usare useEffect con all'interno una chiamata od un metodo collegato al refContainer del useRef. Questo non attiva il re-rendering quindi possiamo usare useEffect anche senza Dependency Array.

Qui per esempio, al primo render, o al ricaricamento, puntiamo il focus sull'input:

<code>

    useEffect(() => {
    refContainer.current.focus();
    });

</code>

## 24. useReducer - useState Setup

L'Hook useReducer viene usato quando vi sono dei setup complicati.
Essenzialmente useReducer aggiunge più struttura allo useState.

In questa parte interagiremo anche con il file come fosse un index.js.

Partiamo dal codice:

<code>

    const UseReducer = () => {
    	const [name, setName] = useState("");
    	const [people, setPeople] = useState(data);
    	const [showModal, setShowModal] = useState(false);

    		function handleSubmit(event) {
    			event.preventDefault();
    			if (name) {
    				console.log("Here");
    				setShowModal(true);
    				setPeople([...people, { id: new Date().getTime().toString(), name }]);
    				setName("");
    			} else {
    				setShowModal(true);
    			}
    		}

    		return (
    			<>
    				{showModal && <Modal />}
    				<form onSubmit={handleSubmit} className="form">
    					<div>
    						<input
    							type="text"
    							value={name}
    							onChange={(event) => {
    								return setName(event.target.value);
    							}}
    						/>
    					</div>
    					<button type="submit">Add</button>
    				</form>
    				{people.map((person) => {
    					return (
    						<div key={person.id}>
    							<h4>{person.name}</h4>
    						</div>
    					);
    				})}
    			</>
    		);

    };

    export default UseReducer;

</code>

Questo utilizza più State, e per piccole app può andar bene.
Ma mano a mano che l'app cresce, si avrà bisogno di una maggior struttura. Si desidererà quindi avere dei limiti, per aggiornare lo State solo in determinati modi.

## 25. useReducer - Refactor

Ora passeremo al refactor del codice precedente sostuendo con l'uso di useReducer due State.

Andremo quindi a creare:
const [state, dispatch] = useReducer();

Come per useState, la prima restituita (state) sarà la value e la seconda la funzione.
A differenza di useState però andremo ad inserire come parametro non la value di partenza per inizializzare la value ma la funzione reducer.
const [state, dispatch] = useReducer(reducer);

Se si vuole fare qualcosa con la variabile "state" occorre sempre usare la funzione "dispatch" e passerà attraverso "reducer".
"reducer" lo si può pensare come qualcosa che prende la vecchia funzione e accoglie qualcosa chiamato "action", che rimanda indietro il nuovo valore di "state".

La funzione reducer prende due parametri, state ed action:

function reducer(state, action){
}

• state - lo state appena prima dell'aggiornamento
• action - quello che stiamo cercando di fare

La funzione "reducer" verrà eseguita quando chiameremo dispatch nel nostro useReducer:

const [state, dispatch] = useReducer(reducer);

Il secondo paramentro del motodo useReducer sarà lo state iniziale. Questo può essere una variabile separata oppure impostato direttamente nel metodo.

<code>

    const defaultState = {
    	people: [],
    	isModalOpen: false,
    	modalContent: "hello world"
    };

    const [state, dispatch] = useReducer(reducer, defaultState);

</code>

Ora effettuiamo il refactor dell'esempio precedente senza le modifiche dinamiche, che vedremo in seguito:

<code>

    function reducer(state, action) {

    	const defaultState = {
    	people: data,
    	isModalOpen: false,
    	modalContent: "hello world"
    	};

    		const UseReducer = () => {
    		const [name, setName] = useState("");
    		const [state, dispatch] = useReducer(reducer, defaultState);

    	function handleSubmit(event) {
    			event.preventDefault();

    			if (name) {

    				} else {

    				}
    	}

    		return (
    			<>
    				{state.isModalOpen && <Modal modalContent={state.modalContent} />}
    				<form onSubmit={handleSubmit} className="form">
    					<div>
    						<input
    							type="text"
    							value={name}
    							onChange={(event) => {
    								return setName(event.target.value);
    							}}
    						/>
    					</div>
    					<button type="submit">Add</button>
    				</form>
    				{state.people.map((person) => {
    					return (
    						<div key={person.id}>
    							<h4>{person.name}</h4>
    						</div>
    					);
    				})}
    			</>
    		);
    	};
    };

</code>

Grazie a useReducer, usando la funzione dispatch, potrò modificare tutte le properties in un solo posto senza dover ricorrerre a molteplici State con relative funzioni setter da chiamare per modificare ognuno.

## 26. useReducer - Add Item

Per modificare qualsiasi cosa nel nostro state ora, avremo bisogno di "dispatch".
Lo useremo quindi all'interno dell'if nella funzione handleSubmit, per chiamare dispatch ad ogni qualvolta vi sia una modifica nell'input.

A dispatch occorrerà sempre passare un object con la property chiamata "type":

<code>

    function handleSubmit(event) {
    	event.preventDefault();
    	if (name) {
    		dispatch({type: 'TESTING'})
    	} else {

    	}
    }

</code>

L'argument di dispatch sarà la nostra action.

La funzione reducer quindi accoglierà la nostra action e dovrà sempre restituire (return) lo state, o vi sarà un errore. Questo convolgerà ogni property dello State usata, in quanto undefiend.

<code>

    function reducer(state, action) {
    	console.log(state, action);
    	return state;
    }

</code>

Aggiungengo al campo input un name e clickando add, otteniamo nella console due objects:

{
people: Array(0), isModalOpen: false, modalContent: ""
}

{
type: "TESTING"
}

Il primo é lo state appena prima dell'aggiornamento, l'altro é l'action.

Ora modifichiamo reducer con un if:

<code>

    function reducer(state, action) {
    	if (action.type === "TESTING") {

    	}
    	return state;
    }

</code>

Dato questo possiamo capire che impostiamo la nostra action con un type e poi nella funzione reducer andiamo a rilevare proprio questa property "type" con la sua value.
Si può notare che non andiamo ad intaccare il nostro state in più parti ma solamente nella funzione reducer rilavando il type della action.

Questa struttura é meno soggetta ad errori o bug nascosti rispetto alla precedente, soprattutto quando si parla di architetture dell'app più complesse.

Modifichiamo ora la funzione reducer nell'if:

<code>

    function reducer(state, action) {
    	if (action.type === "TESTING") {
    	return {
    		...state,
    		people: data,
    		isModalOpen: true,
    		modalContent: "item added"
    	};
    }
    	return state;
    }

</code>

Così facendo restituirò un nuovo state.

E' importante restituire un error in caso di type non trovato, in modo da non creare parti non rilavate restituendo uno state senza fine.

Modificheremo ora l'if in handleSubmit per adattarlo all'aggiunta di un object.

Nota: utilizzare il nome maiuscolo con degli underscore per gli spazi nella property type nell'object di dispatch, questa é una convenzione largamente usata. Per passare i dati si fornisce in genere la property payload.

Ora per passare i dati che vanno a modificare lo state aggiungeremo altre proprietà all'object argument di dispatch. Per facilitarci creiamo delle variabili all'interno del conditional, subito prima della chiamata a dispatch:

<code>
function handleSubmit(event) {
		event.preventDefault();
		if (name) {
			const newItem = {
				id: new Date.getTime().toString(),
				name
			};
			dispatch({ type: "ADD_ITEM", payload: newItem });
		} else {
			dispatch({ type: "RANDOM" });
		}
	}
</code>

Ora é necessario cogliere i dati da payload nella funzione reducer:

<code>

    function reducer(state, action) {
    	const newPeople = [...state.people, action.payload];
    	if (action.type === "ADD_ITEM") {
    		return {
    			...state,
    			people: newPeople,
    			isModalOpen: true,
    			modalContent: "item added"
    		};
    	}
    	throw new Error("no matching type");
    }

</code>

Creaiamo una variabile newItems, un Array, che sommi gli elements precedenti provenienti dallo state, perciò state.people, assieme alla property payload della action, il contenuto della chiamata a dispatch. Passiamo quindi la variabile creata come value alla property people del return della funzione reducer.

Ora puliamo l'input di testo dopo l'aggiunta, usando un semplice setName('') dopo la chiamata a dispatch.

Modifichiamo ora l'else del conditional per gestire il tentativo di inserimento di un campo vuoto, invece dell'opzione type: RANDOM.
Cambiamo quindi il type in NO_VALUE. Qui restituiremo semplicemente un modal leggermente diverso, ma non dobbiamo dimenticare anche di conservare l'array people nello state.

<code>
function reducer(state, action) {
	const newPeople = [...state.people, action.payload];
	if (action.type === "ADD_ITEM") {
		return {
			...state,
			people: newPeople,
			isModalOpen: true,
			modalContent: "item added"
		};
	}
	if (action.type === "NO_VALUE") {
		return { ...state, isModalOpen: true, modalContent: "please enter value" };
	}
	throw new Error("no matching type");
}
</code>

Occorre sempre tenere a mente che se si vuole usare dispatch con una nuova action, occorre sempre tener presente il fatto di conservare le values precedenti che non si modificano con questa. In questo caso si utilizza ...state per la conservazione delle values precedenti.

## 27. useReducer - Remove Item

Sempre usando l'esempio precedente, creiamo una funzione che sarà responsabile della chiusura del modal. Qui non avremo bisogno di alcun argument, useremo solo il dispatch con una nuova action.

<code>
function closeModal() {
		dispatch({ type: "CLOSE_MODAL" });
	}
</code>

Ciò che dovrà fare questa funzionalità non sarà altro che conservare le values precedenti dello state e cambiare isModalOpen su false.
Aggiungiamo quindi un nuovo if conditional alla funzione reducer:

<code>

    function reducer(state, action) {
    	const newPeople = [...state.people, action.payload];
    	if (action.type === "ADD_ITEM") {
    		return {
    			...state,
    			people: newPeople,
    			isModalOpen: true,
    			modalContent: "item added"
    		};
    	}
    	if (action.type === "NO_VALUE") {
    		return { ...state, isModalOpen: true, modalContent: "please enter value" };
    	}
    	if (action.type === "CLOSE_MODAL") {
    		return { ...state, isModalOpen: false };
    	}
    	throw new Error("no matching type");
    }

</code>

Eseguiremo quindi la funzione closeModal dopo 3 secondi. Per farlo passiamo una nuova prop al Component Modal:

<code>

    {state.isModalOpen && (
    <Modal closeModal={closeModal} modalContent={state.modalContent} />
    )}

</code>

Nel Component Modal andrò poi ad accedere a questa prop, usando un Hook useEffect per usare un setTimeout al suo interno:

<code>
const Modal = ({ modalContent, closeModal }) => {
	useEffect(() => {
		setTimeout(() => {
			closeModal();
		}, 3000);
	});
	return (
		<div className="modal">
			<p>{modalContent}</p>
		</div>
	);
};
</code>

Ora creiamo un button per rimuovere gli items dalla lista sottostante. Per far questo avremo chiaramente bisogno di usare dispatch con una nuova action.
Nel map che restituisce gli items userò quindi:
<code>

    {state.people.map((person) => {
    	return (
    	<div key={person.id} className="item">
    		<h4>{person.name}</h4>
    		<button
    		onClick={() =>
    		dispatch({ type: "REMOVE_ITEM", payload: person.id })
    		} >
    			remove
    		</button>
    	</div>
    	);
    })}

</code>

Useremo person.id per passare al reducer l'id corretto dell'item da rimuovere.
Modifichiamo quindi reducer:

<code>

    function reducer(state, action) {
    	const newPeople = [...state.people, action.payload];
    	if (action.type === "ADD_ITEM") {
    		return {
    			...state,
    			people: newPeople,
    			isModalOpen: true,
    			modalContent: "item added"
    		};
    	}
    	if (action.type === "NO_VALUE") {
    		return { ...state, isModalOpen: true, modalContent: "please enter value" };
    	}
    	if (action.type === "CLOSE_MODAL") {
    		return { ...state, isModalOpen: false };
    	}
    	if (action.type === "REMOVE_ITEM") {
    		const newPeople = state.people.filter((person) => {
    		return person.id !== action.payload;
    	});

    	return { ...state, people: newPeople };
    	}

    	throw new Error("no matching type");
    }

</code>

In questo particolare if...

if (action.type === "REMOVE_ITEM") {
const newPeople = state.people.filter((person) => {
return person.id !== action.payload;
});
return { ...state, people: newPeople };

...creiamo una nuova variabile per filtrare l'array state.people sfruttando l'id, restituiamo lo state con la property people sostituita con value filtrata.

Nota: Solitamente quando creaiamo dei reducer, questi hanno molte funzionalità. E' quindi saggio spostare tale reducer in un file separato con:

export function reducer(state, action) {...}

import { reducer } from "./reducer";

La nostra applicazione ora é molto più pulita e strutturata.

## 27. Prop Drilling

Cominciamo col dire che Prop Drilling (perforare le prop) non é un termine ufficiale.
Questo é un effetto collaterale quando si hanno molteplici Components, e occorre passare lo State dai Component più in alto nel Tree a quelli più in basso, cioé dai parents ai vari children.

Per gestire meglio questa situazione utilizzeremo nel prossimo capitolo l'Hook useContext e capiremo come usarlo e come questo risolve varie problematiche compreso il Prop Drilling.

Prima però capiamo il problema. Partiamo dal codice:

<code>
import { data } from "../assets/data";

const PropDrilling = () => {
const [people, setPeople] = useState(data);

    return (
    	<>
    		<section>
    			<h3>prop drilling</h3>
    			<List people={people} />
    		</section>
    	</>
    );

};

const List = ({ people }) => {
return (
<>
{people.map((person) => {
return <SinglePerson key={person.id} />;
})}
</>
);
};

const SinglePerson = ({ id, name }) => {
return (

<div className="item">
<h4>single item</h4>
</div>
);
};
</code>

Qui ogni Component é connesso con l'altro e alla fine renderizzato nel Component principale, che viene poi renderizzato in App.js. Vengono utilizzati i dati di data.js e passati fino al Component SinglePerson che farà parte poi del Component List.

Ora vogliamo creare una funzione che cancelli un singolo item dal Component List, useremo la stessa metodologia di prima:

<code>
function removePerson(id) {
		setPeople((people) => {
			return people.filter((person) => person.id !== id);
		});
	}
</code>

Ora dobbiamo usare questa funzione nel Component SinglePerson.
Ipoteticamente per farlo dovremmo prima passarlo nell'istanza di List nel return principale, poi passarla al Component SinglePerson dalla sua istanza in List e poi poter chiamare la funzione nella dichiarazione di SinglePerson.

Per Prop Drilling si intende proprio tutto questo passaggio tra i vari Components che non necessitano di una funzione giù tra i vari child e subchild fino a quello che la utilizzerà.

Qui lo faremo partendo dalla property removePerson nell'istanza di List:

<code>

const PropDrilling = () => {
const [people, setPeople] = useState(data);

    function removePerson(id) {
    	setPeople((people) => {
    		return people.filter((person) => person.id !== id);
    	});
    }

    return (
    	<>
    		<section>
    			<h3>prop drilling</h3>
    			<List people={people} removePerson={removePerson} />
    		</section>
    	</>
    );

};

const List = ({ people, removePerson }) => {
return (
<>
{people.map((person) => {
return (
<SinglePerson
key={person.id}
{...person}
removePerson={removePerson}
/>
);
})}
</>
);
};

const SinglePerson = ({ id, name, removePerson }) => {
return (

<div className="item">
<h4>{name}</h4>
<button onClick={() => removePerson(id)}></button>
</div>
);
};

</code>

Tutti questi passaggi, tra un Component e l'altro, potrebbero confondere e causare errori oltre che essere complicati tanto più che la struttura stessa dei Component diventa strutturata.

Per scenari del genere conviene usare la Context API o Redux, con i quali possiamo evitare tutto questo passaggio (prop drilling).

## 28. Context API / useContext

Partendo dall'esempio precedente, vogliamo una soluzione alternativa al prop drilling. Per questo useremo useContext e la Context API.
Importiamo il necessario e poi creiamo il nostro context nella sezione globale:

<code>
const PersonContext = React.createContext();
</code>

A questo dovremo fornire due Components: il "provider" ed il "consumer".

Nota: negli altri Hook visti finora fornivamo solo il consumer.

Occorre trovare qual'é il root Component, in questo caso ContextAPI e fargli restituire un fragment PersonContext.Provider come wrapper:

<code>
const ContextAPI = () => {
	const [people, setPeople] = useState(data);

    function removePerson(id) {
    	setPeople((people) => {
    		return people.filter((person) => person.id !== id);
    	});
    }

    return (
    	<>
    		<PersonContext.Provider>
    			<h3>prop drilling</h3>
    			<List people={people} removePerson={removePerson} />
    		</PersonContext.Provider>
    	</>
    );

};
</code>

Questo Provider é fornito della property value che useremo. Posso usare useContext per accedere a questa property ovunque si trovi.
Context.Provider avvolge in genere una larga parte dell'app, per esempio tutto un Component, o addirittura tutta l'intera App.

<code>
<>
			<PersonContext.Provider value="hello">
				<h3>prop drilling</h3>
				<List people={people} removePerson={removePerson} />
			</PersonContext.Provider>
		</>
</code>

In questo caso andremo a leggerla dal Component SinglePerson per esempio:
<code>
const data = useContext(PersonContext);
</code>

Qui forniamo a useContext il Context appena creato (non PersonContext.Provider).

Se controlliamo la console con l'attuale value di data del useContext, vedremo tanti richiami a value quante sono le istanze del Component.

Quindi possiamo passare delle value direttamente dal Component principale fino al Component che userà tali value senza passare per tutti i Component intermedi come nel Prop Drilling.

Possiamo passare qualunque type di dati nella value, non solo Strings ovviamente.
Quindi posso passare la funzione removePerson:

<code>
return (
<>
<PersonContext.Provider value={{ removePerson }}>
<h3>prop drilling</h3>
<List people={people} removePerson={removePerson} />
</PersonContext.Provider>
</>
);
</code>

E poi nel Component Consumer:
<code>
const SinglePerson = ({ id, name }) => {
const { removePerson } = useContext(PersonContext);
return (

<div className="item">
<h4>{name}</h4>
<button onClick={() => removePerson(id)}>remove</button>
</div>
);
};
</code>

Possiamo ora eliminare tutti i richiami a removePerson nei Components intermedi e la property people fornita all'istanza di list per ottenere:

<code>

    const ContextAPI = () => {
    	const [people, setPeople] = useState(data);

    	function removePerson(id) {
    		setPeople((people) => {
    			return people.filter((person) => person.id !== id);
    		});
    	}

    		return (
    			<>
    				<PersonContext.Provider value={{ removePerson, people }}>
    					<h3>ContextAPI - useContext</h3>
    					<List />
    				</PersonContext.Provider>
    			</>
    		);
    };

    const List = () => {
    	const mainData = useContext(PersonContext);
    	console.log(mainData);
    	return (
    		<>
    		{mainData.people.map((person) => {
    			return <SinglePerson key={person.id} {...person} />;
    		})}
    		</>
    	);
    };

    const SinglePerson = ({ id, name }) => {
    	const { removePerson } = useContext(PersonContext);
    	return (

    	<div className="item">
    		<h4>{name}</h4>
    		<button onClick={() => removePerson(id)}>remove</button>
    	</div>
    	);
    };

export default ContextAPI;

</code>

Nota: fare sempre attenzione, in questo caso si può usare sia il destructuring con removePerson nel Component SinglePerson sia accedere ai dati tramite mainData.people come nel Component List.

Occorre sempre valutare quanto in profondità deve andare una prop o una value prima di usare React.createContext e tutta la struttura associata. Se vi sono più di un livello é utile usarlo.

## 29. Custom Hooks - useFetch

I Custom Hooks ci permettono di riusare le funzionalità.
Non si parla di riusare degli elements HTML, di quello se ne occupano i Components.
Si parla per esempio del fetch dei dati, salvare sul localStorage e altre funzionalità di questo tipo.

L'esempio che andremo ad utilizzare si incentra sullo scopo e sul setup dei Custom Hooks, in modo da poter creare i propri Custom Hooks o usare quelli di altri capendoli.

L'esempio é un classico per il fetch data da un'API, capibile con i concetti studiati fin'ora:

<code>

    const Example = () => {
    	const [loading, setLoading] = useState(true);
    	const [products, setProducts] = useState([]);

    	async function getProducts() {
    		const response = await fetch(url);
    		const products = await response.json();
    		setProducts(products);
    		setLoading(false);
    	}

    	useEffect(() => {
    		getProducts();
    	}, []);

    	console.log(products);

    		return (
    			<div>
    				<h2>{loading ? "loading" : "data"}</h2>
    			</div>
    		);

    };

    export default Example;

</code>

Il punto ora non é il codice in sé, ma come riutilizzare la funzionalità.
Questo in modo che se dovessi avere un altro Component che vuole eseguire il fetch dei dati (in quest'esempio), non si debba riscrivere l'intero codice.

Ora creeremo un Custom Hook riutilizzabile in useFetch.js.
Partiamo dal taglio dal file precedente della parte inerente al fetch dei dati:

<code>

    export default useFetch = () => {
    	const [loading, setLoading] = useState(true);
    	const [products, setProducts] = useState([]);

    		async function getProducts() {
    			const response = await fetch(url);
    			const products = await response.json();

    			setProducts(products);
    			setLoading(false);
    		}

    		useEffect(() => {
    			getProducts();
    		}, []);

    };

</code>

Già così facendo abbiamo un Custom Hook quasi completo usabile nel codice Example, ma prima dobbiamo restituire qualcosa da questo Custom Hook:
<code>

    export default useFetch = (url) => {
    	const [loading, setLoading] = useState(true);
    	const [products, setProducts] = useState([]);

    			async function getProducts() {
    				const response = await fetch(url);
    				const products = await response.json();

    				setProducts(products);
    				setLoading(false);
    			}

    			useEffect(() => {
    				getProducts();
    			}, [url]);

    			return { loading, products };
    };

</code>

Così facendo, chiamando questo Custom Hook in altri Component potrò, fornendo l'url, ottenere gli State "loading" e "products". Sfruttando inoltre il dependency array con element url, al cambio di url verrà rieseguito l'Effect.

Importerò quindi il nuovo Custom Hook useFetch nel file precedente Example e dovrò invocarlo:

<code>

    import { useFetch } from "./useFetch";

    const url = "https://course-api.com/javascript-store-products";

    const Example = () => {
    const { loading, products } = useFetch(url);

    		console.log(products);

    		return (
    			<div>
    				<h2>{loading ? "loading" : "data"}</h2>
    			</div>
    		);
    };

</code>

Ora la mia funzionalità é inserita in un Custom Hook e se voglio riusarla basta importarla e istanziarla.

Nota: come norma generale, visto che useFetch é un Custom Hook, il nome deve iniziare con "use...". Sia per chiarezza, sia per non avere errori sovrascrivendo proprietà esistenti.

## 30. PropTypes - Setup

I PropTypes ci permettono di validare le nostre props.

Partiamo dal codice per capire:

<code>

    import { useFetch } from "./17- useFetch";

    const url = "https://course-api.com/react-prop-types-example";

    const PropTypes = () => {
    	const { products } = useFetch(url);
    	return (
    	<div>
    		<h2>Products</h2>
    		<section className="products">
    			{products.map((product) => {
    			return <Product key={product.id} {...product} />;
    			})}
    		</section>
    	</div>
    	);
    };

    export default PropTypes;

</code>

Qui, guardando alla lezione precedente, possiamo vedere che utilizziamo solo lo State dato da useFetch chiamato "products" e possiamo fare a meno di considerare l'altro. Non abbiamo inoltre bisogno di dichiarare nessuno nuovo State per accedere ai dati, visto che già tutto proviene dal Custom Hook useFetch.

Per vedere come i PropTypes vengono in aiuto proviamo a ricavare le varie properties, come name, url dell'immagine o altro, e vediamo poi l'utilizzo dei Prop Types.

Agiamo si Product.js:

<code>

    import React from "react";

    const Product = ({ image, name, price }) => {
    	return (
    	<article className="product">
    		<h4>{name}</h4>
    		<p>{price}</p>
    	</article>
    	);
    };

    export default Product;

</code>

Così facendo visualizziamo il name ed il price provenienti dall'API. Ma vi é un piccolo bug voluto, l'ultimo price non é presente nell'object dell'API.
Questo ci ricorda che non é sempre garantito che arrivi qualche tipo di value, i dati potrebbero non essere presenti o altro.

Nell'esempio appena mostrato é presente proprio il problema che ci siamo relazionati ai dati dando per scontato che arrivasse un parametro price --> {image, name, price}.
Se mancasse la value ad una property per esempio image.url nella property src di un image si avrebbe un errore che bloccherebbe l'App.
Quindi come agire se la value non é presente?

Imposteremo i PropTypes che controlleranno eventuali value mancanti ed inoltre imposteremo delle value di default.
Usiamo l'import per il package già compreso in React.js:

import PropTypes from "prop-types";

Si userà la property nel Component Product.propTypes già presernte e al suo interno:

<code>

    Product.propTypes = {
    	image:PropTypes.object.isRequired
    }

</code>

Nello specifico: si indica la property nel quale usare PropTypes come value:

<code>

    Product.propTypes = {
    	image:PropTypes
    }

</code>

Si indica quale type ci si aspetta:

<code>

    Product.propTypes = {
    	image:PropTypes.object
    }

</code>

Lo si indica come necessario:

<code>

    Product.propTypes = {
    	image:PropTypes.object.isRequired
    }

</code>

Quindi si otterrà:

<code>

    Product.propTypes = {
    	image: PropTypes.object.isRequired,
    	name: PropTypes.string.isRequired,
    	price: PropTypes.number.isRequired
    };

</code>

Nella console ora riusciamo ad identificare chiaramente dove sono le mancanze.

Vediamo ora come aggiungere delle values di default. Semplicemente sotto a Product.propTypes inseriamo:

<code>

    Product.defaultProps = {
    	name: "default name",
    	price: 3.99,
    	image: ""
    };

</code>

Per le immagini importeremo un'immagine di default dalla cartella assets con:
import defaultImage from "../assets/default-image.jpg";

Da notare che dobbiamo aggiungere l'estensione del file al Path, visto che non si tratta di un file JavaScript.

Quindi avremo:
<code>

    import defaultImage from "../assets/default-image.jpg";

    const Product = ({ image, name, price }) => {
    	return (
    		<article className="product">
    			<h4>{name}</h4>
    			<p>{price}</p>
    		</article>
    	);
    };

    Product.propTypes = {
    	image: PropTypes.object.isRequired,
    	name: PropTypes.string.isRequired,
    	price: PropTypes.number.isRequired
    };

    Product.defaultProps = {
    	name: "default name",
    	price: 3.99,
    	image: defaultImage
    };

</code>

Così riusciremo ad ottenere una value di dafault per il price ma l'image presenta ancora un errore e non viene visualizzata.

Vediamo come intervenire usando gli Short Circuit Operators.

Per values semplici possiamo usare al posto di quanto visto prima:

<p>{price || 3.99}</p>

Questa soluzione non funziona però per le images.
Possiamo però usare:
const url = image && image.url;

Per sistemare la situazione. In questo modo, se l'image esiste, allora mi restituirà l'url.
Otterremo quindi:

<code>
const Product = ({ image, name, price }) => {
const url = image && image.url;

    return (
    	<article className="product">
    		<img src={url || defaultImage} alt={name || "default name"} />
    		<h4>{name}</h4>
    		<p>{price || 3.99}</p>
    	</article>
    );

};

Product.propTypes = {
image: PropTypes.object.isRequired,
name: PropTypes.string.isRequired,
price: PropTypes.number.isRequired
};

// Product.defaultProps = {
// name: "default-name",
// price: 3.99,
// image: defaultImage
// };

export default Product;
</code>

Si può anche importare come component esterno un file di testing con la struttura dei PropTypes.
Come shorthand scrivere in un file vuoto:
raftcp

## 31. React Routers - Basic Setup

Fino ad ora i nostri esempi sono stati sulla stessa pagina. Quando si esce dai tutorial é ovvio che si possa necessitare di molteplici pagine.

Quando si parla di framework JavaScript chiaramente non si parla di tradizionali pagine HTML.
In tale caso si parla si SinglePageApplication significa che abbiamo una pagina, un div, con un id "root" e invece di tornare al server ed eseguire la richiesta di informazioni sulle pagine dove l'utente naviga, impostiamo un routing sul client side senza il refresh delle pagine.

Come nell'esempio video mostrato, passeremo da una pagina all'altra come tra le varie routes in Node.js, senza variare il link della pagina ma solo tra le varie "routes" (url/pageone oppure url/pagetwo).

React.js non ha un routing interno quindi dobbiamo installare un node package esterno.

Una volta installato possiamo anche osservare i cambiamenti nella nuova versione rispetto al tutorial.

Creiamo tutte le varie pagine come nel tutorial, per capire meglio il nuovo argomento.

Importiamo ora il necessario nella pagina principale, nel tutorial indicato index.js ma faremo diversamente qui:

import { BrowserRouter as Router, Route, Switch } from "react-router-dom";

Avvolgeremo il risultato del return nel Fragment Router, che in genere avvolge tutta l'Applicazione comunque:
<code>
const ReactRouterSetup = () => {
return <Router>react router</Router>;
};

export default ReactRouterSetup;
</code>

In sintesi il setup é lo stesso del precedente, solo che viene avvolto nel Fragment Router, e nelle vere SinglePageApplications viene avvolto il return Component App.

Ora andremo ad impostare le Routes, che significa che nell'url quando navighiamo vedremo quel Component specifico.

Per indicare una Route nel Router:
<Route path=...>
Dove Path sarà il /dominio per l'applicazione.
Al suo interno andremo a renderizzare il Component associato.
Per la Home, lascieremo solo / nel Path e renderizzeremo Home:

<code>
const ReactRouterSetup = () => {
	return (
		<Router>
			<Route path="/">
				<Home />
			</Route>
		</Router>
	);
};
</code>

Home é una scelta, potrebbe essere qualunque altro Component.

Ora aggiungiamo una Route per ogni altro Component, osservando bene il Path indicato:
<code>

    <Route path="/about">
    	<About />
    </Route>

</code>

Così facendo si passerà da Home con path / per arrivare ad About con path /about.
La scelta del nome dell'url spetta a noi, non vi sono obblighi. Occorre comunque rispettare le regole studiate nel corso Node.js seguendo le best practice.

Quindi:

<code>
const ReactRouterSetup = () => {
	return (
		<Router>
			<Route path="/">
				<Home />
			</Route>
			<Route path="/about">
				<About />
			</Route>
			<Route path="/people">
				<People />
			</Route>
		</Router>
	);
};
</code>

ATTENZIONE: Errore dovuto a nuova versione. Notare cambiamenti:
<code>

    const ReactRouterSetup = () => {
    	return (
    	<BrowserRouter>
    		<Routes>
    			<Route path="/" element={<Home />}></Route>
    			<Route path="/about" element={<About />}></Route>
    			<Route path="/people" elemement={<People />}></Route>
    		</Routes>
    	</BrowserRouter>
    	);
    };

</code>

Rilevato un errore nel tutorial non presente nella versione 6 di react-routers: quando vado nelle routes, resta visualizzata anche la Home /. Questo accadeva perché di default se i path corrispondevano la pagina veniva renderizzata quindi per esempio in /about corrispondeva sia / che /about, quindi venivano visualizzate entrambe.

Per risolverlo:
<Route exact path="/" element={<Home />}></Route>

con exact indicato nella route principale. Era consigliato aggiungerlo anche alle altre routes se vi fossero state delle pagine annidate a queste (esempio /about/contacts/form)

## 32. React Routers - Error And Switch

Ora abbiamo bisogno di una pagina di errore nel caso di pagina errata / non esistente, per esempio se provassi url/hello. Questo darebbe un'esperienza migliore.
Per impostare una pagina di errore la route dev'essere:
<Route path="*"></Route>

L'asterisco sta ad indicare che corrisponde sempre, quindi in caso di url non trovata o di errore verrà visualizzata questa pagina.
Quindi nella v5:

<code>

    <Route path="*" >
    	<Error />
    </Route>

</code>

Nella v6:

<code>

    <Route path="\*" element={<Error />}></Route>

</code>

In seguito aggiungeremo un element Link per reindirizzare l'utente ad un'altra Page.

Ora avremo però un piccolo problema: quando andrò nell'url della pagina "/about" si visualizzerà la pagina di errore.

E' esattamente qui che torna utile Switch.

NOTA: questo non avviene nella Versione 6 di react-routers, per questo Switch dovrebbe essere stato rimosso, controllare.

Inserendo tutti i Route Components nello Switch solo la prima page che corrisponde all'url verrà visualizzata, quindi non verrà mostrata la Error Page.

<code>
<Routes>
				<Switch>
					<Route exact path="/" element={<Home />}></Route>
					<Route path="/about" element={<About />}></Route>
					<Route path="/people" element={<People />}></Route>
					<Route path="*" element={<Error />}></Route>
				</Switch>
			</Routes>
</code>

Nota: rimosso dalla pagina per motivo nota soprastante.

## 33. React Routers - Links

Navigare usando la barra di ricerca non é chiaramente la miglior UserExperience. Per questo abbiamo bisogno degli elements Link inseriti nelle pagine.

Per far si di inserirli in modo elegante creeremo una Navbar.
Inseriamo quindi la Navbar dentro all'Element Router.
Attenzione, nell'element BrowserRouter in v6, non Router.
Attenzione, non all'interno dell'element Switch in v5.

<code>
const ReactRouterSetup = () => {
	return (
		<BrowserRouter>
			<Navbar />
			<Routes>
				<Route exact path="/" element={<Home />}></Route>
				<Route path="/about" element={<About />}></Route>
				<Route path="/people" element={<People />}></Route>
				<Route path="*" element={<Error />}></Route>
			</Routes>
		</BrowserRouter>
	);
};
</code>

Ora avremo una Navbar visualizzata sopra ad ogni pagina presente come Route nell'App.

Miglioriamo ora la Navbar inserendo quindi anche i Link elements.
I Link chiaramente sono diversi dagli elements "a" in HTML ed hanno delle specifiche props:

• la prop "to" indica in quale pagina sarà reindirizzato l'utente

<code>
const Navbar = () => {
	return (
		<nav>
			<ul>
				<li>
					<Link to="/">Home</Link>
				</li>
				<li>
					<Link to="/about">About</Link>
				</li>
				<li>
					<Link to="/people">People</Link>
				</li>
			</ul>
		</nav>
	);
};
</code>

Creiamo quindi un Link per reindirizzare alla Home anche sulla pagina di Error:

<code>
const Error = () => {
	return (
		<>
			<h2>Error Page</h2>
			<br />
			<Link to="/" className="btn">
				Back Home
			</Link>
		</>
	);
};
</code>

Occorre tenere presente che la Navbar viene visualizzata in ogni Page, quindi possiamo tornare alla Home dalla pagina di Error sia tramite il Link stilizzato come un button appena creato oppure usando la Navbar.

## 33. React Routers - URL Params And Placeholders

Spostiamoci ora nella Page People.
Creeremo dei Placeholders che una volta clickati ci mostreranno delle informazioni su ogni element dell'array "people", come fosse una lista di prodotti in un ecommerce per esempio.
Non creeremo quindi una pagina per ogni element, piuttosto creeremo un singolo placeholder che coglierà i dati dell'element e li visualizzerà.

Quindi partendo da:

<code>

    const People = () => {
    	const [people, setPeople] = useState(data);
    	return (
    	<div>
    		<h1>People Page</h1>
    		{people.map((person) => {
    		return (
    			<div key={person.id} className="item">
    				<h4>{person.name}</h4>
    			</div>
    		);
    		})}
    	</div>
    	);
    };

</code>

Utilizzeremo il Component già creato Person.js e per farlo dobbiamo impostare una nuova Route in BrowserRouter.
Questa avrà una prop path che ricalca quella per i params in Node.js, quindi "/:param":

<Route path="/:id"></Route>

La prop path dipende da noi, sempre seguendo le regole imparate, ma potrebbe essere anche "/person/:id".

Non inseriremo il Component all'interno di Route (v5) o nella prop element (v6) ma inseriremo una seconda prop "children":

<code>
		<Route path="/person/:id" children={<Person />}></Route>
</code>

Person.js diverrà quindi il nostro placeholder e ogni volta che navigheremo nell'url con person e uno specifico id (/person/:id) visualizzeremo il Person Component. Nel Person component coglieremo l'id e utilizzeremo il fetch dei dati.

Quindi in People.js imposteremo un Link dove la prop to sarà impostata dinamicamente:

<code>

    const People = () => {
    	const [people, setPeople] = useState(data);
    	return (

    	<div>
    		<h1>People Page</h1>
    		{people.map((person) => {
    			return (
    				<div key={person.id} className="item">
    					<h4>{person.name}</h4>
    					<Link to={`/person/:${person.id}`}>Learn More</Link>
    				</div>
    			);
    		})}
    	</div>
    	);
    };

</code>

Così facendo ogni volta che andremo a clickare nel Link presente a fianco di ogni Person della lista in People.js verremo reindirizzati alla pagina del Component Person.js.
In v6 non sarà diverso dalle altre Route, cambierà solo il path con :id :

<code>

    <Route path="/person/:id" element={<Person />}></Route>

</code>

in v5:

<code>

    <Route path="/person/:id" children={<Person />}></Route>

</code>

Ora in Person vogliamo cogliere l'id del param in modo da cogliere i dati corretti nei dati, l'array "data".
E' normale effettuare un secondo fetch dei dati quando si utilizza il placeholder clickando sul Link a finco del nome nella lista in People.js.

Per cogliere l'id useremo useParams, un Hook fornito da react-router.

Usando console.log(useParams()); in Person.js avremo come risposta un object con id: String per esempio id:1.
Nota: la key id deriva dall'url impostato da noi, cambierebbe se avessimo impostato per esempio /people/:name.

Otteniamo quindi l'id in Person.js:
<code>
const { id } = useParams();
</code>

Quindi:

<code>

    const Person = () => {
    	const [name, setName] = useState("default name");
    	const { id } = useParams();
    		useEffect(() => {
    			const newPerson = data.find((person) => {
    				return person.id === parseInt(id.split(":")[1]);
    			});
    			setName(newPerson.name);
    		}, []);

    		return (
    			<div>
    				<h2>{name}</h2>
    				<Link to="/people" className="btn">
    					Back to People
    				</Link>
    			</div>
    		);
    };

</code>

Attenzione: id restituito comprende il carattere ":".

## 34. React Routers - React.js Optimization Warning - useMemo

Qui parleremo delle Performance dell'App, con nello specifico:

• React.memo
• useCallback
• useMemo
• Memoizing --> caching results

React.js é veloce di default. Solo perché abbiamo questi strumenti per velocizzarlo ulteriormente non dobbiamo farlo per forza.

Le ottimizzioni hanno il loro costo, usano memoria e il potere computazionale, occorre essere sicuri di ciò che si fa.

Partiamo da un esempio già preimpostato che usa le conoscenze acquisite fin'ora:

<code>

    const url = "https://course-api.com/javascript-store-products";

    const Memoizing = () => {
    	const { products } = useFetch(url);
    	const [count, setCount] = useState(0);

    	return (
    		<>
    			<h2>Count: {count}</h2>
    			<button className="btn" onClick={() => setCount(count + 1)}>
    				click me
    			</button>
    			<BigList products={products} />
    		</>
    	);

    };

    const BigList = ({ products }) => {
    	return (

    	<section className="products">
    		{products.map((product) => {
    		return <SingleProduct key={product.id} {...product}></SingleProduct>;
    		})}
    	</section>
    	);
    };

    const SingleProduct = ({ fields }) => {
    	let { name, price } = fields;
    	price = price / 100;
    	const image = fields.image[0].url;
    			return (
    				<article className="product">
    					<img src={image} alt={name} />
    					<h4>{name}</h4>
    					<p>${price}</p>
    				</article>
    			);
    };

    export default Memoizing;

</code>

Aggiungiamo ora un console.log dentro ad un useEffect nel Component BigList e un console.count nel Component SingleProduct. Come si può vedere i render sono già molti al solo avvio, ma se clickiamo crescono in modo esponenziale.

Questo accade perché abbiamo una State value che usa useState e al cambio della value clickando il button avvia il re-render.
Questo re-render comprende anche un nuovo render di BigList e di ogni SigleProduct Component presente.

Una soluzione a questo, oltre a quella vista nella parte dello scorso Tutorial, usare React.memo.

Quindi occorre avvolgere tutto il Component in:
React.memo(Component)

<code>

    const BigList = React.memo(({ products }) => {
    	useEffect(() => {
    	console.log("big list called");
    	}, []);

    			return (

    				<section className="products">
    					{products.map((product) => {
    					return <SingleProduct key={product.id} {...product}></SingleProduct>;
    					})}
    				</section>
    			);
    });

</code>

Ora se controlliamo la console, il render avviene solo nel caricamento iniziale e NON quando viene premuto il button mutando lo State count.

React.memo controlla (Memoizing) qual'é la value.
Quindi se la prop value non cambia (products in questo caso) non avviene un re-render.

Nota: ricordare che quando una prop o uno State cambia, avviene un re-render del Component.

Visto che non avviene il re-render per il Component BigList, anche i subComponents SingleProduct non vengono renderizzati nuovamente.

## 35. React Routers - React.js Optimization - useCallback

Con lo stesso esempio precedente, creiamo uno State "cart".
Inoltre una funzione per aggiungere al cart e un h2 per visualizzare la value {cart}:

<code>

    const [cart, setCart] = useState(0);

    function addToCart() {
    	setCart((prevCart) => {
    		return prevCart + 1;
    	});
    }

    <h2 style={{ marginTop: "3rem" }}>cart: {cart}</h2>

</code>

Quindi aggiungiamo al Component BigList la prop
addToCart={addToCart}. Questo poi allo stesso modo ai Components SingleProduct (Prop Drilling ma va bene qui come esempio).
Poi gestiamo la prop nella dichiarazione del Component SingleProduct:

<code>

    const SingleProduct = ({ fields, addToCart }) => {
    	useEffect(() => {
    	console.count("single item called");
    	}, []);
    	let { name, price } = fields;
    	price = price / 100;
    	const image = fields.image[0].url;

    		return (
    			<article className="product">
    				<img src={image} alt={name} />
    				<h4>{name}</h4>
    				<p>${price}</p>
    				<button onClick={addToCart}></button>
    			</article>
    		);
    };

</code>

Clickando nel button appena creato si avrà lo stesso problema precedente, una serie di re-render esponenziali.
Questo perché la prop addToCart viene creata da zero varie volte, in particolare quando si aggiunge al cart, questo comporta un re-render per ogni aggiunta.

Per sistemare questo problema si può usare useCallback.
Questo Hook fa essenzialmente lo stesso che fa React.memo ma con una function. Quando la value cambia la funzione viene ricreata altrimenti no.

Cambierò quindi la funzione, aggiungendo anche il dependency array, in modo che ogni volta che la value di cart si aggiorna, solo allora venga ricreata la funzione.

<code>

    const addToCart = useCallback(() => {
    		setCart((prevCart) => {
    			return prevCart + 1;
    		});
    	}, [cart]);

</code>

## 36. React Routers - React.js Optimization - useMemo

A differenza di useCallback che memorizza una funzione e non la ricrea se non cambia la value del Dependency Array, useMemo interagisce invece con le values.

Da non confondersi con React.memo che controlla la variazione di una prop essenzialmente, useMemo é specifico per le values.

Creiamo una funzione calculateMostExpensive, che altro non farà che calcolare il prodotto più costosto nella lista. Sfrutteremo il metodo "reduce" degli array per questo:

<code>

    function calculateMostExpensive(data) {
    	return (
    	data.reduce((total, item) => {
    		const price = item.fields.price;
    		if (price >= total) {
    			total = price;
    		}
    		return total;
    		}, 0) / 100
    	);
    }

</code>

Inserirò poi:

<code>

    <h2>Most Expensive: ${calculateMostExpensive(products)}</h2>

</code>

Teniamo presente che a differenza di quest'esempio, siamo nell'ambito delle funzioni che impiegano molto tempo per calcolare.

Proprio per questo sarebbe utile, visto che ad ogni click di un button avviene un re-render, tenere a mente questa value difficile da calcolare. E fare in modo che venga ricalcolata solamente se vi fosse un cambiamento in data (che in questa chiamata a calculateMostExpensive é "products").
E' qui che viene in aiuto useMemo.

Inseriamo prima del return:

<code>

    const mostExpensive = useMemo(callback, dependencyArray)

</code>

Quindi:

<code>

    const mostExpensive = useMemo(
    	() => calculateMostExpensive(products),
    [products]
    );

</code>

Sostituiamo quindi la chiamata a calculateMostExpensive nell'h2 con la value risultante dall'Hook useMemo:

<code>

    <h2>Most Expensive: ${mostExpensive}</h2>

</code>

## 37. React Routers - React.js Optimization - useCallback - Fetch Example

Come ultima sezione troviamo un use case adatto per l'Hook useCallback proprio nel Custom Hook useFetch. In questo si presenta un infinite loop nella chiamata a getProducts dentro a useEffect, perché viene ricreato ogni volta che deve venire eseguita come funzione.
Risolviamo quindi usando useCallback nella sua dichiarazione:

<code>
export const useFetch = (url) => {
	const [loading, setLoading] = useState(true);
	const [products, setProducts] = useState([]);

    const getProducts = useCallback(async () => {
    	const response = await fetch(url);
    	const products = await response.json();

    	setProducts(products);
    	setLoading(false);
    }, [url]);

    useEffect(() => {
    	getProducts();
    }, [url, getProducts]);

    return { loading, products };

};
</code>

E questo é quanto.
FINE SECONDA PARTE - ADVANCED

# Terza parte - Facoltativo React Routers v6

## 1. First Pages

React-Router permette di creare più pagine basate sui Components restando in una SinglePageApplication. Non ha bisogno di andare a richiedere la nuova pagina da caricare ad un server, tutto viene contenuto in un singolo div, gestendo la logica grazie a JavaScript.

React.js non ha un sistema integrato di routing, quindi ci si basa per questo sul package react-routers.

Tutto questo permette una risposta ed un caricamento delle nuove pagine rapidissimo, senza il bisogno di un caricamento o ricaricamento delle pagine.

Cominciamo dal primo esempio per capire il funzionamento di questa nuova versione di react-router.
In App.js eseguiamo gli imports:

import { BrowserRouter, Routes, Route } from "react-router-dom";

Per connetterci con il Browser attuale usiamo l'element BrowserRouter:

<code>

    export default function App() {
    	return <BrowserRouter>React Router Tutorial</BrowserRouter>;
    }

</code>

Poi aggiungiamo l'Element Routes come nella versione 5 e le singole Route:

<code>

    export default function App() {
    	return (
    		<BrowserRouter>
    			<Routes>
    				<Route />
    			</Routes>
    		</BrowserRouter>
    	);
    }

</code>

La property path riflette ciò che abbiamo nell'url, quindi per la home basta "/".

La property element indica il Component da renderizzare in tale Route. Può essere anche un semplice div contenitore con altri elements al suo interno.

Avremo quindi come esempio basilare:

<code>

    export default function App() {
    	return (
    		<BrowserRouter>
    			<Routes>
    				<Route path="/" element={<div>home page</div>} />
    			</Routes>
    		</BrowserRouter>
    	);
    }

</code>

Creaimo ora una piccola pagina d'esempio (una dummy page).
Aggiungiamo quindi una route:

<code>

    <Route path="testing" element={
    	<div>
    		<h2>testing</h2>
    	</div>
    }
    />

</code>

Per accedervi per il momento possiamo usare solo l'url "url/testing", una Navbar verrà aggiunta in seguito.

## 2. Page Components

Inserire direttamente degli elements HTML nella property element di una Route non é la scelta ideale, non per ultimo come motivo un eccessivo uso delle risorse.

Passiamo quindi dei Components ad element dopo averli creati:

<code>

    export default function App() {
    	return (
    	<BrowserRouter>
    		<Routes>
    			<Route path="/" element={<Home />} />
    			<Route path="about" element={<About />} />
    			<Route path="products" element={<Products />} />
    		</Routes>
    	</BrowserRouter>
    	);
    }

</code>

Ora tutto quello che abbiamo nel Component sarà il content della page visualizzate all'url del path.
Dentro a tale Component può benissimo esserci anche un altro Component.

In questo modo diventa molto più facile gestire l'App rispetto che con l'hard coding di HTML nella property element.

## 3. Link Component

Vediamo ora come navigare nel nostro progetto, visto che al momento l'unico modo é attraverso la url bar.

Per farlo non vi sono elementi "a" HTML ma si usa in Component Link di React-Routers. Per navigare in pagine esterne si usa ancora l'element "a" con href.

<code>

    <Link to="/about" className="btn">
    	About
    </Link>

</code>

La parte essenziale, come si nota, del Component Link é la property "to", alla quale si passa l'url composto da foreslash e la parte finale dell'url, cioé la page alla quale si vuole essere reindirizzati.

Aggiungiamo un Link sia ad Home che ad About per alternarsi tra le due pages.

## 4. Error Component

Per poter gestire gli errori di inserimento di pagine nell'url, si utilizza un Route Component nel nostro Component Routes, con path="\*", e si imposta una Error page come element.
Nella Error page impostiamo un messaggio d'errore per indicare che l'url utilizzato non presenta corrispondenze tra le nostro Route.

Imposteremo inoltre un Component Link per ritornare alla Home Page.

<code>
const Error = () => {
	return (
		<section className="section">
			<h2>404</h2>
			<p>page not found</p>
			<Link to="/" className="btn">
				Back Home
			</Link>
		</section>
	);
};
</code>

## 5. Navbar

Qui capiremo come impostare una Navbar nella nostra App. Sarà un approccio un po' riduttivo ma che andrà però a mutare nelle prossime lezioni con un approccio più rifinito dove andremo ad annidare le nostre pagine ed ad avere un layout condiviso.

Per ora inseriremo un element "nav" e un "footer" subito prima e subito dopo il nostro Component Routes.

Questi due elements verranno visti in tutte le pages.

<code>

    export default function App() {
    	return (
    		<BrowserRouter>
    			<nav>out navbar</nav>
    			<Routes>
    				<Route path="/" element={<Home />} />
    				<Route path="about" element={<About />} />
    				<Route path="products" element={<Products />} />
    				<Route path="\*" element={<Error />} />
    			</Routes>
    			<footer>our footer</footer>
    		</BrowserRouter>
    	);
    }

</code>

Questo é l'approccio più basico per avere un layout condiviso.

## 6. Nested Routes

In questa lezione vedremo come aggiungere una Navbar con delle Nested Routes, dei Layout condivisi e una pagina di index.

Per annidare delle Routes in una Route parent, userò nel parent invece di un tag self closing uno normale.

<code>

    export default function App() {
    	return (
    		<BrowserRouter>
    			<nav>out navbar</nav>
    			<Routes>
    				<Route path="/" element={<Home />}>
    					<Route path="about" element={<About />} />
    					<Route path="products" element={<Products />} />
    					<Route path="*" element={<Error />} />
    				</Route>
    			</Routes>
    			<footer>our footer</footer>
    		</BrowserRouter>
    	);
    }

</code>

Occorre modificare le varie properties path delle Route annidate, altrimenti si avranno degli errori. Queste nuove value dovranno essere relative al path del parent altrimenti si potrà solo vedere il Component parent, mai quelle nested.

## 7. Shared Layout

Per risolvere il problema della lezione precedente e inoltre capire come avere uno Shared Layout dobbiamo per prima cosa modificare il Component parent direttamente.

Nel nostro caso sarà Home, nel quale andremo prima ad importare il Component "Outlet".

Il Component Outlet andrà a rappresentare tutto ciò che verrà condiviso tra il Component Route Parent e tutti i Component Route Nested al suo interno.

<code>

    const Home = () => {
    	return (
    		<section className="section">
    			<h2>Home</h2>
    			<Outlet />
    		</section>
    	);
    };

</code>

Al momento tutto quello nella Home sarà condiviso tra le pages.

Con questo principio andiamo a creare un Component Navbar con i vari Link Components al suo interno:

<code>

import { Link, Outlet } from "react-router-dom";

    const Navbar = () => {
    	return (
    			<nav className="navbar">
    				<Link to="/">Home</Link>
    				<Link to="/about">About</Link>
    				<Link to="/products">Products</Link>
    			</nav>
    	);
    };

</code>

Importiamo ora il Navbar Component in Home.js. Come detto qualunque struttura impostata SOPRA al Component Outlet verrà condiviso tra le pages annidate (nested) all'interno della Route parent, in questo caso Home:

<code>
const Home = () => {
	return (
		<>
			<Navbar />
			<section className="section">
				<Outlet />
			</section>
		</>
	);
};
</code>

Così avremo il Component Navbar condiviso tra le pages.
Ora occorre capire come impostare una Index Page, la pagina principale, che fino a poco fa era la section di Home con il titolo.

## 8. Index Pages

Ora manca il content nella Home page.
Qualunque element ora si aggiungesse, verrebbe condiviso tra tutti i Components Routes annidati.

La soluzione é impostare un Index Route.

• Le Index Routes renderizzano nelle parent routes nel path del parent della Route.

• Le Index Routes corrisponde (si trovano / match) quando corrisponde una parent Route ma non corrisponde con nessun children / nested Component Route.

• Una Index Route é la Child Route di default per una Parent Route.

• Le Index Routes vengono renderizzare quando l'user non ha ancora clickato nessuno degli item in una Navigation List.

Partendo da questo quindi:

<code>

    export default function App() {
    	return (
    		<BrowserRouter>
    			<Routes>
    				<Route path="/" element={<Home />}>
    					<Route path="about" element={<About />} />
    					<Route path="products" element={<Products />} />
    					<Route path="*" element={<Error />} />
    				</Route>
    			</Routes>
    		</BrowserRouter>
    	);
    }

</code>

Per impostare una Index Route creerò una Route Component con property index senza value. Il Path di questa Route corrisponderà SEMPRE con la property path della Route Parent.
Avremo poi una property element che indicherà il Component da renderizzare.

Creiamo quindi un nuovo Component SharedLayout nel quale andremo a copiare tutto quello che abbiamo nel Component Home.
Lo aggiungeremo quindi come property element al Parent Component Route in App.js.
Questo Component sarà quindi condiviso tra tutte le pages nested nella Route parent.

Impostiamo quindi la Index Route per questa Parent Route.

<code>
export default function App() {
	return (
		<BrowserRouter>
			<Routes>
				<Route path="/" element={<SharedLayout />}>
					<Route index element={<Home />} />
					<Route path="about" element={<About />} />
					<Route path="products" element={<Products />} />
					<Route path="*" element={<Error />} />
				</Route>
			</Routes>
		</BrowserRouter>
	);
}
</code>

In questo modo avremo un layout condiviso e ciò che é contenuto nel Component Home sarà renderizzato come Index Page.

Puliamo il Content di SharedLayout in modo che sia più chiaro il concetto di "Ciò che si trova sopra al Component Outlet viene condiviso tra i Component Route annidati":

<code>
const SharedLayout = () => {
	return (
		<>
			<Navbar />
			<Outlet />
		</>
	);
};
</code>

## 9. NavLink Component

Creaimo ora una Navbar nuova, che userà i Components NavLink.
Questi Components sono più adatti alla modifica dello style, vista la property adatta presente, che restituisce di default il parametro isActive, adatto ad identificare se un link é attivo o meno per modificarne lo style.

Copiamo il contenuto del Component Navbar nel nuovo Component StyledNavbar.

Invece del Component Link importiamo NavLink e cambiamo tutti i Link in NavLink.

<code>
const StyledNavbar = () => {
	return (
		<nav className="navbar">
			<NavLink to="/">Home</NavLink>
			<NavLink to="/about">About</NavLink>
			<NavLink to="/products">Products</NavLink>
		</nav>
	);
};
</code>

Modifichiamo il Component in SharedLayout.

Ora clickando su un link verrà aggiunta in automatico al link attivo una class denominata "active". Avendo già uno style scritto in CSS per questa class potremo cambiare lo style del Component facilemente.

Vediamo come aggiungere uno style ad un singolo Component nella StyledNavbar. Partiamo da:

<code>

    const StyledNavbar = () => {
    	return (
    		<nav className="navbar">
    			<NavLink to="/" style={({ isActive }) => {

    			}}>Home</NavLink>
    			<NavLink to="/about">About</NavLink>
    			<NavLink to="/products">Products</NavLink>
    		</nav>
    	);
    };

</code>

Si noti che isActive non é un parametro ma un object, infatti la property style:
style={({obj}) => {}};

Che diverrà quindi:
<code>

    const StyledNavbar = () => {
    	return (
    		<nav className="navbar">
    			<NavLink
    			to="/"
    			style={({ isActive }) => {
    			return { color: isActive ? "red" : "grey" };
    			}} >
    			Home
    			</NavLink>
    			<NavLink to="/about">About</NavLink>
    			<NavLink to="/products">Products</NavLink>
    		</nav>
    	);
    };

</code>

Invece per aggiungere una class dinamicamente possiamo usare:

<code>
<NavLink
				to="/"
				className={({ isActive }) => (isActive ? "link active" : "link")}
			>
				Home
			</NavLink>
</code>

Ricordarsi di modificare le classes con il nome corretto nel CSS e di connettere i giusti Component tra loro.

## 10. Reading URL Params

Impariamo ora come ottenere i parametri di un URL, in modo da ottenere come risultato delle pagine dinamiche.

Reimmaginiamo quindi la page Products, dove saranno disposti una serie di prodotti, e quando clickiamo uno specifico prodotto questo verrà visualizzato in una page separata.
Questa é la chiave: non voglio impostare una pagina separata per ogni singolo prodotto che ho, ma ha molto più senso impostare una singola pagina che fungerà da placeholder, ed ottenere i dati che dovrò visualizzare.

Potrò così usare questa Page anche per 400 prodotti.

Per impostare i parametri dell'URL userò :nameOfTheParam.
Nel nostro caso sarà :productId

<code>

    export default function App() {
    	return (
    		<BrowserRouter>
    			<Routes>
    				<Route path="/" element={<SharedLayout />}>
    				<Route index element={<Home />} />
    				<Route path="about" element={<About />} />
    				<Route path="products" element={<Products />} />
    				<Route path="products/:productId" element={<SingleProduct />} />
    				<Route path="\*" element={<Error />} />
    				</Route>
    			</Routes>
    		</BrowserRouter>
    	);
    }

</code>

Nota: Si può eventualmente anche impostare una struttura nested come visto nelle lezioni precedenti.

Per accedere ai parametri dell'URL usiamo l'Hook useParams. Si noti che il name dell'object {productId} deve corrispondere con quello del param indicato nel path della Route.

<code>

    import { Link, useParams } from "react-router-dom";

    const SingleProduct = () => {
    	const { productId } = useParams();
    	return (
    		<section>
    			<h4>{productId}</h4>
    			<Link to="/products">back to products</Link>
    		</section>
    	);
    };

    export default SingleProduct;

</code>

In questo modo possiamo accedere ai params dell'URL che utilizzeremo nella prossima lezione per cercare un product specifico dopo aver iterato tra i dati forniti per ottenere una lista di products.

## 11. Single Product

In Products.js modifichiamo importando i dati forniti e iterando tra questi creaiamo una lista prodotti:

<code>

    const Products = () => {
    	return (
    		<section className="section">
    			<h2>Products</h2>
    			<div className="products">
    				{products.map((product) => {
    					return (
    						<article key={product.id}>
    							<h5>{product.name}</h5>
    							<Link to={`/products/${product.id}`}>more info</Link>
    						</article>
    					);
    				})}
    			</div>
    		</section>
    	);
    };

</code>

Si noti che l'url fornito nel Component Link é dove passiamo dinamicamente le informazioni, in questo caso product.id per essere colto nel param productId nel Component SingleProduct.

Nota: Solitamente si ottengono questo tipo di dati da un'API, quindi é consigliabile l'uso dell'Hook useEffect per il fetch.

Ora in SingleProduct, identifichiamo il product tramite .find(), otteniamo image e name e poi utilizziamo questi dati per un element "img" e un "h5".

<code>

    const SingleProduct = () => {
    	const { productId } = useParams();
    	const product = products.find((prod) => prod.id === productId);
    	const { image, name } = product;
    	return (
    		<section>
    			<img src={image} alt={name} />
    			<h5>{name}</h5>
    			<Link to="/products">back to products</Link>
    		</section>
    	);
    };

    export default SingleProduct;

</code>

## 12. useNavigate()

Ora vediamo come possiamo muoverci nel nostro progetto in modo programmatico. Nel nostro caso avverrà quando sottoporremo (submit) un form.
Vedremo inoltre come possiamo restringere l'accesso solo a certe Routes.

Nota: Prima di cominciare si consideri che normalmente usiamo il context per archiviare una value.

Comiminceremo da App.js, dichiarando uno State e creando i Components Login e Dashboard ed usandoli nelle rispettive Route con i rispettivi path.
Al Component Login passerò una prop setUser con value la funzione setter setUser, a quello Dashboard passerò una prop user con State value user.

Aggiungiamo un NavLink alla Navbar per Login.

Per la creazione del Component Login andremo in qualcosa di più articolato. Partendo da un form con due campi input, un button e due State per name e email dichiarati, la prop setUser colta dalla prop mandata da App.js:

<code>
const Login = ({setUser}) => {
	const [name, setName] = useState("");
	const [email, setEmail] = useState("");

    async function handleSubmit(event) {
    	event.preventDefault();
    	console.log(name, email);
    }

    return (
    	<section>
    		<form className="form" onSubmit={handleSubmit}>
    			<h5>login</h5>
    			<div className="form-row">
    				<label htmlFor="name">name</label>
    				<input
    					type="text"
    					className="form-input"
    					id="name"
    					value={name}
    					onChange={(event) => setName(event.target.value)}
    				/>
    			</div>
    			<div className="form-row">
    				<label htmlFor="email" className="form-label">
    					email
    				</label>
    				<input
    					type="text"
    					className="form-input"
    					id="email"
    					value={email}
    					onChange={(event) => setEmail(event.target.value)}
    				/>
    			</div>
    			<button type="submit" className="btn btn-block">
    				login
    			</button>
    		</form>
    	</section>
    );

};
</code>

Ora importiamo useNavigate:
import { useNavigate } from "react-router-dom";

Impostiamo una costante navigate ottenuta dall'Hook useNavigate e modifichiamo la funzione handleSubmit:

<code>

const navigate = useNavigate();

    async function handleSubmit(event) {
    	event.preventDefault();

    	if (!name || !email) {
    		return;
    	} else {
    		setUser({ name: name, email: email });
    		navigate("/dashboard");
    	}
    }

</code>

Qui avremo una condizione dove se manca uno dei due parametri, vi sarà un semplice return, altrimenti vengono impostati name e email, e viene chiamato navigate che ci porterà in modo programmatico alla Dashboard.

Così facendo verremo reindirizzati alla Dashboard. Qui modifichiamo il codice per visualizzare il name dello user che ha appena effettuato il login. Coglieremo la prop user mandata da App.js, la useremo su un h4 con un optional chaining:

<code>

    const Dashboard = ({ user }) => {
    	return (
    		<section className="section">
    			<h4>Hello, {user?.name}</h4>
    		</section>
    	);
    };

</code>

## 13. Protected Route

Vediamo ora come restringere l'accesso a certe Route.
Per prima cosa creeremo il Component ProtectedRoute, poi una volta importato useremo questo Component per avvolgere il Component verso il quale restringere l'accesso, nel nostro caso Dashboard.
Il wrap del Component Dashboard avverrà all'interno della property element della Route.

Partiamo quindi dal semplice:

<code>

    const ProtectedRoute = () => {
    	return <div>ProtectedRoute</div>;
    };

    export default ProtectedRoute;

</code>

Importiamo in App.js e usiamolo:

<code>

    				<Route
    					path="dashboard"
    					element={
    						<ProtectedRoute user={user}>
    							<Dashboard user={user} />
    						</ProtectedRoute>
    					}
    				/>

</code>

Passiamo la prop user per controllarla e poi se user esiste, solo allora mostreremo la Dashboard.

Ora se andiamo all'URL "/dashboard" visualizzaremo ProtectedRoute al suo posto.
Ora imposteremo le corrette funzionalità in ProtectedRoute.js:

<code>

    import { Navigate } from "react-router-dom";

    const ProtectedRoute = ({ children, user }) => {
    if (!user) {
    	return <Navigate to="/" />;
    }
    	return children;
    };

</code>

In questo codice vogliamo accedere a due cose. Per prima children, che sarà la pagina Dashboard o qualunque altra pagina che vogliamo proteggere. E per seconda user.
Se questo non esiste usiamo il Component Navigate con property "to" indirizzata a dove vogliamo reindirizzare l'utente.
Se esiste restituiamo il children, la nostra Dashboard.

Se proviamo ad accedere ora a Dashboard direttamente tramite URL, verremo reindirizzati alla Home.
Solo accedendo alla pagina di login ed inserendo i dati verremo reindirizzati alla Dashboard (possibile da if...else in Login.js).

Ricordarsi sempre di avvolgere la Page alla quale si vuole restringere l'accesso, come in questo caso con Protected Route.

## 14. Refactor

Qui renderemo SingleProduct un nested Component.
Creaimo per prima cosa uno Shared Layout, SharedProductLayout.
Importiamo anche il nuovo layout in App.js:

<code>
const Home = () => {
	return (
		<>
			<h2>products</h2>
			<Outlet />
		</>
	);
};
</code>

Rimuoviamo quindi l'h2 dal Component Product ed impostiamo tutto il necessario, la nuova Route con path products ed element il nuovo layout, modifichiamo la Route di Products e SingleProduct.

<code>
return (
		<BrowserRouter>
			<Routes>
				<Route path="/" element={<SharedLayout />}>
					<Route index element={<Home />} />
					<Route path="about" element={<About />} />
					<Route path="products" element={<SharedProductLayout />}>
						<Route index element={<Products />} />
						<Route path=":productId" element={<SingleProduct />} />
					</Route>
					<Route path="login" element={<Login setUser={setUser} />} />
					<Route
						path="dashboard"
						element={
							<ProtectedRoute user={user}>
								<Dashboard user={user} />
							</ProtectedRoute>
						}
					/>
					<Route path="*" element={<Error />} />
				</Route>
			</Routes>
		</BrowserRouter>
	);
</code>

E questo é quanto.
FINE TERZA PARTE - ADVANCED - REACT ROUTERS V6

# Quarta parte - Code 15 React.js Projects

## 1. Intro

Presentazione corso.

## 2. Starter Project Setup

Organizzazione base delle cartelle per il tutorial.

## 3. First Project - Birthday Intro

Il progetto darà creare una lista di birthdays.
Si parte avendo i Components App e List basici.

Modifichiamo il setup di base con:

<code>

    function App() {
    	return (
    		<main>
    			<section className="container">
    				<h3>0 birthdays today</h3>
    				<List />
    				<button onClick={() => console.log("clicked me")}>clear all</button>
    			</section>
    		</main>
    	);
    }

</code>

Dichiariamo la nostra State variable "people" con:

<code>
	const [people, setPeople] = useState(data);
</code>

Passiamo la nuova State variable agli elements:

<code>

    	<h3>{people.length} birthdays today</h3>
    	<List people={people} />

</code>

Ci spostiamo nel Component List dove gestiremo la prop people destrutturandola:

<code>

    const List = ({ people }) => {
    	return (
    		<>
    			{people.map((person) => {
    				const { id, name, age, image } = person;
    				return (
    					<article key={id} className="person">
    						<img src={image} alt={name} />
    						<div>
    							<h4>{name}</h4>
    							<p>{age} years</p>
    						</div>
    					</article>
    				);
    			})}
    		</>
    	);
    };

</code>

Aggiungiamo ora la funzionalità per il button per poter pulire la lista:

<code>

    <button onClick={() => setPeople([])}>clear all</button>

</code>

## 3. Second Project - Tours Intro

Descrizione secondo progetto: lista di tour disponibili, con possibilità di eliminare il singolo tour dalla lista e quando vuota eseguire un refresh con schermata di loading durante il fetch dei dati.

Impostiamo i vari components con un setup di base.

## 4. Second Project - Tours Fetch Data

Modifichiamo ora App.js per eseguire il fetch dei dati usando useEffect e una funzione asincrona:

<code>
function App() {
	const [loading, setLoading] = useState(true);
	const [tours, setTours] = useState([]);

    async function fetchTours() {
    	setLoading(true);
    	const response = await fetch(url);
    	const tours = await response.json();
    	console.log(tours);
    }
    useEffect(() => {
    	fetchTours();
    }, []);

    if (loading) {
    	return (
    		<main>
    			<Loading />
    		</main>
    	);
    }
    return (
    	<main>
    		<Tours />
    	</main>
    );

}
</code>

Gestiamo gli eventuali errors in fetchTours con una struttura try...catch:

<code>
async function fetchTours() {
		setLoading(true);
		try {
			const response = await fetch(url);
			const tours = await response.json();
			setLoading(false);
			setTours(tours);
		} catch (error) {
			setLoading(false);
			console.log(error);
		}
	}
</code>

## 4. Second Project - Tours Display Data

In App.js passiamo una prop tours con value dello State al Component Tours:

<code>

    return (
    		<main>
    			<Tours tours={tours} />
    		</main>
    	);

</code>

E nel Component Tours gestiamo la prop e visualizziamo i dati:

<code>
const Tours = ({ tours }) => {
	return (
		<section>
			<div className="title">
				<h2>our tours</h2>
				<div className="underline"></div>
			</div>
			<div>
				{tours.map((tour) => {
					return <Tour key={tour.id} {...tour} />;
				})}
			</div>
		</section>
	);
};
</code>

Ora abbiamo 5 Components Tour come dalla lunghezza dei dati, gestiamo ora nel Component Tour la prop ({...tour}), usandola per visualizzare l'image e le info:

<code>
const Tour = ({ id, image, info, price, name }) => {
	return (
		<article className="single-tour">
			<img src={image} alt={name} />
			<footer>
				<div className="tour-info">
					<h4>{name}</h4>
					<h4 className="tour-price">${price}</h4>
				</div>
				<p>{info}</p>
				<button className="delete-btn">not interested</button>
			</footer>
		</article>
	);
};
</code>

## 5. Second Project - Tours Toggle Button

Ora vogliamo implementare il paragraph in modo che vada a nascondere parte del text ed un button che mostri la parte delle info mancante, clickando "un read more".

Molto facilmente imposto una State value:
<code>
const [readMore, setReadMore] = useState(false);
</code>

Ed imposto il p come:

<code>

    <p>{readMore ? info : `${info.substring(0, 200)}...`}</p>

</code>

Ora impostiamo un button all'interno del "p" con un onClick event handler e tutte le funzionalità per variare il text del button e cambiare la value di readMore:

<code>

    <p>
    					{readMore ? info : `${info.substring(0, 200)}...`}
    					<button onClick={() => setReadMore(!readMore)}>
    						{readMore ? "Show Less" : "Read More"}
    					</button>
    </p>

</code>

## 6. Second Project - Tours Remove Tour

In questa sezione aggiungeremo la funzionalità di togliere un Tour clickando il button "not interested". Quando non avremo più items nella lista comparirà un altro button per il "refresh" che eseguirà il fetch un'altra volta oltre a quella iniziale.

E' normale pensare che la funzionalità debba risiedere in App.js visto che é li che abbiamo i nostri dati, ma comunque la useremo sul singolo Component Tour. Dobbiamo quindi figurarci come far passare una function per rimuovere un Tour fino al Component Tour stesso.

Prima la funzione per rimuovere il singolo Tour basato sull'id:

<code>

    function removeTour(id) {
    	const newTours = tours.filter((tour) => tour.id !== id);
    	setTours(newTours);
    }

</code>

Poi, anche se non é la soluzione migliore, passiamo questa funzione fino ai Components Tour passando per Tours:
<code>
<Tours tours={tours} removeTour={removeTour} />
</code>

Destrutturiamo le prop nel Component Tours:

<code>

    const Tours = ({ tours, removeTour }) => {
    	return (
    		<section>
    			<div className="title">
    				<h2>our tours</h2>
    				<div className="underline"></div>
    			</div>
    			<div>
    				{tours.map((tour) => {
    					return <Tour key={tour.id} removeTour={removeTour} {...tour} />;
    				})}
    			</div>
    		</section>
    	);
    };

</code>

Ed infine gestiamo la prop nel singolo Component Tour:

<code>
const Tour = ({ id, image, info, price, name, removeTour }) => {
	const [readMore, setReadMore] = useState(false);
	return (
		<article className="single-tour">
			<img src={image} alt={name} />
			<footer>
				<div className="tour-info">
					<h4>{name}</h4>
					<h4 className="tour-price">${price}</h4>
				</div>
				<p>
					{readMore ? info : `${info.substring(0, 200)}...`}
					<button onClick={() => setReadMore(!readMore)}>
						{readMore ? "Show Less" : "Read More"}
					</button>
				</p>
				<button className="delete-btn" onClick={() => removeTour(id)}>
					not interested
				</button>
			</footer>
		</article>
	);
};
</code>

Ora implementiamo il button per il refresh dei dati. Lo inseriremo come una nuova condizione in App.js, sotto all'if che controlla il Boolean loading:
<code>
if (loading) {
return (

<main>
<Loading />
</main>
);
}

    if (tours.length === 0) {
    	return (
    		<main>
    			<div className="title">
    				<h2>No tours left</h2>
    				<button onClick={fetchTours}>refresh</button>
    			</div>
    		</main>
    	);
    }

</code>

## 7. Third Project - Reviews Intro

In quest'app costruiremo un carousel di reviews, che sarà possibile far scorrere a destra o sinistra o farne apparire una random con l'apposito button.

## 7. Third Project - Reviews Info and React Icons

Impostiamo quindi il progetto basico, con App.js e Review.js.
Quest'ultimo dovrà usare delle icons e le scelte per poterle usare sono molteplici:
• si può usare per esempio la CDN in index.html
• usare react-icons installabile come npm package

Useremo la seconda opzione.
Per usare le icons occorre importarle singolarmente con il name descritto nella documentation con il path corretto indicante il package e la library specifica.

Installiamo il package e usiamo una icon:

<code>

    function App() {
    	return (
    		<>
    			<h2>reviews project setup</h2>
    			<FaGithubSquare />
    		</>
    	);
    }

</code>

Per dare dello style all'icon possiamo considerare che di preciso come element sarà un svg quindi possiamo usare lo style generico in CSS oppure come scelta migliore usare una class.

## 8. Third Project - Reviews Setup

Creiamo il setup generale di App.js:
<code>

    function App() {
    	return (
    		<main>
    			<section className="container">
    				<div className="title">
    					<h2>our reviews</h2>
    					<div className="underline"></div>
    				</div>
    				<Review />
    			</section>
    		</main>
    	);
    }

</code>

## 9. Third Project - Reviews Prev and Next Person

E poi passiamo a creare le funzionalità del Component Review.
Importiamo i nostri dati con "people" e le icons necessarie da react-icons/fa.
Per far apparire il primo element nell'array all'avvio dell'app sfrutteremo uno State index inizializzato a 0, con un destructuring nelle varie property basato su people con index che usa la State value index:

<code>
const [index, setIndex] = useState(0);
const [name, job, image, text] = people[index];
</code>

Quando la value di index cambierà avverrà un nuovo render e i dati destrutturati proverranno dallo user nella list con index corrente.

Quindi il Component Review si mostrerà come:

<code>
const Review = () => {
	const [index, setIndex] = useState(0);
	const { name, job, image, text } = people[index];
	console.log(name);
	return (
		<article className="review">
			<div className="img-container">
				<img src={image} alt={name} className="person-img" />
				<span className="quote-icon">
					<FaQuoteRight />
				</span>
			</div>
			<h4 className="author">{name}</h4>
			<p className="job">{job}</p>
			<p className="info">{info}</p>
			<div className="button-container">
				<button className="prev-btn">
					<FaChevronLeft />
				</button>
				<button className="next-btn">
					<FaChevronRight />
				</button>
				<button className="random-btn">surprise me</button>
			</div>
		</article>
	);
};
</code>

Per le due funzioni necessarie per aumentare o diminuire l'index possiamo usare due soluzioni:

• Scrivere direttamente le condizioni:

<code>
function nextPerson() {
		setIndex((prevIndex) => {
			let newIndex = prevIndex + 1;
			if (newIndex >= people.length - 1) {
				newIndex = people.length - 1;
			}
			return newIndex;
		});
	}
	function prevPerson() {
		setIndex((prevIndex) => {
			let newIndex = prevIndex - 1;
			if (newIndex <= 0) {
				newIndex = 0;
			}
			return newIndex;
		});
	}
</code>

Oppure scrivere una funzione a parte che verrà usata da entrambe le funzioni:

<code>
function checkNumber(number, arr) {
		if (number > arr.length - 1) {
			return 0;
		}
		if (number < 0) {
			return people.length - 1;
		}
		return number;
	}

    function nextPerson() {
    	setIndex((prevIndex) => {
    		let newIndex = prevIndex + 1;
    		return checkNumber(newIndex, people);
    	});
    }

    function prevPerson() {
    	setIndex((prevIndex) => {
    		let newIndex = prevIndex - 1;
    		return checkNumber(newIndex, people);
    	});
    }

</code>

La seconda alternativa é quella consigliata visto l'alto numero di chiamate.

## 10. Third Project - Reviews Random Person

Creiamo ora la funzionalità Random Person associata al relativo button.

<code>

    function randomPerson() {
    	let randomNumber = Math.floor(Math.random() * people.length);
    	if (randomNumber === index) {
    		randomNumber = index + 1;
    	}
    	setIndex(checkNumber(randomNumber, people));
    }

</code>

Che associeremo quindi ad un Event Handler onClick nel button "surprise me".
Si noti nella funzione l'uso di checkNumber per evitare di uscire dall'array come index.

## 11. Fourth Project - Accordition Intro

Questo progetto consiste in una semplice lista di domande la quale risposta può essere visualizzata o nascota (toggle). Cambierà anche l'icon, passando da + a - e viceversa.

## 12. Fourth Project - Accordition Complete

Impostiamo il setup di App.js e Question.js:

<code>

    function App() {
    	return (
    		<main>
    		</main>
    	);
    }

</code>

<code>

    import { AiOutlineMinus, AiOutlinePlus } from "react-icons/ai";

    const Question = () => {
    	return (
    	<>
    		<h2>Question</h2>
    	</>
    	);
    };

    export default Question;

</code>

Da notare anche l'import delle icons dopo aver installato il package npm.

Soluzione senza tutorial:

<code>
function App() {
	const [questions, setQuestions] = useState(data);
	return (
		<main>
			<div className="container">
				<h3>questions and answers about login</h3>
				<section className="info">
					{questions.map((question) => {
						return (
							<SingleQuestion
								key={question.id}
								title={question.title}
								info={question.info}
							/>
						);
					})}
				</section>
			</div>
		</main>
	);
}
</code>

<code>
const Question = ({ title, info }) => {
	const [showInfo, setShowInfo] = useState(false);

    function toggleText() {
    	setShowInfo((prevValue) => !prevValue);
    }
    return (
    	<article className="question">
    		<header>
    			<h4>{title}</h4>
    			<button className="btn" onClick={toggleText}>
    				{showInfo ? <AiOutlineMinus /> : <AiOutlinePlus />}
    			</button>
    		</header>
    		{showInfo && <p>{info}</p>}
    	</article>
    );

};
</code>

Soluzione tutorial:

<code>
function App() {
	const [questions, setQuestions] = useState(data);
	return (
		<main>
			<div className="container">
				<h3>questions and answers about login</h3>
				<section className="info">
					{questions.map((question) => {
						return <SingleQuestion key={question.id} {...question} />;
					})}
				</section>
			</div>
		</main>
	);
}
</code>

<code>
const Question = ({ title, info }) => {
	const [showInfo, setShowInfo] = useState(false);

    return (
    	<article className="question">
    		<header>
    			<h4>{title}</h4>
    			<button className="btn" onClick={() => setShowInfo(!showInfo)}>
    				{showInfo ? <AiOutlineMinus /> : <AiOutlinePlus />}
    			</button>
    		</header>
    		{showInfo && <p>{info}</p>}
    	</article>
    );

};

export default Question;
</code>

Quasi perfetto.

## 13. Fifth Project - Menu Intro

Questo progetto sarà composto da una lista con dei piatti da ordinare e saranno presenti dei buttons nella parte superiore per filtrare la lista in base ai pasti della giornata.
I buttons verrano aggiunti in modo dinamico, non saranno hard-coded.

## 14. Fifth Project - Menu Display Items

Impostiamo i Components come App.js, Menu.js e Categories.js.
Nei dati troveremo per ogni object la property "category" che useremo per la creazione dinamica dei buttons.

Comiciamo con la modifica ad App.js:
<code>

    function App() {
    const [menuItems, setMenuItems] = useState(items);
    const [categories, setCategories] = useState([]);

    		return (
    			<main>
    				<section className="menu-section">
    					<div className="title">
    						<h2>our menu</h2>
    						<div className="underline"></div>
    					</div>
    					<Categories />
    					<Menu items={menuItems} />
    				</section>
    			</main>
    		);

    }

</code>

Mandiamo così la prop "items" al Component Menu e quindi:

<code>
const Menu = ({ items }) => {
	return (
		<div className="section-center">
			{items.map((menuItem) => {
				const { id, title, img, desc, price } = menuItem;
				return (
					<article key={id} className="menu-item">
						<img
							src={imagesArray[items.indexOf(menuItem)]}
							alt={title}
							className="photo"
						/>
						<div className="item-info">
							<header>
								<h4>{title}</h4>
								<h4>{price}</h4>
							</header>
							<p className="item-text">{desc}</p>
						</div>
					</article>
				);
			})}
		</div>
	);
};
</code>

Ora proveremo prima un approccio manuale alla creazione dei Buttons per filtrare la lista e poi uno dinamico.

Creaimo una funzione filterItems che confronti una string il parametro category degli objects nell'Array dei dati. All'interno della funzione itererò tra tutti gli elements dell'Array originale, non la State value, ed userò setCategories per cambiare la lista di objects:

<code>

    function filterItems(category) {
    		const newItems = items.filter((item) => item.category === category);
    		setMenuItems(newItems);
    }

</code>

Nota: Come regola conviene sempre utilizzare la lista (array) originale per iterare e modificare la lista visualizzata.

Una volta creata la funzione la passiamo come prop al Component Categories.
Nel Component poi prendiamo la prop e la destrutturiamo come parametro del Component Categories.
Passeremo quindi all'aggiunta manuale dei Buttons. Per aggiungere ogni button occorrerebbe usare questo approccio per ogni categoria presente nei dati. Qui ne esamineremo uno solo per scopo didattico, quindi per la category "breakfast" avremo un Button con event handler onClick:

<code>

    const Categories = ({ filterItems }) => {
    	return (
    		<div className="btn-container">
    			<button className="filter-btn" onClick={() => filterItems("breakfast")}>
    				breakfast
    			</button>
    		</div>
    	);
    };

</code>

Vista chiaramente la modalità laboriosa e senza la possibilità di rivisualizzare tutti gli items, passiamo ad aggiungere tale funzionalità alla funzione filterItems:

<code>

    function filterItems(category) {
    		if (category === "all") {
    			setMenuItems(items);
    			return;
    		}
    		const newItems = items.filter((item) => item.category === category);
    		setMenuItems(newItems);
    	}

</code>

Aggiungiamo sempre a scopo dimostrativo il button all alla schermata:

<code>
const Categories = ({ filterItems }) => {
	return (
		<div className="btn-container">
			<button className="filter-btn" onClick={() => filterItems("all")}>
				all
			</button>
			<button className="filter-btn" onClick={() => filterItems("breakfast")}>
				breakfast
			</button>
		</div>
	);
};
</code>

Il problema con questo approccio é che non siamo sincronizzati con i dati: se dovessimo aggiungere altri articoli con nuove categorie dovremmo creare sempre nuovi buttons e modifiche al codice associate a questa modifica o aggiunta. Chiaramente questo non é un buon approccio.

## 15. Fifth Project - Menu Dynamic Approach

Per un approccio dinamico torniamo in App.js e filtriamo i dati originali per le categories, ma solo quelle uniche, senza doppie categorie con lo stesso name.

ATTENZIONE: utilizzo pratico Set.
Otteniamo quindi un Array con tutte le categorie che poi filtreremo tramire la struttura dati Set:
<code>

    const allCategories = [
    	"all",
    	...new Set(
    		items.map((item) => {
    			return item.category;
    		})
    	)
    ];

</code>

La struttura dai Set ha la particolarità di accettare solo value uniche (unique values).

Per trasformare tutte le categories in un unico array comprendendo anche la categoria "all", possiamo usare l'interessante struttura composta dallo spread operator "..." e dal Set appena creato:

<code>

    const allCategories = [
    	"all",
    	...new Set(
    		items.map((item) => {
    			return item.category;
    		})
    	)
    ];

</code>

Ora passeremo quest'Array ottenuto alla State value create in precedenza "categories".

<code>
	const [categories, setCategories] = useState(allCategories);
</code>

Questo State poi verrà passato come prop al Component Categories che aggiungeremo poi alla destrutturazione dei parametri nella dichiarazione del Component Categories. In questo Component inoltre itereremo tra le categorie per creare dei Buttons dinamicamente invece di utilizzare il metodo manuale realizzato prima, impostando quindi la funzionalità che colga la value di ogni categoria:

<code>

    const Categories = ({ categories, filterItems }) => {
    	return (
    		<div className="btn-container">
    			{categories.map((category, index) => {
    				return (
    					<button
    						type="button"
    						className="filter-btn"
    						key={index}
    						onClick={() => filterItems(category)}
    					>
    						{category}
    					</button>
    				);
    			})}
    		</div>
    	);
    };

</code>

Adesso siamo "in sync" con i nostri dati. Se questi venissero aggiornati e vi fossero delle nuove categories, queste verrebbero subito aggiunte come buttons selezionabili per filtrare gli items.

Test effettuato con successo, aggiunto nuovo item ai dati (id: 10) con nuova category.

## 16. Sixth Project - Tabs Intro

Descrizione progetto: varie tab laterali con visualizzazione testo al click sulla tab.
Il progetto userà fetch per ottenere i dati da usare.

## 17. Sixth Project - Tabs Setup

Impostiamo per prima cosa App.js:
<code>

    function App() {
    return <div>App.js</div>;
    }

</code>

Creiamo al suo interno tre State da utilizzare in seguito, loading, jobs e value.

Creaiamo quindi una funzione asincrona per il fetch dei dati, la quale una volta ottenuti li userà per impostare la value di jobs, prima inizializzata ad un Empty Array:

<code>
function App() {
	const [loading, setLoading] = useState(true);
	const [jobs, setJobs] = useState([]);
	const [value, setValue] = useState(0);

    async function fetchJobs() {
    	const response = await fetch(url);
    	const newJobs = await response.json();
    	setJobs(newJobs);
    	setLoading(false);
    }

    useEffect(() => {
    	fetchJobs();
    }, []);

    if (loading) {
    	return (
    		<section className="section loading">
    			<h2>...loading</h2>
    		</section>
    	);
    }

    return <div>Jobs</div>;

}
</code>

## 18. Sixth Project - Tabs Display First Job

Ora, dopo aver ottenuto la lista completa dei lavori dai dati con fetch, visualiziamo il primo oltre ad un Button per passare da una scheda all'altra.

Useremo quindi lo State "value". Avremo bisogno di destrutturare i dati dopo il conditional del loading, in modo da ottenere da questi le properties "company", "dates", "duties" e "title" provenienti dai dall'Array salvato in jobs con index uguale alla State value denominata "value".
Modifichiamo quindi il return del Component App per visualizzare tali dati.

<code>
return (
		<section className="section">
			<div className="title">
				<h2>experience</h2>
				<div className="underline"></div>
			</div>
			<div className="jobs-center">
				{/* btn container */}
				{/* job info */}
				<article className="job-info">
					<h3>{title}</h3>
					<h4>{company}</h4>
					<p className="job-date">{dates}</p>
					{duties.map((duty, index) => {
						return (
							<div key={index} className="job-desc">
								<FaAngleDoubleRight className="job-icon"></FaAngleDoubleRight>
								<p>{duty}</p>
							</div>
						);
					})}
				</article>
			</div>
		</section>
	);
</code>

## 19. Sixth Project - Tabs Buttons

Ora creeremo dei buttons per cambiare il lavoro visualizzato, andando a cambiare lo State "value".
La visualizzazione allora si mostrerà correttamente in quando andremo ad aggiungere una column in più per la visualizzazione di tipo grid.
Creeremo quindi un buttons container ed itereremo su jobs per ottenere i nostri buttons che una volta clickati andranno a modificare la State value "value".

<code>

    		<div className="btn-container">
    				{jobs.map((job, index) => {
    					return (
    						<button key={job.id} onClick={() => setValue(index)}>
    							{job.company}
    						</button>
    					);
    				})}
    		</div>

</code>

Per aggiungere la classe CSS "active-btn" al Button attivo o toglierla a quelli inattivi useremo un Template String per valutare se index é uguale alla State value denominata "value".
Se così fosse la classe verrà aggiunta altrimenti tolta:
<code>

    			<div className="btn-container">
    				{jobs.map((job, index) => {
    					return (
    						<button
    							key={job.id}
    							onClick={() => setValue(index)}
    							className={`job-btn ${index === value && "active-btn"}`}
    						>
    							{job.company}
    						</button>
    					);
    				})}
    			</div>

</code>

In questo modo possiamo aggiungere delle classes di style "on-the-fly".

## 20. Seventh Project - Slider Intro

Questo progetto é una semplice evoluzione di un carousel, uno Slider. Clickando a destra o sinistra passeremo alla Slide precedente o successiva.
Aggiungeremo anche la funzionalotà del passaggio delle Slide dopo un certo quantitativo di tempo.

## 21. Seventh Project - Slider Setup

Partiamo dal file data.js per ottenere i dati per le nostre Slides.
Installiamo ed importiamo le icons da usare nel progetto da react-icons.

Si concentrerà tutto in un singolo component App.js, in modo da poter districarsi anche tra components di dimensioni notevoli. Questo é motivato dal fatto che a volte non tutto é piccolo e facilmente gestibile o dividibile in piccoli components.

NOTA: Challange facoltativa. Finito il progetto, scegliere come dividere questo grande Component in Components separati.

Cominciamo impostando uno State per contenere l'Array di dati e uno per l'index, utile per indicizzare le Slides in modo da avere un ordine fisso sul quale basarsi.

Impostiamo quindi il resto del Component App.js:

<code>
function App() {
	const [people, setPeople] = useState(data);
	const [index, setIndex] = useState(0);

    useEffect(() => {}, []);
    return (
    	<section className="section">
    		<div className="title">
    			<h2>
    				<span>/</span>reviews
    			</h2>
    		</div>
    		<div className="section-center">
    			{people.map((person, personIndex) => {
    				const { id, image, name, title, quote } = person;
    				// more stuff coming up
    				return (
    					<article key={id}>
    						<img src={image} alt={name} className="person-img" />
    						<h4>{name}</h4>
    						<p className="title">{title}</p>
    						<p className="text">{quote}</p>
    						<FaQuoteRight className="icon" />
    					</article>
    				);
    			})}
    			<button className="prev">
    				<FiChevronLeft />
    			</button>
    			<button className="next">
    				<FiChevronRight />
    			</button>
    		</div>
    	</section>
    );

}
</code>

Questa impostazione é corretta per la gestione dei dati visualizzati, ma presenta la sovrapposizione di tutte le foto e il text dei vari paragraph, infatti avremmo i quattro elements article tutti presenti nello schermo controllando con la console.
Questo é dovuto al CSS e nella prossima sezione vedremo come sistemarlo manualmente, mentre in quelle successive come impostare il tutto in modo dinamico per non ottenere errori.

## 22. Seventh Project - Slider Manual Setup

La visualizzazione o meno di una slide dipende dall'overflow del CSS e dalla opacity fornita alla Slide. Le slide inattive verrano spostate fuori dal flow della pagina e la loro opacità abbassata al minimo. Per quella attiva invece sarà l'opposto e verrà posizionata al centro. Tutto questo sembra basarsi su classes CSS.

Come prima cosa per allineare tutte le Slides usiamo display:flex nel file CSS (già preimpostato).

Il problema del sovrapponimento delle Slides viene risolto eliminando le righe del position:absolute e delle misure, in questo modo gli elements si espanderanno.

Ora per muovere la Slide precedente a sinistra e quella successiva a destra dello schermo, sfruttiamo la property CSS "transform".
Riattiviamo le properties commentate poco fa ed aggiungendo la class nextSlide ad una Slide vedremo che traslerà verso destra. Esattamente l'effetto che volevamo.

Aggiungiamo la property overflow:hidden al container e la property opacity:0 per le Slides nascoste mentre quella active avrà sempre un opacity:1.

Nota: per usare il position:absolute occorre per forza avere una height dichiarata per il container.

Ora spostiamoci sul Component React App.js per impostare la variazione delle classes per creare la funzionalità che cambi le classes per un element quando avviene il cambio di Slide.

## 23. Seventh Project - Slider Manual Classes

Imposteremo all'interno del una variabile position con value "nextSlide" (attenzione al nome associato alla value, deve coincidere con il name della class).
Aggiungiamo un condizionale basato sullo State index che si raffronta con l'index attuale dell'element mappato personIndex. Se questi due corrispondono allora varieremo il nome della class in "activeSlide".

<code>

    {people.map((person, personIndex) => {
    					const { id, image, name, title, quote } = person;
    					// more stuff coming up
    					let position = "nextSlide";
    					if (personIndex === index) {
    						position = "activeSlide";
    					}
    					return (
    						<article className={position} key={id}>
    							<img src={image} alt={name} className="person-img" />
    							<h4>{name}</h4>
    							<p className="title">{title}</p>
    							<p className="text">{quote}</p>
    							<FaQuoteRight className="icon" />
    						</article>
    					);
    				})}

</code>

Per aggiungere la class "lastSlide" aggiungeremo un altro if che prenderà due condizioni, una che sarà personIndex === index - 1. Questa per cogliere la Slide precedente come index e (index === 0 && personIndex === people.length - 1) per i limiti della lista di Slides.

Ora passiamo ad impostare gli event handlers per i buttons per passare da una Slide ad un altra.

## 24. Seventh Project - Slider Prev And Next

Ora creeremo le funzionalità nei Buttons per modificare la value dello State denominato index.

<code>
<button
					className="prev"
					onClick={() => setIndex((prevIndex) => prevIndex - 1)}
				>
					<FiChevronLeft />
				</button>
				<button
					className="next"
					onClick={() => setIndex((prevIndex) => prevIndex + 1)}
				>
					<FiChevronRight />
				</button>
</code>

Così facendo vi saranno dei bug prima in testa ed in coda quando si tornerà indietro o si andrà avanti, che verranno sistemati usando useEffect. In ogni caso la funzionalità per muoversi da una Slide ad un'altra rimane valida.

L'Hook useEffect verrà impostato per controllare la value della State value index, quando sarà negativo verrà riportato a positivo e quando sarà più grande della lunghezza dell'Array verrà riportato a 0.

## 25. Seventh Project - Slider First And Last, Autoslide

Impostiamo quindi lo useEffect prima del return. Questo si attiverà in due casi, quando l'index cambia o quando l'Array people cambia.

<code>
function App() {
	const [people, setPeople] = useState(data);
	const [index, setIndex] = useState(0);

    useEffect(() => {
    	const lastIndex = people.length - 1;
    	if (index < 0) {
    		setIndex(lastIndex);
    	}
    	if (index > lastIndex) {
    		setIndex(0);
    	}
    }, [index, people.length]);
    return...

</code>

Impostiamo quindi un autoslide usando un altro useEffect. Questo avrà un setInterval che si attiverà ad ogni cambio dell'index:

<code>
useEffect(() => {
		setInterval(() => {
			setIndex((prevIndex) => prevIndex + 1);
		}, 3000);
	});
	return ...
</code>

Qui vi sarà una piccola problematica che ci farà capire perché é necessaria una Cleanup Function.

Quando si clicka uno dei button vi sarà un continuo riaggiornamento di index che causerà un restart dell'Effect continuo. Ciò che vogliamo fare sarà eseguire il Cleanup per la funzione precedente, in modo che questo non succeda.
Sfruttiamo la value che viene restituirta da setInterval per questo scopo.

<code>
useEffect(() => {
		let slider = setInterval(() => {
			setIndex((prevIndex) => prevIndex + 1);
		}, 3000);
		return () => clearInterval(slider);
	}, [index]);
</code>

Ora le Slides funzionano come previsto.

## 26. Eighth Project - Lorem-Ipsum Intro

Questo progetto consiste in un generatore di testo, il testo sarà il classico lorem-ipsum. Si potranno scegliere quanti paragrafi creare e in caso di scelta di un numero negativo o senza scelta di paragrafi si creerà un singolo paragrafo.

## 26. Eighth Project - Lorem-Ipsum Structure

Cominciamo creando nel Component App.js due State, count e text. Impostiamo poi gli elements nel return:

<code>

    function App() {
    	const [count, setCount] = useState(0);
    	const [text, setText] = useState([]);

    		return (
    			<section className="section-center">
    				<h3>tired of boring lorem ipsum?</h3>
    				<form className="lorem-form" onSubmit={handleSubmit}></form>
    			</section>
    		);
    }

</code>

Aggiungiamo poi la funzione handle submit ed i restanti elements nel return fino ad avere la struttura completa con dei paragraph hard coded:

<code>
return (
		<section className="section-center">
			<h3>tired of boring lorem ipsum?</h3>
			<form className="lorem-form" onSubmit={handleSubmit}>
				<label htmlFor="amount">paragraphs:</label>
				<input
					type="number"
					name="amount"
					id="amount"
					value={count}
					onChange={(event) => setCount(event.target.value)}
				/>
				<button type="submit" className="btn">
					generate
				</button>
			</form>
			<article className="lorem-text">
				<p>
					Jelly sweet roll jelly beans biscuit pie macaroon chocolate donut.
					Carrot cake caramels pie sweet apple pie tiramisu carrot cake.
					Marzipan marshmallow croissant tootsie roll lollipop. Cupcake lemon
					drops bear claw gummies.
				</p>
			</article>
		</section>
	);
</code>

Ciò che faremo sarà cambiare la value dello State Array text quando si eseguirà handleSubmit.

## 27. Eighth Project - Lorem-Ipsum Complete

Completiamo quindi la funzione handleSubmit andando ad usare setText.

<code>

    function handleSubmit(event) {
    		event.preventDefault();
    		setText(data);
    }

</code>

Andiamo poi a renderizzare il text proveniente dai dati nell'article:

<code>
<article className="lorem-text">
				{text.map((item, index) => {
					return <p key={index}>{item}</p>;
				})}
</article>
</code>

Per determinare quanti paragraphs visualizzare andremo a controllare la State value count nella funzione handleSubmit:

<code>
function handleSubmit(event) {
		event.preventDefault();
		console.log(count);
		setText(data);
}
</code>

Convertiamolo in type number, visto che per il momento é una string.
Per visualizzare il numero di paragraphs indicato useremo il metodo slice su data, all'interno della setter setText:

<code>
function handleSubmit(event) {
		event.preventDefault();
		let amount = parseInt(count);
		setText(data.slice(0, amount));
}
</code>

Per stabilire i limiti descritti ad inizio capitolo, cioé se il number selezionato fosse negativo, visualizzando un solo paragraph, o superiore a 8, il numero massimo di paragraphs contenuti nei dati, utilizzere dei semplici if:

<code>
if (count <= 0) {
			amount = 1;
		}
if (count > 8) {
			amount = 8;
}
</code>

## 28. Ninth Project - Color-Generetor Intro

Questo progetto é similare allo scorso come inserimento dei dati, solo che qui si passerà una String nell'input con value un codice esadecimale per un colore.
Una volta inserito questo si otterranno i dieci colori più chiari ed i dieci più scuri rispetto al colore inserito.

Aggiungeremo per ogni colore ottenuta la possibilità di copiare la value esadecimale di tale colore nella clipboard.

Se la value inserita nell'input non sarà corretta si otterrà un errore indicato da un border di colore rosso nell'input box.

## 29. Ninth Project - Color-Generetor Structure

Avremo un file utils.js che conterrà una funzione per convertire le values in rgb in hex.
Per ottenere i colori useremo una library esterna chiamata "values.js".
Nota: Osservare documentazione in seguito.

L'idea iniziale come detto é di un form dove inseriremo la value del color. Tale value sarà gestita da handleSubmit e poi se tutto é corretto otterremo una lista di values di colori.
Itereremo poi tra questa lista per mostrarne i colori ricavati da values.js.

Cominciamo aggiungendo uno State "color" inizializzato ad empty string.
Impostiamo un secondo State: questo servirà a gestire l'error, sarà il responsabile dell'indicazione d'errore nell'input.
Impostiamo un terzo State: questo conterrà la lista di colori che ricaveremo partendo da quello inserito nell'input, inizializzato ad empty array.

Come return avremo un fragment con all'interno due sections, una per il form e una per visualizzare i colori:

<code>
return (
		<>
			<section className="container">
				<h3>color generator</h3>
			</section>
			<section className="colors">
				<h4>list goes here</h4>
			</section>
		</>
	);
</code>

Inseriamo il form nel return con event handler onSubmit uguale alla funzione handleSubmit. Al suo interno poi avremo un input type text con value che si riferisce alla State value Color. Inseriamo inoltre un button per il submit:

<code>
return (
		<>
			<section className="container">
				<h3>color generator</h3>
				<form onSubmit={handleSubmit}>
					<input type="text" value={color} />
				</form>
			</section>
			<section className="colors">
				<h4>list goes here</h4>
			</section>
		</>
	);
</code>

## 30. Ninth Project - Color-Generetor Get Values, Error

Gestiamo ora l'inserimento della value che deve essere un color, se non lo fosse occorre che venga rimandato un errore, visualizzato con un border rosso nell'input. In handleSubmit cominciamo ad usare la library values.js dopo averla installata. Useremo vari metodi di questa library presenti nella documentazione:

<code>

    function handleSubmit(event) {
    		event.preventDefault();
    		let colors = new Values(color).all(10);
    		console.log(colors);
    	}

</code>

Qui otterremo un Array di 21 elements, contenenti i colori ottenuti con le varie sfumature, più chiare e più scure.

Qui sorge il problema quando inseriamo una value non valida o una value vuota, visto che la risposta sarà un error.
Per gestirlo inseriamo tutto in un try...catch dove il catch oltre a visualizzare l'errore imposterà la nostra State value "error" su true:

<code>
function handleSubmit(event) {
		event.preventDefault();
		try {
			let colors = new Values(color).all(10);
			console.log(colors);
		} catch (error) {
			setError(true);
			console.log(error);
		}
	}
</code>

Questo ci tornerà utile per la visualizzazione del border rosso nell'input box. Per ottenerla utilizzeremo un ternary nella property className dell'input:

<code>
<input
						type="text"
						value={color}
						onChange={(event) => setColor(event.target.value)}
						placeholder="#f15025"
						className={`${error ? "error" : null}`}
					/>
</code>

Di default la value di error sarà false, quindi l'element input non avrà una class associata e neanche il border rosso.

## 31. Ninth Project - Color-Generetor Single Color

Ora lavoreremo con la list ottenuta da new Values() all'interno della funzione handleSubmit:

<code>
function handleSubmit(event) {
		event.preventDefault();
		try {
			let colors = new Values(color).all(10);
			setList(colors);
		} catch (error) {
			setError(true);
			console.log(error);
		}
	}
</code>

Nella seconda section andremo quindi ad iterare sugli elements della State value "list", creando un Component SingleColor per ogni element della list:

<code>
<section className="colors">
				{list.map((colorItem, index) => {
					return <SingleColor key={index} {...colorItem} index={index} />;
				})}
</section>
</code>

Nel Component SingleColor andremo poi a gestire le varie props:

<code>
const SingleColor = ({rgb, weight, index}) => {
	return <h4>single color</h4>;
};

export default SingleColor;
</code>

Le prime due props, rgb e weight, provengono da ...colorItem in App.js. Otterremo un object con come elements un Array con la value RGB come array di tre elements, alpha type e weight.

Usando l'array imposteremo il background per ogni SingleColor component. Partiamo quindi dal creare una State value alert che ci mostrerà un'indicazione testuale nel momento nel quale andremo a clickare per copiare il colore nella clipboard. Imposteremo inoltre una variabile che ci restituirà la value come string per impostare il background-color.
Come return avremo un article che avrà come inline style il background color con value quella appena ottenuta in un teplate literal:

<code>
const SingleColor = ({ rgb, weight, index }) => {
	const [alert, setAlert] = useState(false);
	const bkg = rgb.join(",");
	console.log(bkg);
	return (
		<article className={`color`} style={{ backgroundColor: `rgb(${bkg})` }}>
			single color
		</article>
	);
};
</code>

Inseriremo poi due paragraphs, uno con il weight, per ogni SingleColor Component:

<code>
			<p className="percent-value">{weight}%</p>

</code>

---

NOTA: Soluzione non trovata dal creatore del tutorial.
Per ricavare la value di hex si può usare in App.js:
<code>
{list.map((colorItem, index) => {
let hex = new Values(`rgb(${colorItem.rgb.join(",")})`).hexString();
return (
<SingleColor key={index} {...colorItem} index={index} hex={hex} />
);
})}
</code>

Decostruendo poi la property hex nel Component SingleColor.

---

Per ottenere la value di hex da usare nel secondo paragraph utilizziamo il file util.js secondo il tutorial, importando la funzione rgbToHex dal file:

<code>
const SingleColor = ({ rgb, weight, index, hex }) => {
	const [alert, setAlert] = useState(false);
	const bkg = rgb.join(",");
	const detHex = rgbToHex(...rgb);
	return (
		<article className={`color`} style={{ backgroundColor: `rgb(${bkg})` }}>
			<p className="percent-value">{weight}%</p>
			{/* <p className="color-value">{hex}</p> */}
			<p className="color-value">{detHex}</p>
		</article>
	);
};

</code>

Ottenuta la value esadecimale del colore possiamo migliorare la visualizzazione del testo per ogni singolo colore in modo che quando questo va a scurirsi, il testo sia ancora visibile.
Per farlo utilizziamo la prop index nel Component SingleColor.
Nell'element article aggiungiamo quindi un condizionale nella property className in modo che se é più grande di 10 si aggiunga una seconda class:

<code>
return (
		<article
			className={`color ${index > 10 && "color-light"}`}
			style={{ backgroundColor: `rgb(${bkg})` }}
		>
			<p className="percent-value">{weight}%</p>
			{/* <p className="color-value">{hex}</p> */}
			<p className="color-value">{detHex}</p>
		</article>
	);
</code>

## 32. Ninth Project - Color-Generetor Copy To Clipboard

L'ultima funzionalità che vogliamo aggiungere consiste nel copiare nella clipboard il colore selezionato al click tra quelli presenti, dando una notifica di copia avvenuta che sparira in tre secondi.

Cominciamo con la notifica sfruttando la State value "alert":
<code>
{alert && <p className="alert">Copied to Clipboard</p>}
</code>

Imposteremo quindi un event handler onClick sull'intero article in modo che venga colto dall'intero riquadro.
Nell'onClick prima impostiamo il setAlert su true.
Per secondo copiamo i dati sulla Clipboard usando l'object Navigator.clipboard, il metodo writeText e passando come parametro ciò che vogliamo cogliere, in questo caso hex:

<code>
return (
		<article
			className={`color ${index > 10 && "color-light"}`}
			style={{ backgroundColor: `rgb(${bkg})` }}
			onClick={() => {
				setAlert(true);
				navigator.clipboard.writeText(hex);
			}}
		>
			<p className="percent-value">{weight}%</p>
			<p className="color-value">{hex}</p>
			{/* <p className="color-value">{detHex}</p> */}
			{alert && <p className="alert">Copied to Clipboard</p>}
		</article>
	);
</code>

Ora nasconderemo la notifica di copia dopo tre secondi. Per farlo imposteremo un useEffect che si baserà sulla variazione della State value alert, impostando un timeout dopo tre secondi, che dovrà avere una Cleanup function come return per disattivare un timeout prima di impostarne un altro:

<code>
useEffect(() => {
		const timeout = setTimeout(() => {
			setAlert(false);
		}, 3000);
		return () => clearTimeout(timeout);
	}, [alert]);
</code>

Per migliorare la visualizzazione iniziale dell'app torniamo su App.js ed impostiamo una value di default diversa per la State value "list":

<code>

    const [list, setList] = useState(new Values("#f15025")).all(10);

</code>

## 33. Tenth Project - Grocery-Bud Intro

Questo progetto sarà incentrato sulla creazione di una lista della spesa. Si partirà da un form per aggiungere i vari items, i quali potranno essere aggiunti, modificati o rimossi singolarmente o nella loro totalità.

Per avere una persistenza dei dati utilizzeremo il localStorage.

## 34. Tenth Project - Grocery-Bud Structure

Impostiamo prima di tutto la struttura su App.js dichiarando delle State values: name, list, isEditing, editID e alert. Alert nello specifico darà un object, che utilizzeremo con più proprietà visti i vari tipi di notifiche che utilizzaremo.

<code>

    function App() {
    	const [name, setName] = useState("");
    	const [list, setList] = useState([]);
    	const [isEditing, setIsEditing] = useState(false);
    	const [editID, seteditID] = useState(null);
    	const [alert, setAlert] = useState({ show: false, msg: "", type: "" });

    		function handleSubmit(event) {
    			event.preventDefault();
    			console.log("here");
    		}

    		return (
    			<section className="section-center">
    				<form className="grocery-form" onSubmit={handelSubmit}></form>
    				<div className="grocery-container">
    					<List />
    					<button className="clear-btn">clear</button>
    				</div>
    			</section>
    		);

    }

</code>

Ora imposteremo il nostro alert in modo conditional, all'interno dell'element form. Useremo alert.show per usare la property corretta dell'object alert, State value dichiarate precedentemente. Aggiungiamo inoltre tutti glia ltri elements necessari per inserire un nuovo item, come input, con un button per indicare l'edit o il submit di un item:

<code>
return (
		<section className="section-center">
			<form className="grocery-form" onSubmit={handleSubmit}>
				{alert.show && <Alert />}
				<h3>grocery bud</h3>
				<div className="form-control">
					<input
						type="text"
						className="grocery"
						placeholder=""
						enterKeyHint=".g. eggs"
						value={name}
						onChange={(event) => setName(event.target.value)}
					/>
					<button type="submit" className="submit-btn">
						{isEditing ? "edit" : "submit"}
					</button>
				</div>
			</form>
			<div className="grocery-container">
				<List />
				<button className="clear-btn">clear</button>
			</div>
		</section>
	);
</code>

## 35. Tenth Project - Grocery-Bud Add Items

Ora che la struttura é completa passiamo all'aggiunta della prima funzionalità: l'aggiunta di un item.

Modifichiamo quindi la funzione handleSubmit, per prima cosa controllando che la value all'interno dell'input al momento dell'event submit non sia vuota:

<code>
function handleSubmit(event) {
		event.preventDefault();
		if (!name) {
			// display alert
		} else if (name && isEditing) {
			// deal with edit
		} else {
			// show alert
			// create new item
		}
}
</code>

Questa struttura if...else if...else ci sarà la possibilità di impedire il submit di un item vuoto, modificare un item in caso di presenza del name ed State value isEditing true, e creare nuovi items.
Diverrà quindi:

<code>
function handleSubmit(event) {
		event.preventDefault();
		if (!name) {
			// display alert
		} else if (name && isEditing) {
			// deal with edit
		} else {
			// show alert
			const newItem = { id: new Date().getTime().toString(), title: name };
			setList([...list, newItem]);
			setName("");
		}
}
</code>

Qui nell'else creiamo un nuovo item con id unico e title uguale alla State value name, che viene impostato dall'event handler onChange nell'input. Impostiamo la State value list con la sua funzione setter in modo che includa tutti gli elements già presenti con ...list e il nuovo item. Reimpostiamo quindi il name ad una empty string.

Forniamo ora al Component List la prop items uguale alla State value list in modo da poter iterare tra gli items inseriti quando saremo nel Component List.

<code>
<div className="grocery-container">
				<List items={list} />
				<button className="clear-btn">clear</button>
			</div>
		</section>
	);
</code>

Nel Component List quindi:

<code>
const List = ({ items }) => {
	return (
		<div className="grocery-list">
			{items.map((item) => {
				const { id, title } = item;
				return (
					<article key={id} className="grocery-item">
						<p className="titke">{title}</p>
						<div className="btn-container">
							<button type="button" className="edit-btn">
								<FaEdit />
							</button>
							<button type="button" className="delete-btn">
								<FaTrash />
							</button>
						</div>
					</article>
				);
			})}
		</div>
	);
};
</code>

Ora che abbiamo provato la nostra list possiamo renderla visibile in modo condizionale in App.js, in modo che venga renderizzato il container solo se la quantità di items é maggiore di 0:

<code>
{list.length > 0 && (
				<div className="grocery-container">
					<List items={list} />
					<button className="clear-btn">clear items</button>
				</div>
)}
</code>

## 36. Tenth Project - Grocery-Bud Alert

Ora impostiamo in nostro Component Alert in modo che indichi correttamente l'azione di inserimento di un item.

Modifichiamo la State value alert temporaneamente come test. Queste properties verranno poi usate come prop per essere passate al Component Alert:

<code>

    const [alert, setAlert] = useState({
    		show: true,
    		msg: "hello world",
    		type: "success"
    });

    <form className="grocery-form" onSubmit={handleSubmit}>
    				{alert.show && <Alert {...alert} />}
    				<h3>grocery bud</h3>

</code>

Ora le coglieremo nel Component Alert destrutturandole:
<code>
const Alert = ({type, msg}) => {
return <h2>Alert component</h2>;
};
</code>

Utilizziamo solo type e msg visto che non necessitiamo di show.
Quindi usiamo la property msg per dare un testo al paragraph e sfruttiamo la property type per avere una class per lo style dinamica in base a questo:

<code>
const Alert = ({ type, msg }) => {
	return <p className={`alert alert-${type}`}>{msg}</p>;
};
</code>

Ora torniamo alle value di defaut nella dichiarazione della State value alert, e mostriamo quindi l'alert quando andiamo a provare ad inserire un'empty value nell'input. Agiamo quindi sul primo blocco if nella funzione handleSubmit:

<code>
function handleSubmit(event) {
		event.preventDefault();
		if (!name) {
			setAlert({ show: true, msg: "please enter value", type: "danger" });
		} else if (name && isEditing) {
			// deal with edit
		} else {
			// show alert
			const newItem = { id: new Date().getTime().toString(), title: name };
			setList([...list, newItem]);
			setName("");
		}
	}
</code>

Dovendo però chiamare più volte questo setAlert, conviene creare una funzione separata e chiamarla con i parametri adatti:

<code>
function showAlert(show = false, type = "", msg = "") {
		setAlert({ show, type, msg });
	}
</code>

Nota: possibile anche modifica di setAlert usando la callback e la prevValue.

Quindi in handleSubmit avremo:

<code>
function handleSubmit(event) {
		event.preventDefault();
		if (!name) {
			showAlert(true, "danger", "please enter value");
		} else if (name && isEditing) {
			// deal with edit
		} else {
			// show alert
			const newItem = { id: new Date().getTime().toString(), title: name };
			setList([...list, newItem]);
			setName("");
		}
	}
</code>

Passiamo la funzione come prop removeAlert al Component Alert, poi in Alert.js andiamo a destrutturla:

<code>
const Alert = ({ type, msg, removeAlert }) => {
	return <p className={`alert alert-${type}`}>{msg}</p>;
};
</code>

Qui useremo un Hook useEffect per far scomparire l'alert dopo tre secondi. Chiamando removeAlert senza parametri dichiarati, verranno usati quelli di dafault in showAlert, facendo quindi scomparire l'alert:

<code>
const Alert = ({ type, msg, removeAlert }) => {
	useEffect(() => {
		const timeout = setTimeout(() => {
			removeAlert();
		}, 3000);
		return () => clearTimeout(timeout);
	}, []);
	return <p className={`alert alert-${type}`}>{msg}</p>;
};
</code>

Importante non dimenticare la Cleanup function in caso di useEffect con setTimeout.

## 37. Tenth Project - Grocery-Bud Clear List

Ora integreremo la funzionalità per il clear totale della lista.
Per farlo creiamo una nuova funzione clearList.

<code>

    function clearList() {
    		showAlert(true, "danger", "empty list");
    		setList([]);
    }

</code>

Questa funzione si dovrà eseguire al click sul button clear items:

<code>
<div className="grocery-container">
					<List items={list} />
					<button className="clear-btn" onClick={clearList}>
						clear items
					</button>
</div>
</code>

## 38. Tenth Project - Grocery-Bud Remove Item

Implementiamo ora la funzionalità per rimuovere un singolo item. Per farlo dichiariamo una funzione removeItem che sfrutterà l'id dell'item.
Comiminciamo con usando la nostra funzione showAlert:

<code>
function removeItem(id) {
		showAlert(true, "danger", "item removed");
}
</code>

Poi usiamo la setter function setList per filtrare la lista in base all'id:

<code>
function removeItem(id) {
		showAlert(true, "danger", "item removed");
		setList((prevList) => {
			return prevList.filter((item) => item.id !== id);
	});	
}
</code>

Passiamo ora removeItem come prop al Component List:

<code>
{list.length > 0 && (
		<div className="grocery-container">
					<List items={list} removeItem={removeItem} />
					<button className="clear-btn" onClick={clearList}>
						clear items
					</button>
		</div>
)}
</code>

Poi nel Component List destrutturiamo la nuova prop e usiamola come event handler onClick sul delete button come inline function per poter usare l'id destrutturato dall'item proveniente dal .map:

<code>
const List = ({ items, removeItem }) => {
	return (
		<div className="grocery-list">
			{items.map((item) => {
				const { id, title } = item;
				return (
					<article key={id} className="grocery-item">
						<p className="titke">{title}</p>
						<div className="btn-container">
							<button type="button" className="edit-btn">
								<FaEdit />
							</button>
							<button
								type="button"
								className="delete-btn"
								onClick={() => removeItem(id)}
							>
								<FaTrash />
							</button>
						</div>
					</article>
				);
			})}
		</div>
	);
};
</code>

Per migliorare poi il nostro Component Alert passiamogli come prop anche la State value list, in modo da usarla per far si che l'Effect si attivi ad ogni sua modifica:

<code>

    <form className="grocery-form" onSubmit={handleSubmit}>
    				{alert.show && <Alert {...alert} removeAlert={showAlert} list={list} />}
    				<h3>grocery bud</h3>

</code>

<code>

    const Alert = ({ type, msg, removeAlert, list }) => {
    	useEffect(() => {
    		const timeout = setTimeout(() => {
    			removeAlert();
    		}, 3000);
    		return () => clearTimeout(timeout);
    	}, [list]);
    	return <p className={`alert alert-${type}`}>{msg}</p>;
    };

</code>

## 39. Tenth Project - Grocery-Bud Edit Item

Ora implementeremo la funzionalità più impegnativa, modificare un item.
Creiamo una nuova funzione editItem che si baserà sull'id dell'item per identificare quale item dalla lista modificare:

<code>
function editItem(id) {
		const specificItem = list.find((item) => item.id === id);
		setIsEditing(true);
		setEditID(id);
		setName(specificItem.title);
}
</code>

Passiamola quindi come prop al Component List:

<code>
					<List items={list} removeItem={removeItem} editItem={editItem} />
</code>

Ed in questo Component aggiungiamo editItem alla destrutturazione nel parametro object, e useremo tale parametro come callback inline nel event handler onClick nel button 'edit-button':

<code>
<div className="btn-container">
			<button
								type="button"
								className="edit-btn"
								onClick={() => editItem(id)}
							>
								<FaEdit />
			</button>
...
</code>

Ora andremo ad implementare la modifica al blocco if...else in handleSubmit. Qui imposteremo un conditional che sfrutterà il fatto che l'id corrisponde con la State value editID modificata al momento della chiamata di editItem per applicare la modifica apportata all'item corretto della list. Per modificarlo conserveremo tutte le properties dell'object tramire spread operator ... ma andremo a modificare title che corrisponderà all'attuale value di name impostato sempre in editItem:

<code>

    function handleSubmit(event) {
    		event.preventDefault();
    		if (!name) {
    			showAlert(true, "danger", "please enter value");
    		} else if (name && isEditing) {
    			setList(
    				list.map((item) => {
    					if (item.id === editID) {
    						return { ...item, title: name };
    					}
    					return item;
    				})
    			);
    		} else {
    			showAlert(true, "success", "item added to the list");
    			const newItem = { id: new Date().getTime().toString(), title: name };
    			setList([...list, newItem]);
    			setName("");
    		}
    }

</code>

Quindi completa con tutte le State value riportate a default e la chiamata a showAlert per la notifica della modifica:

<code>
function handleSubmit(event) {
		event.preventDefault();
		if (!name) {
			showAlert(true, "danger", "please enter value");
		} else if (name && isEditing) {
			setList(
				list.map((item) => {
					if (item.id === editID) {
						return { ...item, title: name };
					}
					return item;
				})
			);
			setName("");
			setEditID(null);
			setIsEditing(false);
			showAlert(true, "success", "value changed");
		} else {
			showAlert(true, "success", "item added to the list");
			const newItem = { id: new Date().getTime().toString(), title: name };
			setList([...list, newItem]);
			setName("");
		}
}
</code>

## 40. Tenth Project - Grocery-Bud Local Storage

Ora l'app funziona abbastanza bene, ma nel momento in cui viene ricaricata la pagina tutta la lista va persa, vista la mancanza di una persistenza dei dati. Useremo quindi un'API del browser, localStorage per sopperire a questo problema.

Useremo quindi l'Hook useEffect che si attiverà alla variazione di list. Useremo il metodo dell'object localStorage chiamato setItem, che prende una coppia key / value come entry ed entrambe devono essere Strings, quindi:

<code>
useEffect(() => {
		localStorage.setItem("list", JSON.stringify(list));
	}, [list]);
</code>

Fatto questo dobbiamo gestire questi dati quando dichiariamo la State value "list" al primo render dell'app. Creeremo quindi una funzione getLocalStorage, che salverà su una variabile la list proveniente dal localStorage. In un conditional poi, la list esiste verrà parserizzata e restituita per essere inserita nella State value "list", altrimenti verrà restituito un Array vuoto ed inserito quello:

<code>
function getLocalStorage() {
	let list = localStorage.getItem("list");
	if (list) {
		return JSON.parse(localStorage.getItem("list"));
	} else {
		return [];
	}
}

const [list, setList] = useState(getLocalStorage());

</code>

Così al refresh la lista rimarrà con tutte le aggiunte, modifiche o cancellazioni che opereremo.

## 41. Eleventh Project - Navbar Intro

Questo progetto consiste nella creazione di una Navbar sfruttando l'Hook useRef studiato in precedenza.

Questa Navbar verrà costruita in modo che se il display fosse un desktop allora i vari elements della Navbar, i link, saranno estesi nella pagina lungo la width, mentre se ci si trovasse in un dislay mobile questi elements verranno toggled (nascosti - alternati tra nascosti e visibili) fino al click sull'icon menu che li visualizzarà lungo l'height.

## 42. Eleventh Project - Navbar Structure

Creiamo una struttura con App.js e il Component Navbar.js. Inseriamo data.js con i nostri dati. Un'immagine di un logo.

Per prima cosa renderizziamo il Component Navbar in App.js.

Nel Component Navbar poi andiamo a cambiare il return:

<code>
const Navbar = () => {
	return (
		<nav>
			<div className="nav-center">
				<div className="nav-header"></div>
				<div className="links-container show-container"></div>
				<ul className="social-icons"></ul>
			</div>
		</nav>
	);
};
</code>

Passiamo quindi alla crezione dell'header inserendo il logo e il button che avrà un icon FaBars:

<code>
<div className="nav-header">
					<img src={logo} alt="logo" />
					<button className="nav-toggle">
						<FaBars />
					</button>
</div>
</code>

Modifichiamo ora il links container, quello che conterrà i vari link tra i quali navigare:

<code>
<div className="links-container show-container">
					<ul className="links">
						<li>
								<a href="#">Home</a>
						</li>
						...
					</ul>
</div>
</code>

Nota: l'uso degli anchor elements con href pari a # causerà degli errori. Da ciò che abbiamo imparato in React Routers v6 questi andranno sostituiti con i Link Elements.
Qui useremo di anchor elements a scopo dimostrativo.

Aggiungiamo un totale di quattro link nella unordered list.
Ora imposteremo le social media icons:

<code>
	<ul className="social-icons">
					<li>
						<a href="https.//www.facebook.com">
							<FaTwitter />
						</a>
					</li>
					<li>
						<a href="https.//www.facebook.com">
							<FaFacebook />
						</a>
					</li>
	</ul>
</code>

Questo approccio ha un problema ma che verrà affrontato in seguito nel tutorial.

Ora abbiamo la lista di link sempre visibile che al restringimento dello schermo verranno spostati e le social media icons spariranno.
Tutti i vari cambiamenti di Style o apparizzione delle icons sono effettuati tramite CSS.

Ora la struttura è pronta ed andremo ad implementare le varie features.

## 43. Eleventh Project - Navbar Links Data

Un approccio migliore per la Navbar é creare i vari link dai dati, senza usare gli elements della lista hard coded. Questo permetterà, in caso di cambiamenti anche del solo nome di un link, di ottenere l'immediata modifica anche nel render della pagina.
Questo approccio si rivela utile anche nel caso volessimo inserire gli stessi link della Navbar anche una sidebar in un'altra page o in un altro Component.

Partiamo quindi dai dati forniti in un array con all'interno degli objects dalla struttura:

<code>

    {
    	id: 1,
    	url: '/',
    	text: 'home'
    }

</code>

Il campo path qui fa riferimento al suo utilizzo in React Routers.

Utilizziamo quindi un approccio migliore iterando sull'Array di dati nella Navbar, come potrebbe essere in una Sidebar o in un Footer. Così facendo se vogliamo modificare qualcosa basterà agire solamente nei dati e i vari Components si aggiorneranno automaticamente.

Eliminiamo quindi i list items hard coded sfruttando l'import:

<code>

    import { links, social } from "../assets/db/data";

</code>

<code>

    <div className="links-container show-container">
    					<ul className="links">
    						{links.map((link) => {
    							const { id, url, text } = link;
    							return (
    								<li key={id}>
    									<a href={url}>{text}</a>
    								</li>
    							);
    						})}
    					</ul>
    </div>

</code>

Nota: qui dimostrazione anche con Sidebar.

Ora faremo lo stesso per le Social Media Icons:

<code>
<ul className="social-icons">
					{social.map((socialIcon) => {
						const { id, url, icon } = socialIcon;
						return (
							<li key={id}>
								<a href={url}>{icon}</a>
							</li>
						);
					})}
</ul>
</code>

## 44. Eleventh Project - Navbar Simple Toggle

Ora affronteremo il toggle dei link al click della menu icon come button.

Partiamo dal dichiarare una State value showLinks:

<code>

    const [showLinks, setShowLinks] = useState(false);

</code>

Nel Button già presense inseriamo un event handler onClick:

<code>

    <div className="nav-header">
    					<img src={logo} alt="logo" />
    					<button
    						className="nav-toggle"
    						onClick={() => setShowLinks(!showLinks)}
    					>
    						<FaBars />
    					</button>
    </div>

</code>

Ora per effettivamente creare un toggle effect, inseriamo il links container in un conditional basato sulla State value showLinks:

<code>

{showLinks && (

<div className="links-container show-container">
<ul className="links">
{links.map((link) => {
const { id, url, text } = link;
return (
<li key={id}>
<a href={url}>{text}</a>
</li>
);
})}
</ul>
</div>
)}
</code>

Questo approccio però non ci permette di aggiungere un'animazione smooth per esempio per l'apparizione o la sparizione del links, per questo ne adotteremo uno diverso.

## 45. Eleventh Project - Navbar Class Toggle

Rimuoviamo ora il conditional per fare spazio alla nuova soluzione.
Agiremo sull'aggiunta o la rimozione di una specifica class CSS.
Avremo come partenza la class .links-container che avrà una height di 0. Solo aggiungendo la class .show-container aggiungeremo una height di 10rem.
Quindi opereremo questo cambiamento dinamicamente e per farlo agiremo con una Template String nella property className del links-container basandoci la State value showLinks:

<code>
<div
					className={`${
						showLinks ? "links-container show-container" : "links-container"
					}`}
				>
					<ul className="links">
						{links.map((link) => {
							...
</code>

Il problema ora si sposta nel CSS. Non vi é un'aggiunta di una height dinamica ma semplicemente una value di 10rem hard coded. Quindi se per esempio il numero di values provenienti dai dati aumentasse, questa value rimarrà la stessa, non cambierà in base ai link presenti, nascondendone alcuni.

Quindi vogliamo che la height del container vari in base ai link contenuti in questo.

## 46. Eleventh Project - Navbar UseRef Approach

Torniamo ora alla semplce class links-container nel div.
Per risolvere il problema sopraindicato cominceremo ad usare useRef. Imposteremo due Hook useRef, uno per il container ed uno per i links:

<code>
const linksContainer = useRef(null);
const linksRef = useRef(null);
</code>

Nel container e nella unordered list:

<code>
<div className="links-container" ref={linksContainerRef}>
					<ul className="links" ref={linksRef}>
						{links.map((link) => {...
</code>

Quindi ora ogni volta che la value di showLinks cambia, voglio che venga eseguito un useEffect.
Nell'Effect quindi controlleremo l'height dei links e da questi andremo a aggiustare la height modificando il linksContainerRef. Per farlo useremo il metodo getBoundingClientRect su linksRef.current. Presa la height da questo metodo andremo ad impostare manualmente la height del container:

<code>
useEffect(() => {
		const linksHeight = linksRef.current.getBoundingClientRect().height;
		if (showLinks) {
			linksContainerRef.current.style.height = `${linksHeight}px`;
		} else {
			linksContainerRef.current.style.height = "0px";
		}
}, [showLinks]);
</code>

Qui possiamo osservare che usando useRef dobbiamo riferirci all'element corrente come variable.current per poter interagire con questo e modificarne lo style.
Fatto questo avremo la height del container calcolata in base alla height corrente dei links.

Nota: é importante utilizzare nella class links-container nel CSS, precisamente nelle media query per desktop, una height impostata su auto !important. Questo permette di avere una height dichiarata per le versioni desktop, altrimenti rimarrebbe 0 visto che i links si estendono nell'altro verso.

## 47. Twelfth Project - Sidebar & Modal Intro

Questo progetto mostrerà un uso pratico di useContext.
Creeremo una Sidebar ed un Modal.

## 48. Twelfth Project - Sidebar & Modal Structure

La struttura di base sarà:

In App.js

<code>

    function App() {
    	return (
    		<>
    			<Home />
    			<Modal />
    			<Sidebar />
    		</>
    	);
    }

</code>

In Home.js

<code>
const Home = () => {
	return (
		<main>
			<button className="sidebar-toggle">
				<FaBars />
			</button>
			<button className="btn">show modal</button>
		</main>
	);
};
</code>

In Modal.js:

<code>
const Modal = () => {
	return (
		<div className={`modal-overlay show-modal`}>
			<div className="modal-container">
				<h3>modal content</h3>
				<button className="close-modal-btn">
					<FaTimes />
				</button>
			</div>
		</div>
	);
};
</code>

Nella Sidebar poi:

<code>
const Sidebar = () => {
	return <aside className={`sidebar show-sidebar`}>sidebar</aside>;
};
</code>

Qui itereremo sui nostri dati, che sono molto similari a quelli della sezione precedente.

Nota: Qui nella Sidebar useremo un nuovo element mai usato, "aside".

Qui la class show-sidebar sarà responsabile per la visualizzazione o meno della Sidebar.
Inseriremo quindi un sidebar-header con un logo ed un button per chiudere la Sidebar:

<code>
const Sidebar = () => {
	return (
		<aside className={`sidebar show-sidebar`}>
			<div className="sidebar-header">
				<img src={logo} className="logo" alt="logo" />
				<button className="close-btn">
					<FaTimes />
				</button>
			</div>
		</aside>
	);
};
</code>

Aggiungeremo poi i link inseriti in una unordered list:

<code>
<aside className={`sidebar show-sidebar`}>
			<div className="sidebar-header">
				<img src={logo} className="logo" alt="logo" />
				<button className="close-btn">
					<FaTimes />
				</button>
			</div>
			<ul className="links">
				{links.map((link) => {
					const { id, url, text, icon } = link;
					return (
						<li key={id}>
							<a href={url}>
								{icon} {text}
							</a>
						</li>
					);
				})}
      </ul>
</code>

E faremo lo stesso per le Social Icons:

<code>
<ul className="social-icons">
				{social.map((link) => {
					const { id, url, icon } = link;
					return (
						<li key={id}>
							<a href={url}>{icon}</a>
						</li>
					);
				})}
			</ul>
</code>

Ora sfrutteremo la class show-sidebar in aggiunta a quella sidebar per il toggle, l'alternanza di visibile / nascosto.

Nella prossima sezione cominceremo la creazione della funzionalità che ci permetterà di mostrare o nascondere la Sidebar o il Modal al click di un button.

## 49. Twelfth Project - Sidebar & Modal Global Context

Una volta pronta la struttura é ora di pensare alla funzionalità di toggle della Sidebar e del Modal.

Potremmo usare delle State variables che al variare tra true e false, aggiungeranno o elimineranno la class adibita al toggle del Component.
Questo tuttavia non é possibile, occorre valutare il fatto che non possiamo aprire un Modal dal Modal stesso, perché il Button attualmente si trova nella Home.
Di conseguenza non posso impostare tale State Value nel Modal.

Tecnicamente si potrebbe creare un argument che imposteremo in App.js. Tramite funzioni dove inseriremo il toggle e passandole come props eccetera.
Il primo problema con questo approccio é che App.js rischierebbe di diventare gigantesco, il secondo é che sarebbe inevitabile il prop drilling.

Possiamo ovviare a questi problemi utilizzando context.js. Per utilizzarlo avvolgeremo tutta la nostra app nello stesso context.

In context.js quindi useremo il metodo di React createContext.
Questo prende due parametri, uno per il provider e uno per il consumer:

<code>

    const AppContext = React.createContext();

    const AppProvider = ({ children }) => {
    	return <AppContext.Provider value="hello">{children}</AppContext.Provider>;
    };

</code>

Creaiamo il Provider ponendo attenzione al passare i children come argument, altrimenti non vedremo nulla.

Ora da questo Component dobbiamo esportare sia l'AppContext, perché useContext andrà a cercarlo, ed inoltre esporteremo AppProvider.

Per farlo verranno illustrati due modi: uno usando useContext negli altri Components e uno impostando un Custom Hook che lo restituirà.

Cominciamo esportando:

<code>

    export {AppContext, AppProvider}

</code>

AppProvider dovrà poi essere importato in index.js, dove avvolgerà il Component App.js.

<code>
root.render(
	<React.StrictMode>
		<AppProvider>
			<App />
		</AppProvider>
	</React.StrictMode>
);
</code>

Ora in ogni Component all'interno di App.js, come Home o
Sidebar, sarà disponibile la value fornita ad
AppContext.Provider, in questo caso "hello".

Nel Component Home per esempio importiamo {AppContext} che verrà usato da useContext:

<code>
const Home = () => {
	const data = useContext(AppContext);
	console.log(data);
	return (
		<main>
			<button className="sidebar-toggle">
				<FaBars />
			</button>
			<button className="btn">show modal</button>
		</main>
	);
};
</code>

Non importa se il Component dove viene usato useContext con argument AppContext si trova indentato in 10 livelli di profondità, sarà sempre in grado di accedere alla value fornita come parametro ad AppContext.Provider.

Prima di proseguire con la risoluzione della problematica precendente, vediamo l'uso di un Custom Hook.

Immaginiamo lo scenario in cui non si possa o non si voglia importare useContext e AppContext in ogni Component. Piuttosto potremo importare un Custom Hook ed avere accesso allo stesso Context.

Nota: non cambierà il risultato solo l'implementazione per arrivarci.

Creeremo quindi il nostro Custom Hook all'interno di context.js, ricordando di cominciare il name con "use...", per rendere chiaro che si tratta di un Hook, e poi restituire useContext passando come argument AppContext:

<code>
export const useGlobalContext = () => {
	return useContext(AppContext);
};
</code>

Allora nel Component Home.js importeremo useGlobalContext e lo useremo al posto di useContext:

<code>
const data = useGlobalContext();
	console.log(data);
</code>

## 50. Twelfth Project - Sidebar & Modal Complete

Imposteremo ora la funzionalità di toggle partendo dall'AppProvider in context.js in modo da condividere più di una semplice value="hello".

Cominciamo dichiarando due State values in context.js, isSidebarOpen e isModalOpen entrambe inizializzate a false.

Dichiariamo quattro funzioni openSidebar, closeSidebar, openModal e closeModal. Tutte queste funzioni useranno le corrispettive setter functions per impostare da true a false e viceversa le State values.

Passiamo ora ad AppContext.Provider un object alla property value con all'interno le due State values e le quattro funzioni:

<code>
return (
		<AppContext.Provider
			value={{
				isSidebarOpen,
				isModalOpen,
				openSidebar,
				closeSidebar,
				openModal,
				closeModal
			}}
		>
			{children}
		</AppContext.Provider>
	);
};
</code>

Ora nel Component Home.js possiamo avvolgere le coppie di funzioni per aprire e chiudere la Sidebar e il Modal.
Iniziamo con l'apertura dei due:

<code>
const Home = () => {
	const { openSidebar, openModal } = useContext(AppContext);

    // const data = useGlobalContext();
    // console.log(data);
    return (
    	<main>
    		<button className="sidebar-toggle" onClick={openSidebar}>
    			<FaBars />
    		</button>
    		<button className="btn" onClick={openModal}>
    			show modal
    		</button>
    	</main>
    );

};
</code>

Ora per far si che la Sidebar e il Modal si aprano dobbiamo passare le relative State values provenienti da context.js ai relativi Components, usandoli per determinare la State value e per chiudere la Sidebar o il Modal:

In Sidebar.js:

<code>
import { useGlobalContext } from "../context";

const Sidebar = () => {
const { isSidebarOpen, closeSidebar } = useGlobalContext();
return (

<aside className={`${isSidebarOpen ? "sidebar show-sidebar" : "sidebar"}`}>
<div className="sidebar-header">
<img src={logo} className="logo" alt="logo" />
<button className="close-btn" onClick={closeSidebar}>
<FaTimes />
</button>
</div>
...
</code>

In Modal.js:

<code>

    const Modal = () => {
    	const { isModalOpen, closeModal } = useGlobalContext();
    	return (
    		<div
    			className={`${
    				isModalOpen ? "modal-overlay show-modal" : "modal-overlay"
    			} `}
    		>
    			<div className="modal-container">
    				<h3>modal content</h3>
    				<button className="close-modal-btn" onClick={closeModal}>
    					<FaTimes />
    				</button>
    			</div>
    		</div>
    	);
    };

</code>

Per impostare la view del Component ci baseremo sulle classes CSS, alternandole in base alla State value con un ternary operator all'interno di una Template String.

Nota: Questo Sezione appena finita risulterà molto importante

## 51. Thirteenth Project - Stripe Intro

Ora che abbiamo fatto pratica con useContext e sappiamo usarlo in modo globale possiamo avventurarci in un progetto più grande.

Imposteremo menu e submenu come nel sito di Stripe, con allungamento in orizzontale, e per schermi mobile in verticale, con diverse funzionalità annesse.

## 52. Thirteenth Project - Stripe Context Boilerplate

Creaiamo i vari Components dati, context.js e data.js.
Si noti che i dati e gli objects in essi sono più complessi rispetto ai precedenti:

<code>
{
		page: "products",
		links: [
			{ label: "payment", icon: <FaCreditCard />, url: "/products" },
			{ label: "terminal", icon: <FaCreditCard />, url: "/products" },
			{ label: "connect", icon: <FaCreditCard />, url: "/products" }
		]
}
</code>

Per prima cosa renderizziamo i Components in App.js e poi impostiamo il Global Context in context.js.
Creiamo l'AppContext e l'AppProvider, non dimenticando di passare il parametro children, e restituiamo da questo AppContext.Provider che avvolga i children per poter visualizzare i nostri Components.

Impostiamo la State variable isSidebarOpen e isModalOpen.
Creiamo le funzioni per open e close della Sidebar e del Modal.
Passiamo come property value un object con le funzioni e le State variables.

<code>
const AppProvider = ({ children }) => {
	const [isSidebarOpen, setIsSidebarOpen] = useState(true);
	const [isSubmenuOpen, setIsSubmenuOpen] = useState(true);

    function openSidebar() {
    	setIsSidebarOpen(true);
    }

    function closeSidebar() {
    	setIsSidebarOpen(false);
    }

    function openSubmenu() {
    	setIsSubmenuOpen(true);
    }

    function closeSubmenu() {
    	setIsSubmenuOpen(false);
    }

    return (
    	<AppContext.Provider
    		value={{
    			isSubmenuOpen,
    			isSidebarOpen,
    			openSubmenu,
    			closeSubmenu,
    			openSidebar,
    			closeSidebar
    		}}
    	>
    		{children}
    	</AppContext.Provider>
    );

};
</code>

Creiamo sempre in context.js quindi il nostro Custom Hook:
<code>
export const useGlobalContext = () => {
return useContext(AppContext);
};
</code>

Ora in index.js importiamo l'{AppProvider} e usiamolo per avvolgere il Component App:

<code>
import { AppProvider } from "./context";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
<React.StrictMode>
<AppProvider>
<App />
</AppProvider>
</React.StrictMode>
);
</code>

Proviamo ora in Hero.js se viene visualizzato l'object passato come property value ad AppContext.Provider:

<code>
import { useGlobalContext } from "../context";

const Hero = () => {
const data = useGlobalContext();
console.log(data);
return <h2>hero component</h2>;
};
</code>

Ora abbiamo disponibili i dati passati dal GlobalContext a tutti i Components.

## 53. Thirteenth Project - Stripe Navbar

La Navbar qui sarà trasparente, quindi per ottenere un effetto visivo aggiungeremo anche il Component Hero (in teoria creerà lo sfondo).

Lavoriamo quindi sulla Navbar, importiamo il context e dichiariamo tre funzioni provenienti dal quest'ultimo:

<code>
	const { openSidebar, openSubmenu, closeSubmenu } = useGlobalContext();
</code>

Restituiamo quindi un element nav con:

<code>
const Navbar = () => {
	const { openSidebar, openSubmenu, closeSubmenu } = useGlobalContext();
	return (
		<nav className="nav">
			<div className="nav-header">
				<ul className="nav-links"></ul>
			</div>
		</nav>
	);
};
</code>

Al momento non possiamo iterare sui links ed inserirli all'interno della unordered list, ma piuttosto inseriamo un element img per renderizzare il logo proveniente dall'import ed un button per il toggle, che al click richiamerà openSidebar proveniente dal context:

<code>
const Navbar = () => {
	const { openSidebar, openSubmenu, closeSubmenu } = useGlobalContext();
	return (
		<nav className="nav">
			<div className="nav-header">
				<img src={logo} className="nav-logo" alt="stripe_logo" />
				<button className="btn toggle-btn" onClick={openSidebar}>
					<FaBars />
				</button>
				<ul className="nav-links"></ul>
			</div>
		</nav>
	);
};
</code>

Inseriamo un element li con all'interno un button per testare la struttura che completeremo successivamente quando avremo accesso ai dati, oltre ad un button per il sing in senza funzionalità:

<code>
return (
		<nav className="nav-center">
			<div className="nav-header">
				<img src={logo} className="nav-logo" alt="stripe" />
				<button className="btn toggle-btn" onClick={openSidebar}>
					<FaBars />
				</button>
				<ul className="nav-links">
					<li>
						<button className="link-btn">products</button>
					</li>
					<li>
						<button className="link-btn">developers</button>
					</li>
					<li>
						<button className="link-btn">company</button>
					</li>
				</ul>
				<button className="btn signin-btn">Sign in</button>
			</div>
		</nav>
	);
</code>

Ora per poter avere un contrasto e vedere meglio la navbar creeremo la Hero section.

## 54. Thirteenth Project - Stripe Hero

Quindi creiamo il Component Hero, importiamo il context e ricaviamo dal GlobalContext la funzione closeSubmenu:

<code>
	const { closeSubmenu } = useGlobalContext();
</code>

Restituiremo quindi un element section, con tutti gli articles, il title della pagina, paragraphs e image:

<code>
const Hero = () => {
	const { closeSubmenu } = useGlobalContext();
	return (
		<section className="hero">
			<div className="hero-center">
				<article className="hero-info">
					<h1>Payments infrastructure for the internet</h1>
					<p>
						Millions of companies of all sizes—from startups to Fortune 500s—use
						Stripe’s software and APIs to accept payments, send payouts, and
						manage their businesses online.
					</p>
					<button className="btn">Start now</button>
				</article>
				<article className="hero-images">
					<img src={phoneImg} className="phone-img" />
				</article>
			</div>
		</section>
	);
};
</code>

Proseguiamo ora con la Sidebar.

## 55. Thirteenth Project - Stripe Sidebar

La Sidebar verrà visualizzata solo per gli schermi di dimensione ridotta, non per desktop (motivo non visualizzazione bars su desktop).

Questa Sidebar si aprirà quando verrà clickato un button qualsiasi della Navbar e avrà un close button.

Qui itereremo sui sublinks, e vi saranno multiple iterazioni.
Avremo bisogno anche del GlobalContext come per gli altri Components.
Dichiariamo isSidebarOpen e closeSidebar provenienti dal GlobalContext.
Restiuremo quindi un element aside, con className elaborata tramire Template String, sfruttando la value di isSidebarOpen per avere una o due classes abbinate all'element. La value di isSidebarOpen verrà fornita dal GlobalContext e riaggiornata alla variazione di value.
Inseriremo il close button con un event handler OnClick che richiamerà la funzione closeSidebar:

<code>
const Sidebar = () => {
	const { isSidebarOpen, closeSidebar } = useGlobalContext();
	return (
		<aside
			className={`${
				isSidebarOpen ? "sidebar-wrapper show" : "sidebar-wrapper"
			}`}
		>
			<div className="sidebar">
				<button className="close-btn" onClick={closeSidebar}>
					<FaTimes />
				</button>
			</div>
		</aside>
	);
};
</code>

Ora visualizzeremo i dati nella Sidebar, ma la cosa interessante é che effettueremo una doppia iterazione, questo perché i nostri dati sono annidati.
Creiamo quindi un div con className sidebar-links dove useremo un map su sublinks, importato da data.
Qui destruttureremo links e page, links per gli effettivi link e page per associare i vari link con le pages alle quali appartengono.
Aggiungeremom quindi un h4 al return insieme ad un div dove avverrà la seconda iterazione, che sarà sull'Array links appena destrutturato.
Qui useremo il singolo link e l'index al quale é associato.
Da link destrutturiamo le variabili url, icon e label.
Restituiamo quindi un anchor tag (Link element applicando React Router), con key pari ad index, href pari ad url e all'interno dell'anchor tag visualizzare icon e label del link:

<code>
return (
		<aside
			className={`${
				isSidebarOpen ? "sidebar-wrapper show" : "sidebar-wrapper"
			}`}
		>
			<div className="sidebar">
				<button className="close-btn" onClick={closeSidebar}>
					<FaTimes />
				</button>
				<div className="sidebar-links">
					{sublinks.map((item, index) => {
						const { links, page } = item;
						return (
							<article key={index}>
								<h4>{page}</h4>
								<div className="sidebar-sublinks">
									{links.map((link, index) => {
										const { url, icon, label } = link;
										return (
											<a key={index} href={url}>
												{icon}
												{label}
											</a>
										);
									})}
								</div>
							</article>
						);
					})}
				</div>
			</div>
		</aside>
	);
</code>

Ora cambiamo l'inizializzazione delle due State values in context.js per nascondere di default la Sidebar.

La Sidebar sarà il modo di navigare tra le pagine usato negli schermi di piccola dimensione come gli smartphone. Per fare ciò anche nella versione desktop andremo ad implementare il Submenu, che ci permetterà di creare un submenu per ogni over che avviene nei buttons presenti nella Navbar.

## 56. Thirteenth Project - Stripe Submenu

Qui implementeremo i Submenu per ogni button nel quale avverrà un event hover, ciò a cui dobbiamo prestare attenzione sarà che il Submenu corrisponda con la label del button che andremo a coprire.

Nel Component Submenu importeremo il context ed estrapoleremo da useGlobalContext {isSubmenuOpen}.
Restituiamo un element aside con className variabile in base alla value di isSubmenuOpen.

La nostra necessità ora é mostrare il Submenu solo al momento di un hovering, una sovrapposizione del mouse su uno dei button nella Navbar.
Spostiamoci quindi nel Component Navbar, dove creeremo una funzione che verrà eseguita dagli event listener onMouseOver nei buttons. Potremmo usare direttamente openSubmenu e closeSubmenu, ma visto che implementeremo anche altre funzionalità meglio creare una funzione apposita.

Nota: rispetto al codice d'esempio occorre aggiungere una property z-index agli elements per far funzionare il tutto, sia per il button con le bars, sia per i buttons per l'hover con apparizzione del Submenu.

Ora il Submenu appare all'hover ma non sconpare, per questo dobbiamo implementare un'altra funzionalità.

## 57. Thirteenth Project - Stripe Location

Occorre sistemare alcune cose nel Submenu che appare all'hover.
Per prima inserire i dati corretti per ogni button che si va a coprire, la seconda é la dimensione del Submenu, in base a quanti link contiene, la terza é la posizione (la Location) del Submenu in base al button a cui si passa sopra.

Al momento il nostro Submenu non é realmente dinamico a causa di queste mancanze.

La Location del Submenu dovrà risultare esattamente a metà del button. Per questo abbiamo creato una funzione, displaySubmenu, all'interno del Component Navbar e non ci siamo fermati alla semplice apertura e chiusura del Submenu.

Torniamo quindi a lavorare sulla funzione displaySubmenu ed otteniamo il target in base a dove avviene l'event. Usando questo e il suo textContent possiamo determinare la page dalla quale ricavare i dati.
Sempre grazie al target possiamo ottenere le misure e le coordinate di tale target con il metodo getBoundingClientRect.
Usando queste quindi determiniamo il center del button ed il bottom.
Per il bottom ci terremo 3px più in alto per un effetto visivo migliore:

<code>
function displaySubmenu(event) {
		const page = event.target.textContent;
		const tempBtn = event.target.getBoundingClientRect();
		const center = (tempBtn.left + tempBtn.right) / 2;
		const bottom = tempBtn.bottom - 3;
		openSubmenu();
	}
</code>

Passiamo quindi le measures ottenute ad openSubmenu come due parametri, il primo indicante la page, il secondo come object con le measures center e bottom calcolate.

<code>
function displaySubmenu(event) {
		const page = event.target.textContent;
		const tempBtn = event.target.getBoundingClientRect();
		const center = (tempBtn.left + tempBtn.right) / 2;
		const bottom = tempBtn.bottom - 3;
		openSubmenu(page, { center, bottom });
}
</code>

Torniamo ora in context.js per utilizzare questi nuovi parametri passati modificando la funzione openSubmenu:

<code>
function openSubmenu(text, coordinates) {
		setIsSubmenuOpen(true);
	}
</code>

Utilizziamo una nuova State value in context.js per la location, inizializzata come empty object. Useremo poi la setter function di location per impostare questa State value con il parametro coordinates:

<code>
function openSubmenu(text, coordinates) {
		setLocation(coordinates);
		setIsSubmenuOpen(true);
	}
</code>

Useremo quindi location per impostare del CSS inline per modificare la location del Submenu che apparirà.
Dovremo quindi passare la State value location nell'object nella property value di AppContext.Provider e poi destrutturarlo nel Component Submenu:

<code>
const Submenu = () => {
	const { isSubmenuOpen, location } = useGlobalContext();
	return...
</code>

Nel Component Submenu imposterò quindi un useEffect che eseguirà un Effect ogni volta che location cambierà:

<code>
useEffect(() => {
		
}, [location])
</code>

Imposteremo un container con un useRef, con ref collegata all'element aside restituito dal Component:

<code>
const Submenu = () => {
	const { isSubmenuOpen, location } = useGlobalContext();
	const container = useRef(null);
	useEffect(() => {}, [location]);
	return (
		<aside
			className={`${isSubmenuOpen ? "submenu show" : "submenu"}`}
			ref={container}
		>
			submenu
		</aside>
	);
};
</code>

Sarà proprio grazie ad questa ref che andremo a cogliere una variabile all'interno dell'Effect, come container.current:

<code>
useEffect(() => {
		const submenu = container.current;
		
	}, [location]);
</code>

Otteniamo il center ed il bottom da location:

<code>
useEffect(() => {
		const submenu = container.current;
		const { center, bottom } = location;
	}, [location]);
</code>

Quindi impostiamo le coordinate del Submenu:

<code>
useEffect(() => {
		const submenu = container.current;
		const { center, bottom } = location;
		submenu.style.left = `${center}px`;
		submenu.style.top = `${bottom}px`;
	}, [location]);
</code>

In questo modo spostandosi tra un button e l'altro apparirà esattamente sotto ed al centro di tale button il Submenu.

Nota: il submenu non viene trascinato ma resta fisso perché le misure vengono ricalcolate solo al cambio del button, grazie alla funzione displaySubmenu, dove viene usata variabile tempBtn per il getBoundingClientRect. Questo si appoggia ad event.target e fin tanto che questo rimane invariato non si avrà un ricalcolo del getBoundingClientRect e quindi lo spostamento del Submenu:

<code>

    function displaySubmenu(event) {
    		const page = event.target.textContent;
    		const tempBtn = event.target.getBoundingClientRect();
    		const center = (tempBtn.left + tempBtn.right) / 2;
    		const bottom = tempBtn.bottom + 3;
    		openSubmenu(page, { center, bottom });
    }

</code>

## 58. Thirteenth Project - Stripe Submenu Links

Ora cambieremo i dati contenuti nel Submenu in base a quale button stiamo passando sopra (hover over).
Useremo il parametro "page" proveniente da openSubmenu per questo agendo sempre su context.js. Qui abbiamo già i dati importati presenti, dove all'interno dell'Array sublinks é presente la property page per un confronto rispetto all'
event.target.

Dichiariamo una State value in context.js denominata page ed inizializzata ad un object con due values, "page" come empty string e "links" come empty Array, questo per ricalcare la struttura dell'object proveniente dai dati:

<code>
	const [page, setPage] = useState({ page: "", links: [] });
</code>

All'interno della funzione openSubmenu quindi andiamo a dichiarare una variabile page, ottenuta dall'uso del metodo find all'interno dei dati, salvati come sublinks:

<code>
		const page = sublinks.find((link) => link.page === text);
</code>

Qui quando link.page dai dati corrisponde al parametro text fornito da dispaySubmenu nel Component Navbar, avremo la nostra page. Questo ci fornirà quindi i dati definitivi da renderizzare nel Submenu tramite setPage(page):

<code>

function openSubmenu(text, coordinates) {
const page = sublinks.find((link) => link.page === text);
setPage(page);
setLocation(coordinates);
setIsSubmenuOpen(true);
}

</code>

Modificata così la State value page la passiamo come parte dell'object nella property value di AppContext.Provider per averne accesso nel Component Submenu:

<code>
return (
		<AppContext.Provider
			value={{
				isSidebarOpen,
				openSidebar,
				closeSidebar,
				isSubmenuOpen,
				openSubmenu,
				closeSubmenu,
				location,
				page
			}}
		>
			{children}
		</AppContext.Provider>
	);
</code>

In Submenu destruttureremo page per ottenere le properties page e links provenienti dai dai dati:

<code>
const {
		isSubmenuOpen,
		location,
		page: { page, links }
	} = useGlobalContext();
</code>

Ora nell'element aside restituito itereremo su questi links ottenuti:

<code>
return (
		<aside
			className={`${isSubmenuOpen ? "submenu show" : "submenu"}`}
			ref={container}
		>
			<h4>{page}</h4>
			<div>...iteration...</div>
		</aside>
	);
</code>

Qui all'interno del div dove avverrà l'iterazione aggiungeremo dell'ulteriore logica per cambiare dinamicamente il numero di colonne mostrate in base alla quantità di link forniti da dati, visto che variano da una page ad un'altra.
Impostiamo la property className con un interpolation (Template String) e inizializziamola intanto a "submenu-center col-2". Iteriamo sui links estrapolando il singolo link e l'index, destrutturiamo da link le properties label, icon e url e restituiamo un anchor tag, sostituibile in React Routers con l'element Link, e diamo come key l'index, come href l'url e come content l'icon e la label separati:

<code>

    return (
    		<aside
    			className={`${isSubmenuOpen ? "submenu show" : "submenu"}`}
    			ref={container}
    		>
    			<h4>{page}</h4>
    			<div className={`${"submenu-center col-2"}`}>
    				{links.map((link, index) => {
    					const { label, icon, url } = link;
    					return (
    						<a key={index} href={url}>
    							{icon}
    							{label}
    						</a>
    					);
    				})}
    			</div>
    		</aside>
    	);

</code>

Ora impostiamo la dinamicità per la larghezza del Submenu in base al numero di columns riferite ai link.
Per farlo dichiariamo una State value "columns" con default col-2:

<code>
	const [columns, setColumns] = useState("col-2");
</code>

Inseriamo la State value nella property className del submenu:

<code>
<div className={`submenu-center ${columns}`}>
				{links.map((link, index) => {...
</code>

Impostiamo un valore di default all'interno dell'Effect per assicurarci di evitare bug:

<code>
	useEffect(() => {
		setColumns("col-2");
		const submenu = container.current;
		const { center, bottom } = location;
		submenu.style.left = `${center}px`;
		submenu.style.top = `${bottom}px`;
	}, [location]);
</code>

E alla fine dell'Effect impostiamo un blocco conditional che imposti un inline style in base alla length di links, oltre che aggiungere nel dependency array dell'Effect il parametro links, per far rieseguire l'Effect in caso di variazione dei links:

<code>
useEffect(() => {
		setColumns("col-2");
		const submenu = container.current;
		const { center, bottom } = location;
		submenu.style.left = `${center}px`;
		submenu.style.top = `${bottom}px`;
		if (links.length === 3) {
			setColumns("col-3");
		}
		if (links.length > 3) {
			setColumns("col-4");
		}
	}, [location, links]);
</code>

Ora resta solamente da aggiungere la funzionalità che ci permetta di nascondere il Submenu quando non vi é più l'Over sul button.

## 59. Thirteenth Project - Stripe Hide Submenu

Vogliamo ora quindi nascondere il Submenu in due casi: quando andiamo a passare sulla sezione Hero e quando andiamo a passare sulla Navbar ma non sui buttons.

Cominciamo con il Component Hero, dove é già presente l'import del context e della funzione closeSubmenu. Aggiungiamo quindi alla section restituita un event listener per l'event onMouseOver:

<code>
<section className="hero" onMouseOver={closeSubmenu}>
			<div className="hero-center">...
</code>

Passiamo ora al Component Navbar che sarà un po' più complesso in quanto dovremo sfruttare l'event.target.
Abbiamo già importato anche qui la function closeSubmenu, inseriamo quindi un onMouseOver event listener con value pari alla funzione handleSubmenu che andremo a creare.
Creiamo un conditional che rilevi la class associata al target e se questa é diversa da link-btn, la class dei vari buttons, allora il Submenu verrà nascosto:

<code>

    function handleSubmenu(event) {
    	if (!event.target.classList.contains("link-btn")) {
    		closeSubmenu();
    	}
    }

</code>

## 60. Fourteenth Project - Cart Intro

Partiamo dal codice dato. In quest'App partiamo da dei dati hard coded a quelli ottenuti tramite fetch ed aggiungeremo anche una fase di loading con relativa schermata, basata su quanto passato dal context.

## 61. Fourteenth Project - Cart Setup Overview

Spiegazione di tutti i Components dell'App.

## 62. Fourteenth Project - Cart UseReducer Setup

Passaremo ora ad impostare le funzionalità di useReducer.
In context.js eseguiamo il refactor dello State cambiandolo invece in useReducer. Questo prende due parametri, una reducer function, che creeremo nel file reducer.js, ed uno State iniziale.
Cambieremo anche il nome della value da cart a "state" e della setter function da setCart a "dispatch". Quindi:

<code>
	const [state, dispatch] = useReducer(reducer, initialState);
</code>

initialState sarà un object che dichiariamo all'esterno del Component, con i vari stati modificabili, dove al momento nella property cart useremo la value hard coded cartItems, che sarà modificata in futuro per accogliere i dati ottenuti dal fetch:

<code>
const initialState = {
	loading: false,
	cart: cartItems,
	total: 0,
	amount: 0
};
</code>

Creaiamo il reducer nel relativo file:

<code>
import React from "react";

const reducer = (state, action) => {
return state;
};

export default reducer;

</code>

Importiamolo quindi in context.js e usiamolo con useReducer:

<code>
	const [state, dispatch] = useReducer(reducer, initialState);
</code>

Modifichiamo quindi in AppContext.Provider la prop value con all'interno l'object con State value cart, in modo da usare ora "state":

<code>
		<AppContext.Provider value={{ ...state }}>{children}</AppContext.Provider>
</code>

Modifichiamo ora i vari components che utilizzano le properties in initialState, partendo dalla Navbar, dove viene usata "amount". Passiamo quindi dalla hard coded value 3 all'uso di amount dopo averlo importato dal Custom Hook useGlobalContext():

<code>

    const Navbar = () => {
    	const { amount } = useGlobalContext();
    	return (
    		<nav>
    			<div className="nav-center">
    				<h3>useReducer</h3>
    				<div className="nav-container">
    					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
    						<path d="M16 6v2h2l2 12H0L2 8h2V6a6 6 0 1 1 12 0zm-2 0a4 4 0 1 0-8 0v2h8V6zM4 10v2h2v-2H4zm10 0v2h2v-2h-2z" />
    					</svg>
    					<div className="amount-container">
    						<p className="total-amount">{amount}</p>
    					</div>
    				</div>
    			</div>
    		</nav>
    	);
    };

</code>

Passiamo ora al Component App, dove si verificherà lo state loading per la visualizzazione di una pagina di caricamento (aggiungiamo un svg con animazione da quanto appreso su framer-motion):

<code>
function App() {
	const { loading } = useGlobalContext();
	if (loading) {
		return (
			<div className="loading">
				<h1>Loading</h1>
				<motion.svg
					className="pizza-svg"
					xmlns="http://www.w3.org/2000/svg"
					viewBox="0 0 512 512"
					variants={svgVariants}
					initial="hidden"
					animate="visible"
				>
					<motion.path
						fill="none"
						d="M109.7 160H160c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32V64C0 46.3 14.3 32 32 32s32 14.3 32 32v51.2L81.6 97.6c87.5-87.5 229.3-87.5 316.8 0s87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3s-163.8-62.5-226.3 0L109.7 160z"
						variants={pathVariants}
					/>
				</motion.svg>
			</div>
		);
	}
	return (
		<main>
			<Navbar />
			<CartContainer />
		</main>
	);
}
</code>

Ora nel Component CartContainer andremo ad utilizzare oltre a "cart" anche "total":

<code>
	const { cart, total } = useGlobalContext();
	...
	<div className="cart-total">
					<h4>
						total <span>${total}</span>
					</h4>
				</div>
				<button
					className="btn clear-btn"
					onClick={() => {
						cycleAnimation();
						console.log("cleared cart");
					}}
				>
	...
</code>

Ora abbiamo impostato tutte le funzionalità iniziali di quest'App.

## 63. Fourteenth Project - Cart Clear Cart

Ora imposteremo nel context.js delle funzioni in modo da distribuire (dispatch) qualche action attraverso il Provider, andando poi ad agire sul determinato Component che cerca la determinata action, come ad esempio la rimozione di un item, l'aumento o la diminuzione di una quantità ecc. Gestiremo poi la cosa anche nel reducer.js.

I passi sono gli stessi precedenti, iniziamo dal più facile, cioé la rimozione totale degli items dal Cart.

Quindi in context.js dentro ad AppProvider dichiariamo la funzione clearCart che userà il metodo dispatch con come parametro un object:

<code>

    	function clearCart() {
    		dispatch({ type: "CLEAR_CART" });
    	}

</code>

Nota: la value della property type andrà in maiuscolo senza spazi per convenzione.

La funzione verrà poi passata all'interno dell'object della property value di AppContext.Provider nel return del Component AppProvider:

<code>
const AppProvider = ({ children }) => {
	const [state, dispatch] = useReducer(reducer, initialState);

    function clearCart() {
    	dispatch({ type: "CLEAR_CART" });
    }

    return (
    	<AppContext.Provider value={{ ...state, clearCart }}>
    		{children}
    	</AppContext.Provider>
    );

};
</code>

Questa funzionalità sarà richiesta nel Component CartContainer, quindi andiamo a gestirla:

<code>
	const { cart, total, clearCart } = useGlobalContext();
	...
	<button
					className="btn clear-btn"
					onClick={clearCart}
					
	...
</code>

Ora andiamo a gestire tale funzionalità nel reducer.js. Qui si agirà sullo state valutando l'action. Lo state sono le property dell'object initialState dichiarato in context.js, le action.type si basano su ciò che viene passato al metodo dispatch fornito da useReducer sempre in context.js:

<code>
const reducer = (state, action) => {
	if (action.type === "CLEAR_CART") {
		return {...state, cart: []}
	}
	return state;
};
</code>

in questo modo lo state verrà modificato solo nella property cart, cambiando la sua value in un empty Array e così facendo eliminarne gli items.

Nota: Si può optare anche per uno switch priuttosto che gli if statement.

Ora al click del button il cart verrà svuotato.

## 64. Fourteenth Project - Cart Remove Item

La prossima funzionalità che andremo ad implementare sarà la rimozione del singolo item dal cart.

Torniamo quindi a context.js e creiamo la funzione "remove", che dovrà prendere come parametro un id, per identificare quale item stiamo rimuovendo. Per usare questo id passeremo a dispatch, oltre alla property type, anche una property chiamata per convenzione "payload" con value corrispondente al parametro id:

<code>
function remove(id) {
		dispatch({ type: "REMOVE", payload: id });
}
</code>

Passeremo quindi questa funzione al return AppContext.Provider come per la funzione clearCart:

<code>
return (
		<AppContext.Provider value={{ ...state, clearCart, remove }}>
			{children}
		</AppContext.Provider>
	);
</code>

Passiamo quindi al Component CartItem, dove destruttureremo dal Custom Component useGlobalContext la funzione remove:

<code>
	const { remove } = useGlobalContext();
</code>

Nel button con className "remove-btn" andremo poi a impostare una inline function per permettere il passaggio del parametro id:

<code>
...
<button className="remove-btn" onClick={() => remove(id)}>
					remove
</button>
...
</code>

Andiamo quindi a gestire la funzione in reducer.js, dove imposteremo un if adatto al type "REMOVE" e che restituisca uno state uguale ma con property cart modificata, con value filtrata in base al fatto che l'id dell'item non sia differente dal parametro payload impostato in context.js pari all'id dell'item selezionato per la rimozione:

<code>
const reducer = (state, action) => {
	if (action.type === "CLEAR_CART") {
		return { ...state, cart: [] };
	}

    if (action.type === "REMOVE") {
    	return {
    		...state,
    		cart: state.cart.filter((cartItem) => cartItem.id !== action.payload)
    	};
    }
    return state;

};
</code>

Ora la funzionalità di rimozione del singolo item nel cart é completa.

## 65. Fourteenth Project - Cart Increase

Ora andremo ad aggiungere la funzionalità di aumento della quantità di un item nel cart.

Come per le altre funzionalità andiamo a creare una funzione increase in context.js e inoltre creiamo già una funzione identica per il decrease:

<code>
function increase(id) {
		dispatch({ type: "INCREASE", payload: id });
	}

    function decrease(id) {
    	dispatch({ type: "DECREASE", payload: id });
    }

</code>

Passiamo poi le funzione al return AppContext.Provider:

<code>
return (
		<AppContext.Provider value={{ ...state, clearCart, remove, increase, decrease }}>
			{children}
		</AppContext.Provider>
	);
</code>

Destrutturiamo poi tali funzioni nel Component CartItem.

<code>
	const { remove, increase, decrease } = useGlobalContext();
</code>

Inseriamo le funzioni perché vengano eseguite negli appositi button con una inline function per potervi passare l'id dell'item che utilizzerà tale funzionalità:

<code>
...
				<button className="amount-btn" onClick={() => increase(id)}>
...
				<button className="amount-btn" onClick={() => decrease(id)}>
...
</code>

Ora gestiamo queste due funzionalità nel reducer.js:

<code>
if (action.type === "INCREASE") {
		let tempCart = state.cart.map((cartItem) => {
			if (cartItem.id === action.payload) {
				return { ...cartItem, amount: cartItem.amount + 1 };
			}
			return cartItem;
		});
		return {
			...state,
			cart: tempCart
		};
	}
</code>

Qui andremo a creare un tempCart per mappare ogni item del cart, se l'id di un cartItem é uguale all'id proveniente dal payload restituirò tutte le properties dell'object cartItem uguali tranne amount (vedi initialState), che restituirò con una value maggiorata di uno.

La funzionalità DECREASE sarà molto similare, ma andremo ad aggiungere una funzionalità automatica di rimozione dell'item se la quantità arrivasse a zero.

## 66. Fourteenth Project - Cart Decrease

Completiamo quindi la funzionalità decrease nel reducer.js:

<code>
if (action.type === "DECREASE") {
		let tempCart = state.cart
			.map((cartItem) => {
				if (cartItem.id === action.payload && cartItem.amount > 0) {
					return { ...cartItem, amount: cartItem.amount - 1 };
				}
				return cartItem;
			})
			.filter((cartItem) => {
				return cartItem.amount !== 0;
			});
		return { ...state, cart: tempCart };
	}
</code>

Qui per rimuovere gli items arrivati a zero andiamo a concatenare un metodo filter, che controllerà se l'amount di una item é diverso da zero, quindi se questa quantità arrivasse a zero il suddetto item verrebbe filtrato, rimosso.

## 67. Fourteenth Project - Cart Get Totals

Ora andremo a creare la funzionalità che aggiornerà l'amount degli items, in modo che il numero sull'icona della bag in alto a destra venga aggiornato, ed il total per aggiornare il prezzo totale degli items.

A differenza delle altre funzionalità, non creeremo una funzione nell'AppProvider, ma piuttosto useremo un useEffect per aggiornare le properties ad ogni modifica nell'initialState, usando state, nello specifico nel cart.

Quindi in context.js creiamo un useEffect:

<code>
...
function decrease(id) {
		dispatch({ type: "DECREASE", payload: id });
	}

useEffect(() => {
console.log("hello");
}, [state.cart]);

...
</code>

Inseriamo qui la chiamata al dispatch invece che in una funzione separata, con type GET_TOTALS:

<code>
useEffect(() => {
		dispatch({type: "GET_TOTALS"})
	}, [state.cart]);
</code>

Chiaramente non occorrerà passare l'Effect in nessun modo all'AppContext.Provider.

Gestiamo ora la nuova funzionalità nel reducer.js.
Partiamo da:

 <code>
if (action.type === "GET_TOTALS") {
		const { total, amount } = state.cart.reduce((cartTotal, cartitem) => {}, {
			total: 0,
			amount: 0
		});

    	return { ...state, amount, total };
    }

 </code>

Useremo il metodo reduce, con cartTotal come accumulator e cartItem come value. Restituiremo un object con una property total e una amount, entrambe inizializzate a 0.

All'interno del reduce otterniamo le properties price e amount dai dati:
<code>
const { price, amount } = cartItem;
</code>

E poi andiamo a sommare l'amount al cartTotal.amount:
<code>
cartTotal.amount += amount;
</code>

Calcoliamo ora il prezzo totale, moltiplicando l'amount di un item per il suo price, sommando poi l'itemTotalPrice ottenuto con il cartTotal.total:

<code>
const itemTotalPrice = price * amount;
cartTotal.total += itemTotalPrice;
</code>

Per evitare valute con eccessivi numeri dopo la virgola per l'errore di calcolo intrinseco di JavaScript andiamo a modificare infine il total con un toFixed ed un parseFloat:

<code>
if (action.type === "GET_TOTALS") {
		let { total, amount } = state.cart.reduce(
			(cartTotal, cartItem) => {
				const { price, amount } = cartItem;
				const itemTotalPrice = price * amount;
				cartTotal.total += itemTotalPrice;
				cartTotal.amount += amount;
				return cartTotal;
			},
			{
				total: 0,
				amount: 0
			}
		);
		total = parseFloat(total.toFixed(2));

    	return { ...state, amount, total };
    }

</code>

## 68. Fourteenth Project - Cart Fetch Data

Ora tratteremo il fetch dei dati usando useReducer.

Per cominciare per il fetch dei dati effettivo utilizzeremo un altro useEffect e una volta ottenuti i dati dall'url andremo ad inserirli nello state.

Noteremo la differenza con i dati prepopolati perché otterremo quattro items nel cart invece di tre.

Per prima cosa andiamo a creare una funzione fetchData in comntext.js, dove avremo oltre al fetch dei dati anche due dispatch, uno per il loading e uno per il display items.
Nel secondo verrà passato come payload ciò che otteniamo dal fetch dei dati. Questa funzione verrà chiamata solo al momento del primo render dell'App, per questo useremo un useEffect:

<code>
async function fetchData() {
		dispatch({ type: "LOADING" });
		const response = await fetch(url);
		const cart = await response.json();
		dispatch({ type: "DISPLAY_ITEMS", payload: cart });
	}

    useEffect(() => {
    	fetchData();
    }, []);

</code>

Ora spostiamoci nel reducer e gestiamo il dispatch di loading e display items:

<code>
if (action.type === "LOADING") {
		return { ...state, loading: true };
	}
</code>

Per il type loading vogliamo semplicemente che durante il caricamento la property loading di state, perciò initialState, divenga true, in modo da visualizzare la schermata di caricamento.

Per il type display items invece andiamo a restituire ancora le stesse properties dello state ma impostando la property cart ad action.payload, cioé i dati ottenuti dal fetch secondo il dispatch nella funzione fetchData, impostando anche la property loading a false per terminare la visualizzazione della schermata di caricamento:

<code>
if (action.type === "DISPLAY_ITEMS") {
		return { ...state, cart: action.payload, loading: false };
	}
</code>

## 69. Fourteenth Project - Cart Toogle Functionality

Qui provvederemo a rifattorizzare il codice in modo da non avere codice ripetuto nel reducer.js. Per fare ciò dobbiamo partire dal context.js e creare una funzione che accolga sia la possibilità di un type increase che di un type decrease.

Per questo creeremo la funzione toggleAmount, che prenderà due parametri in entrata, l'id dell'item e il type della action da eseguire su tale item:

<code>
function toggleAmount(id, type) {
		dispatch({ type: "TOGGLE_AMOUNT", payload: { id, type } });
	}
</code>

Passiamo ora tale funzione nella property value del return AppContext.Provider:

<code>
return (
		<AppContext.Provider
			value={{ ...state, clearCart, remove, increase, decrease, toggleAmount }}
		>
			{children}
		</AppContext.Provider>
	);
</code>

Ora gestiamo tale funzionalità nel Component CartItem, dove per prima cosa destrutturiamo il parametro proveniente dal context.js toggleAmount:

<code>
	const { remove, increase, decrease, toggleAmount } = useGlobalContext();
</code>

Sostituiamo quindi la chiamata inline delle funzioni negli event handler onClick dei relativi buttons con la chiamata inline alla funzione toggleAmount:

<code>
<button className="amount-btn" onClick={() => toggleAmount(id, "inc")}>
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
						<path d="M10.707 7.05L10 6.343 4.343 12l1.414 1.414L10 9.172l4.243 4.242L15.657 12z" />
					</svg>
				</button>
				<p className="amount">{amount}</p>
<button className="amount-btn" onClick={() => toggleAmount(id, "dec")}>
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
						<path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" />
					</svg>
				</button>

</code>

A differenza delle funzioni precedenti a toggleAmount dobbiamo passare sia l'id dell'item sia un'indicazione string per indicare se si tratta di un aumento di quantità o una diminuzione, in questo caso "inc" e "dec".

Ora spostiamoci nel reducer.js e inseriamo un if conditional per la nuova action TOGGLE_AMOUNT, partendo da una semplice base appoggiandoci anche ad una variabile tempCart:

<code>
	if (action.type === "TOGGLE_AMOUNT") {
		let tempCart = [];
		return { ...state, cart: tempCart };
	}
</code>

Ora andiamo ad applicare un map alla variabile tempCart, andando a verificare il type indicato tramite String all'interno del payload dopo aver verificato che l'id corrisponda. Aggiungiamo inoltre un filter nel caso decrease in modo che se la quantità scendesse sotto a zero diminuendola, l'item venga rimosso:

<code>
if (action.type === "TOGGLE_AMOUNT") {
		let tempCart = state.cart
			.map((cartItem) => {
				if (cartItem.id === action.payload.id) {
					if (action.payload.type === "inc") {
						return { ...cartItem, amount: cartItem.amount + 1 };
					}
					if (action.payload.type === "dec") {
						return { ...cartItem, amount: cartItem.amount - 1 };
					}
				}
				return cartItem;
			})
			.filter((cartItem) => cartItem.amount !== 0);
		return { ...state, cart: tempCart };
	}
</code>

Andiamo a modificare inoltre l'ultimo return state dei condizionali if, in modo che, al posto dello state, venga restituito un Error con un messaggio per evidenziare che il type della action corrisponde:

<code>

...
}
throw new Error("no matching action type");
};

export default reducer;

</code>

Questo progetto si può considerare completo.

## 70. Fifteenth Project - Cocktails Intro

Questo progetto illustrerà una lista di cocktail con le varie informazioni e le immagini andando a ricavare i dati da un'API.

Nota: da questo progetto useremo il boilerplate fornito da Vite invece che quello proveniente da create-react-app.

Nota: adattato reducer.js a Vite, rendendo il file reducer.jsx e modificandolo opportunamente.

Quest'App comprenderà una funzionalità di ricerca del cocktail.

Divideremo i Components dalle Pages in questo progetto, ma in entrambi i casi si tratta di React Components.

Utilizzeremo il context.jsx modificato per avvolgere in main.jsx il Component App in un Component AppProvider.

## 71. Fifteenth Project - Cocktails Router Setup

Dopo aver installato react-router-dom inseriamo il BrowserRouter Component, come fatto, in modo che avvolga il Component App e sia avvolto dall'AppProvider:

<code>
<React.StrictMode>
		<AppContext>
			<BrowserRouter>
				<App />
			</BrowserRouter>
		</AppContext>
	</React.StrictMode>
</code>

Modificheremo il codice fornito dal tutorial per adattarlo a react router v6. Il Router verrà sostituito dal BrowserRouter in main.jsx, lo Switch da Routes e inserito nelle Route la property element invece di inserire all'interno del Component Route il Component usato per una determinata Route.
Impostiamo quindi tutte le Route:

<code>

    return (
    		<>
    			<Navbar />
    			<Routes>
    				<Route exact path="/" element={<Home />}></Route>
    				<Route path="/about" element={<About />}></Route>
    				<Route path="/cocktail/:id" element={<SingleCocktail />}></Route>
    				<Route path="*" element={<Error />}></Route>
    			</Routes>
    		</>
    	);

</code>

## 72. Fifteenth Project - Cocktails Navbar

Impostiamo come primo Component la Navbar, in questo modo faciliteremo anche in fase di sviluppo la navigazione tra la varie Pages.

Qui abbiamo già importato il Link da react-router-dom che ci permetterà l'effettivo reindirizzamento alla pagina indicata.

Qui si mostrerà anche come assegnare ad un Link un immagine in modo da utilizzare il click sul logo per essere reindirizzati alla Home. Questo risulta abbastanza semplice:

<code>
<div className="nav-center">
				<Link to="/">
					<img src={logo} alt="cocktail logo" className="logo" />
				</Link>
			</div>
</code>

Aggiungiamo quindi alla Navbar un unordered list per i Link alle varie Pages:

<code>
<nav className="navbar">
			<div className="nav-center">
				<Link to="/">
					<img src={logo} alt="cocktail logo" className="logo" />
				</Link>
			</div>
			<ul className="nav-links">
				<li>
					<Link to="/">Home</Link>
				</li>
				<li>
					<Link to="/about">About</Link>
				</li>
			</ul>
		</nav>
</code>

## 73. Fifteenth Project - Cocktails Error About

Concentriamoci per prima cosa sulle Pages più semplici: Error.jsx e About.jsx.

Cominciamo con il Component About.jsx, composto da una section con title e paragraph con relative classes CSS:

<code>

    const About = () => {
    	return (
    		<section className="section about-section">
    			<h2 className="section-title">About us</h2>
    			<p>
    				Lorem ipsum dolor sit amet, consectetur...
    			</p>
    		</section>
    	);
    };

</code>

Ora passiamo al Component Error.jsx, composto da una section, un div container, title e un Link element per essere reindirizzati alla Home, tutto con relative classes CSS per rendere per esempio il Link un button:

<code>
const Error = () => {
	return (
		<section className="error-page section">
			<div className="error-container">
				<h2>Ooops! It's a dead end</h2>
				<Link to="/" className="btn btn-primary">
					back home
				</Link>
			</div>
		</section>
	);
};
</code>

Ora cominciamo a lavorare sulle parti più articolate.

## 74. Fifteenth Project - Cocktails Context Setup

La Home page sarà composta da due Components, un SearchForm dove effettuare la ricerca e un Cocktail List con una card per ogni cocktail presente nell'API, dove sarà presente un button per i details che porterà ad una singola page Cocktail per visualizzare i dettagli.

Ora imposteremo la struttura basica per i due Components e la struttura basica nel context.jsx, visto che il fetch iniziale dei dati verrà effettuato nel context.jsx, in modo da impostare le nostre state values usando il GlobalContext Custom Hook per renderle dispoibili ai vari Components.

Quindi nel Component Home dopo aver importato CocktailList e SearchForm, avvolgiamoli in un element main:

<code>
const Home = () => {
	return (
		<main>
			<SearchForm />
			<CocktailList />
		</main>
	);
};
</code>

Passiamo ora al context.jsx, cominciamo impostando delle semplici State values e passiamole tra i Components.
Cominciamo da loading per la schermata di caricamento e searchTerm che sarà la value che andremo a ricavare dall'input del form per passarla poi come termine di ricerca nel fetch dei dati, utilizzando poi la State value cocktails per salvarli, inizializzata però ora ad empty Array. Passiamo quindi le State values nella property value del Provider nel return assieme alla funzione setSearchTerm:

<code>

    const AppContext = ({ children }) => {
    	const [loading, setLoading] = useState(true);
    	const [searchTerm, setSearchTerm] = useState("a");
    	const [cocktails, setCocktails] = useState([]);

    		return (
    			<GlobalContext.Provider
    				value={{ loading, searchTerm, cocktails, setSearchTerm }}
    			>
    				{children}
    			</GlobalContext.Provider>
    		);
    };

</code>

Ora usando useGlobalContext dovremmo essere in grado di accedere alle varie values da tutti i Components.
Partiamo quindi da SearchForm, dove importeremo useGlobalContext ed useremo la function setSearchTerm per impostare la value che andrà a riaggiornarsi ogni qualvolta digiteremo qualcosa invocando tale funzione.

Iniziamo quindi importando la funzione da useGlobalContext invocandolo:

<code>
const SearchForm = () => {
	const { setSearchTerm } = useGlobalContext();
	return (
		<div>
			<h2>search form component</h2>
		</div>
	);
};
</code>

Passiamo ora al Component CocktailList, dove verrà visualizzato poi un Component Cocktail per ogni element nella lista, ricavata da cocktails, e dove verrà impostata la schermata di Loading dal Component in base alla relativa value della State value importata dal context.jsx. Impostiamo quindi anche un if conditional che restituirà renderizzando il Component Loading se la State value loading fosse true:

<code>
const CocktailList = () => {
	const { cocktails, loading } = useGlobalContext();
	
	if (loading) {
		return <Loading />
	}
	return (
		<div>
			<h2>cocktail list component</h2>
		</div>
	);
};
</code>

In questo modo ad ogni digitazione la State value loading verrà riportata su true e una volta ricavati dati su false, una volta completate le varie funzionalità, alternando quindi le schermate con quella di caricamento.

Vi saranno casi dove non avremo risultati, per questo renderizzeremo un messaggio adeguato e soprattutto riporteremo la State value cocktails ad un Empty Array. Gestiamo quindi questa situazione nel Component CocktailList con un altro if conditional, dove testeremo la lunghezza dell'Array ed in caso fosse inferiore ad uno renderizzeremo il messaggio per cocktail non trovato:

<code>

    const CocktailList = () => {
    	const { cocktails, loading } = useGlobalContext();

    		if (loading) {
    			return <Loading />;
    		}

    		if (cocktails.length < 1) {
    			return (
    				<h2 className="section-title">
    					no cocktails matched your search criteria
    				</h2>
    			);
    		}
    		return (
    			<div>
    				<h2>cocktail list component</h2>
    			</div>
    		);

    };

</code>

## 75. Fifteenth Project - Cocktails API Overview

Overview dell'API Cocktail DB per ottenere i dati da usare nell'App.

Useremo l'url per full cocktail details by id nel Component SingleCocktail e Search Cocktail by name nella CocktailList.

## 76. Fifteenth Project - Cocktails Fetch Drinks

Passiamo quindi ora al fetch dei dati nel context.jsx.
Creiamo la funzione asincrona fetchDrinks, con un try...catch per l'eventuale gestione degli errori.
Qusta funzione verrà chiamata ogni qualvolta scriveremo qualcosa nell'input, anche una singola lettera. Dovremo quindi impostare con la funzione setter sia l'Array di cocktail sia la value true o false di loading.

All'inizio della funzione quindi impostiamo loading a true poi impostiamo la response al fetch, ottenuto dall'url più il searchTerm che andrà a cambiare al type nell'input.
Poi gestiamo i dati trasformandoli in json e loggiamoli per cominciare:

<code>
async function fetchDrinks() {
		setLoading(true);
		try {
			const response = await fetch(`${url}${searchTerm}`);
			const data = await response.json();
			console.log(data);
		} catch (error) {
			console.log(error);
		}
	}
</code>

Impostiamo quindi un Effect per invocare la funzione fetchDrinks appena creata, con searchTerm nel Dependency Array, in modo che ad ogni cambiamento venga rieseguito l'Effect:

<code>
useEffect(() => {
		fetchDrinks();
	}, [searchTerm]);
</code>

Provando l'App otterremo un Array di 25 elements.

Ora modifichiamo ulteriormente la funzione in modo che restituisca risultati differenti nei casi che vi siano elements nell'Array oppure non ce ne siano, dove andremo a reimpostare la value ad Empty Array in modo da ottenere il message impostato precedentemente per il risultato non trovato. Alla fine ottenuti i dati e capiti aggiungeremo una funzione setter per loading a false:

<code>
async function fetchDrinks() {
		setLoading(true);
		try {
			const response = await fetch(`${url}${searchTerm}`);
			const data = await response.json();
			const { drinks } = data;
			if (drinks) {
				...
			} else {
				setCocktails([]);
			}
			setLoading(false);
		} catch (error) {
			console.log(error);
		}
	}
</code>

Ora impostiamo l'iterazione sui risultati di drinks all'interno dell'if conditional. Cominciano destrutturando le properties idDrink, strDrink, strDrinkThumb, strAlcoholic, strGlass provenienti dai dati, restituiamo un object in modo da avere le properties associati con names più utilizzabili, ed utilizziamo quest'object salvato in newCocktails per impostare con la funzione setter la State value cocktails:

<code>
async function fetchDrinks() {
		setLoading(true);
		try {
			const response = await fetch(`${url}${searchTerm}`);
			const data = await response.json();
			const { drinks } = data;
			if (drinks) {
				const newCocktails = drinks.map((item) => {
					const { idDrink, strDrink, strDrinkThumb, strAlcoholic, strGlass } =
						item;
					return {
						id: idDrink,
						name: strDrink,
						image: strDrinkThumb,
						info: strAlcoholic,
						glass: strGlass
					};
				});
				setCocktails(newCocktails);
			} else {
				setCocktails([]);
			}
			setLoading(false);
		} catch (error) {
			console.log(error);
			setLoading(false);
		}
	}
</code>

## 77. Fifteenth Project - Cocktails Display List

Spostiamoci quindi nel Component CocktailList dove andremo ad utilizzare la State value cocktails impostata in fetchDrinks, inserendo nel return una section, un title e un div dove itereare su cocktails restituendo per ogni item un Component Cocktail:

<code>

const CocktailList = () => {
const { cocktails, loading } = useGlobalContext();

    if (loading) {
    	return <Loading />;
    }

    if (cocktails.length < 1) {
    	return (
    		<h2 className="section-title">
    			no cocktails matched your search criteria
    		</h2>
    	);
    }
    return (
    	<section className="section">
    		<h2 className="section-title">cocktails</h2>
    		<div className="cocktails-center">
    			{cocktails.map((item) => {
    				return <Cocktail key={item.id} {...item} />;
    			})}
    		</div>
    	</section>
    );

</code>

Ora andremo a gestire le prop mandate al Component Cocktail.
Importiamo le props destrutturandole, creiamo un div per l'image e vari titles e paragraph per i vari dati, infine aggiungiamo un Link element con property to con path variabile usando le Template String usando l'id proveniente dal mapping nel Components CocktailList per impostare il path correttamente:

<code>

    const Cocktail = ({ image, name, id, info, glass }) => {
    	return (
    		<article className="cocktail">
    			<div className="img-container">
    				<img src={image} alt={name} />
    			</div>
    			<div className="cocktail-footer">
    				<h3>{name}</h3>
    				<h4>{glass}</h4>
    				<p>{info}</p>
    				<Link to={`/cocktail/${id}`} className="btn-primary btn-details">
    					details
    				</Link>
    			</div>
    		</article>
    	);
    };

</code>

Clickando ora nel button sotto ad ogni card andremo a visualizzare un Component SingleCocktail ancora senza dati inseriti ma con un url composto correttamente per il prossimo fetch, cioé con l'id corretto per il cocktail selezionato alla fine dell'url come parametro :id.

Ma prima di completare il Component SingleCocktail andiamo a creare il Form nel Component SearchForm con un input per inserire dei termini nella ricerca.

## 80. Fifteenth Project - Cocktails Search Form

Qui useremo un uncontrolled input e l'Hook useRef.
Impostiamo per prima cosa tutta la struttura del Component:

<code>
const SearchForm = () => {
	const { setSearchTerm } = useGlobalContext();
	const searchValue = React.useRef("");

    return (
    	<section className="section search">
    		<form className="search-form">
    			<div className="form-control">
    				<label htmlFor="name"> search your favorite cocktail</label>
    				<input type="text" id="name" ref={searchValue} />
    			</div>
    		</form>
    		<h2>search form component</h2>
    	</section>
    );

};
</code>

Qui abbiamo una section con all'interno un form che contiene un div con una label e un input, il quale element ha una property ref con value searchValue. Questa variabile andrà ad utilizzare useRef.

Qui vogliamo che ad ogni inserimento da parte dell'utente, anche una singola lettera, venga chiamata la funzione setSearchTerm in modo da modificare la State value searchTerm e attivare così l'Effect che chiama la funzione fetchDrinks in modo che vengano ottenuti i dati corrispondenti a quanto inserito nell'input.
Per avviare tutto ciò impostiamo un onChange Event Handler nell'input con una funzione searchCocktail che andremo a creare:

<code>
const SearchForm = () => {
	const { setSearchTerm } = useGlobalContext();
	const searchValue = React.useRef("");

    function searchCocktail() {
    	setSearchTerm(searchValue.current.value);
    }

    return (
    	<section className="section search">
    		<form className="search-form">
    			<div className="form-control">
    				<label htmlFor="name"> search your favorite cocktail</label>
    				<input
    					type="text"
    					id="name"
    					ref={searchValue}
    					onChange={searchCocktail}
    				/>
    			</div>
    		</form>
    		<h2>search form component</h2>
    	</section>
    );

};
</code>

La funzione searchCocktail andrà ad utilizzare la value che si imposta nella ref ad ogni modifica, chiamando al suo interno setSearchTerm con argument searchValue.current.value.
Così facendo la State value searchTerm verrà modificata e verrà chiamata la funzione fetchDrinks con il nuovo parametro di ricerca impostato.

Ora la ricerca funziona come pensata, ricercando ogni termine inserito e restituendo un message in caso di ricerca con esito negativo.

Come aggiunta inseriamo un useEffect che al primo render imposti il focus della pagina sull'input. Accediamo all'element input attraverso la costante searchValue.current e usiamo il metodo focus:

<code>
React.useEffect(() => {
		searchValue.current.focus();
	}, []);
</code>

Ora osserviamo che avviene un fetch non solo per l'inserimento di un carattere, ma anche per il semplice tasto Enter. Questo é un comportamento che occorre sistemare o vi sarà un carico di lavoro inutile.
Per farlo inseriamo un onSubmit Event Handler nell'element form ed inseriamo come value una funzione handleSubmit che andremo a creare:

<code>

...
React.useEffect(() => {
searchValue.current.focus();
}, []);

    function handleSubmit(event) {
    	event.preventDefault();
    }

    return (
    	<section className="section search">
    		<form className="search-form" onSubmit={handleSubmit}>
    			<div className="form-control">
    				<label htmlFor="name"> search your favorite cocktail</label>
    				<input
    					type="text"
    					id="name"
    					ref={searchValue}
    					onChange={searchCocktail}
    				/>
    			</div>
    		</form>
    	</section>
    );

};

</code>

Nella funzione handleSubmit andremo a passare un parametro event e poi semplicemente lo useremo per chiamare il metodo preventDefault.

## 81. Fifteenth Project - Cocktails Single Cocktail Page

Terminiamo ora il nostro progetto andando a completare il Component SingleCocktail.

In questo Component vorrò mostrare delle info su un cocktail specifico facendole visualizzare sul Component e al click del button visualizzare details in una lista.

Per accedere all'id del cocktail inserito nell'url andremo ad utilizzare l'Hook useParams fornito da react-routers-dom.
Verifichiamo la presenza dell'id ricavandolo quindi da useParams e visualizzandolo nella Page:

<code>
import { useParams, Link } from "react-router-dom";

const url = "https://www.thecocktaildb.com/api/json/v1/1/lookup.php?i=";

const SingleCocktail = () => {
const { id } = useParams();
return (

<div>
<h2>{id}</h2>
</div>
);
};

export default SingleCocktail;
</code>

Testato questo andiamo ad impostare un nuovo fetch dei dati questa volta. Come scelta non adremo a dover gestire qualcosa di grande come il context anche qui ma piuttosto separeremo le due cose.

Impostiamo come fatto nel context la State value loading e cocktail per gestire i dati.

Fatto questo impostiamo il fetch dei dati partendo dall'Effect questa volta e sommando i due passaggi:

<code>
React.useEffect(() => {
		setLoading(true);
		async function getCocktail() {
			try {
				const response = await fetch(`${url}${id}`);
				const data = await response.json();
				console.log(data);
			} catch (error) {}
		}
		getCocktail();
	}, [id]);
</code>

Il Dependency Array in questo Effect avrà al suo interno l'id ricavato in precedenza, in modo che quando questo cambierà l'Effect verrà rieseguito.

Impostando in questo modo la funzione e l'Effect otterremo nel log un object con una property drinks con value un Array di lunghezza uno, con l'element contenente i dati per il cocktail specifico relativo all'id inserito.

Gestiamo ora come in precendeza la possibilità di una risposta vuota, avendo cura di inserire un alternativa di visualizzazione. Andiamo quindi a controllare l'esistenza di data.drinks.
Fatto questo andremo a destrutturare i dati dall'Array data.drinks in caso di esistenza, andando a riassegnare le property ottenute con names più gestibili:

<code>
async function getCocktail() {
			try {
				const response = await fetch(`${url}${id}`);
				const data = await response.json();
				if (data.drinks) {
					const {
						strDrink: name,
						strDrinkThumb: image,
						strAlcoholic: info,
						strCategory: category,
						strGlass: glass,
						strInstructions: instructions,
						strIngredient1,
						strIngredient2,
						strIngredient3,
						strIngredient4,
						strIngredient5
					} = data.drinks[0];
					const ingredients = [
						strIngredient1,
						strIngredient2,
						strIngredient3,
						strIngredient4,
						strIngredient5
					];
				} else {
					setCocktail(null);
				}
				setLoading(false);
			} catch (error) {
				console.log(error);
				setLoading(false);
			}
		}
</code>

Fatto questo andiamo a creare, sempre nell'if conditional in caso di esistenza, un nuovo object chiamato newCocktail che andremo a popolare con le nuove properties appena ottenute. Useremo questo object per assegnarlo alla State value cocktail:

<code> 
...
						strIngredient2,
						strIngredient3,
						strIngredient4,
						strIngredient5
					} = data.drinks[0];
					const ingredients = [
						strIngredient1,
						strIngredient2,
						strIngredient3,
						strIngredient4,
						strIngredient5
					];
const newCocktail = {
						name,
						image,
						info,
						category,
						glass,
						instructions,
						ingredients
					};
					setCocktail(newCocktail);
</code>

Ottenuti i dati per assegnarli alla State variable andiamo ad inserire un if conditional per renderizzare il Component Loading nel caso in cui la State variable loading fosse true:

<code>
if (loading) {
		return <Loading />;
	}
</code>

E aggiungiamo inoltre un altro conditional nell'eventualità creata in precedenza nella quale data.drinks non esista, quindi cocktails resti null. Questo restituirà un h2 con un message adatto:

<code>
if (!cocktail) {
		return <h2>no cocktail to display</h2>;
	}
</code>

Ora destrutturiamo le properties name, image, category, info, glass, instructions ed ingredients dalla State value cocktail, usandole poi nel return. Restituiremo prima di tutto una section nel return con un h2 con content {name} per testare che le properties vengano lette correttamente:

<code>

    	...

    if (!cocktail) {
    	return <h2 className="section-title">no cocktail to display</h2>;
    }

    const { name, image, category, info, glass, instructions, ingredients } =
    	cocktail;

    return (
    	<section>
    		<h2 className="section-title">{name}</h2>
    	</section>
    );

};
</code>

Ora organizziamo l'intero content, dalla section nel return aggiungiamo le varie classes CSS, all'interno un element Link con class per adattarlo come button che riporti alla Home.
Sotto al title aggiunto in precedenza aggiungiamo un div con class drink-info, con all'interno un paragraph per ogni property:

<code>
<div className="drink">
				<img src={image} alt={name} />
				<div className="drink-info">
					<p>
						<span className="drink-data">name :</span>
						{name}
					</p>
					<p>
						<span className="drink-data">category :</span>
						{category}
					</p>
					<p>
						<span className="drink-data">info :</span>
						{info}
					</p>
					<p>
						<span className="drink-data">glass :</span>
						{glass}
					</p>
					<p>
						<span className="drink-data">instructions :</span>
						{instructions}
					</p>
				</div>
			</div>
</code>

Aggiungiamo quindi un ulteriore paragraph per iterare sulla property ingredients. Qui mapperemo tra tutti gli ingredienti e restituiremo un Ternary Operator con uno span restituito in caso di esistenza dell'ingrediente o altrimenti null:

<code>
<p>
						<span className="drink-data">ingredients :</span>
						{ingredients.map((item, index) => {
							return item ? <span key={index}>{item}</span> : null
						})}
					</p>
</code>

Ora implementeremo l'uso dell'Hook useCallback. Usarlo significa evitare l'avviso in console che rimanda all'utilizzo mancato di fetchDrinks nel Dependency Array.
Questo viene dato dal fatto che, per com'é impostata ora la funzione fetchDrinks nel context.jsx, la funzione viene ricreata ad ogni render. Ciò che vogliamo ottenere con l'Hook useCallback é che questa venga generata solo quando avviane un cambiamento, cioé quando il termine di ricerca subisce una variazione.

Per utilizzare useCallback andiamo semplicemente ad importarlo in context.jsx e poi usiamolo per avvolgere tutta la funzione fetchDrinks, riscritta come function expression. Come secondo parametro in useCallback inseriremo il Dependency Array con searchTerm come parametro da controllare per un eventuale ricreazione della funzione:

<code>
const fetchDrinks = useCallback(async () => {
		setLoading(true);
		try {
			const response = await fetch(`${url}${searchTerm}`);
			const data = await response.json();
			const { drinks } = data;
			if (drinks) {
				const newCocktails = drinks.map((item) => {
					const { idDrink, strDrink, strDrinkThumb, strAlcoholic, strGlass } =
						item;
					return {
						id: idDrink,
						name: strDrink,
						image: strDrinkThumb,
						info: strAlcoholic,
						glass: strGlass
					};
				});
				setCocktails(newCocktails);
			} else {
				setCocktails([]);
			}
			setLoading(false);
		} catch (error) {
			console.log(error);
			setLoading(false);
		}
	}, [searchTerm]);

    useEffect(() => {
    	fetchDrinks();
    }, [searchTerm]);

</code>

Possiamo ora aggiungere nel Dependency Array dell'Effect che chiama fetchDrinks anche il parametro fetchDrinks.

Se non avessimo utilizzato useCallback con il proprio dependency array, ma avessimo solo aggiunto fetchDrinks nel dependency array dell'Effect, saremo incappati in un infinite loop.

Anche il quindicesimo progetto é concluso, ora si tratterà l'argomento staccato "Hosting".

## 82. Hosting - Drag And Drop

L'Hosting di cui si tratterà sarà fatto tramite Netlify.
Qui esamineremo due casi d'uso: il drag and drop e il continuos deployment integrando git.

Per prima cosa andiamo a lanciare una fase di build dell'ultimo progetto fatto con npm run build.

Finita la build verrà quindi creata una cartella dist in caso di App creata con Vite o una cartella build nel caso di create-react-app.

Una nota nell'usare React Routers con Netlify:
se si vuole che React Routers funzioni bene con Netlify, parlando nello specifico delle Pages. Per migliorare la gestione delle pages si può aggiungere all'interno della cartella public un file denominato "\_redirects" con all'interno:

<code>
/* /index.html		200
</code>

E tanto basterà per far funzionare le due cose al meglio.

## 83. Hosting - Continuos Deployment

Il problema maggiore con il deploy utilizzando il metodo del drag and drop é situo nel fatto che per ogni modifica occorre andare a rifare la build e ricopiare la cartella dist o build su Netlify.

Una soluzione migliore é invece creare una repo su Github, connettere il project Netlify alla repo e ogni volta che abbiamo delle modifiche andare ad eseguire il push di tali cambiamenti su Github e così facendo Netlify aggiornerà automaticamente prendendoli da lì.

Dopo aver creato la repo ed aver effettuato il push, andiamo su Netlify e selezioniamo "new site from repo".
Completiamo quindi tutti i passaggi e selezioniamo Deploy Site.
Questo ci permetterà di mantenere aggiornato il deploy semplicemente avendo cura di effettuare il push su Github di eventuali cambiamenti.

Per far sì che tutto funzioni al meglio qui occorrerà modificare il file package.json, precisamente nella riga del comando build da "react-scripts build" in "CI= react-scripts build".

# Quinta parte - Projects - React Beach Resort Project

## 1. Hotel Project - Intro

Questo tutorial é incentrato sulla creazione di un App per un finto hotel. Mostreremo delle stanze d'hotel e imposteremo delle funzionalità che permetteranno all'utente di filtrare le ricerche. Useremo React Routers per il Routing, React Context per il management dello State, ed un Contentless CMS per la gestione dei dati e infine publicheremo la Web App con Netlify.

Il progetto sarà Responsive. Per i dispositivi con schermo piccolo nella parte alta vi sarà una Navbar che apparirà e scomparirà grazie ad un toggle button. Per gli schermi desktop la Navbar sarà tradizionale sempre visibile.

Sotto la Navbar vi sarà un Hero Component che avrà un'immagine di background, nel centro di questo Component vi sarà un button con un Link che porterà alla pagina di ricerca delle stanze prenotabili.

Sotto l'Hero Component ci sarà un Component Services che elencherà i vari servizi dell'Hotel che verranno visualizzati con delle icon abbinate.

Sotto il Component Services avremo un Component Featured Rooms dove verranno visualizzate tre tra le stanze più apprezzate, renderizzate utlizzando un Room Card Component che includerà il prezzo della stanza, il nome ed un'immagine. Andando a passare sopra alla Card vi sarà la comparsa di un Button Features con un Link che ci porterà ad una Page Single Room dove avremo le informazioni solo su una singola stanza: descrizione, dettagli, info, extra, prezzo e immagini.

Verrà creata inoltre una pagina 404 nel caso si navigasse in pagine inesistenti.

Passiamo ora al Component Search Rooms accessibile dal Button nell'Hero Component: qui avremo la lista completa di tutte le stanze disponibili nell'Hotel oltre ad una serie di filtri applicabili tramite selectors e radio buttons.
Inseriremo inoltre un message in caso non vi fossero stanze trovate con i parametri indicati.

## 2. Hotel Project - Data

Ora tratteremo l'argomento dello storage dei dati.
Quest'App funzionerà con i dati dal file data.jsx, ma in seguito si mostrerà un alternativa per lo storage dei dati tramite Contentful.

## 3. Hotel Project - Packages

Installiamo l'App tramite create-react-app o vite template. Installiamo poi React Icons e React Router Dom.

Spiegazione file \_redirects per host su Netlify utilizzando nell'App react-router-dom.

## 4. Hotel Project - Components

Creaimo i Components Pages principali: Home, Rooms, SingleRoom ed Error, tutti con una struttura basica.
Importiamo i vari Components in App.jsx.

## 5. Hotel Project - Routing

Importiamo e usiamo BrowserRouter da react-router-dom.
Impostiamo il BrowserRouter nel main.jsx (o index.js/.jsx) e il Component Routes in App.js.

Nota: impostazione diversa a cause dell'uso di React Router v6.

Impostiamo ora le singole Route, dove alle pages aggiungeremo anche una property/attribute exact. Così facendo solo se l'url sarà esatto andremo a vedere la corretta Page.

Nella Route per la SinglePage andremo ad inserire un path con parametro id per la corretta visualizzazione di una singola camera. Chiameremo l'id slug in questo caso ma il name é indifferente:

<code>
function App() {
	return (
		<>
			<Routes>
				<Route exact path="/" element={<Home />}></Route>
				<Route exact path="/rooms" element={<Rooms />}></Route>
				<Route exact path="/rooms/:slug" element={<SingleRoom />}></Route>
			</Routes>
		</>
	);
}
</code>

I modi di accesso a tale parametro verranno illustrati in seguito.

Impostiamo anche una 404 Page, che basterà inserire come singola Route nel Component Routes con l'attribute path impostato a \*:

<code>
function App() {
	return (
		<>
			<Routes>
				<Route exact path="/" element={<Home />}></Route>
				<Route exact path="/rooms" element={<Rooms />}></Route>
				<Route exact path="/rooms/:slug" element={<SingleRoom />}></Route>
				<Route path="*" element={<Error />}></Route>
			</Routes>
		</>
	);
}
</code>

## 6. Hotel Project - Navbar

Creaimo ora un Class Component Navbar nella cartella components.

Nota: possibile aggiornamento a functional Component

<code>
import React, { Component } from "react";

export default class Navbar extends Component {
render() {
return <div>hello from navbar</div>;
}
}

</code>

Importiamo il Component in App.jsx e inseriamolo all'esterno del Component Routes.

Breve dimostrazione del package React Icons.

Importiamo tutto ciò che sarà necessario per la nostra Navbar:

<code>

import React, { Component } from "react";
import logo from "../assets/logo.svg";
import { FaAlignRight } from "react-icons/fa";
import { Link } from "react-router-dom";

</code>

Nel class Component Navbar impostiamo per prima cosa uno State:

<code>
export default class Navbar extends Component {
	state = {
		isOpen: false
  };
  
	render() {
		return <div>hello from navbar</div>;
	}
}
</code>

Ed in seguito un metodo handleToggle per il toggle della Navbar, facendo in modo che alla chiamata di questo metodo venga eseguita la funzione setter di state, setState, impostando la value di isOpen al contrario di quella attuale:

<code>
export default class Navbar extends Component {
	state = {
		isOpen: false
  };

handleToggle = () => {
this.setState({isOpen: !this.state.isOpen})
}

    render() {
    	return <div>hello from navbar</div>;
    }

}
</code>

Modifichiamo ora il return della funzione render:

<code>
export default class Navbar extends Component {
	state = {
		isOpen: false
	};

    handleToggle = () => {
    	this.setState({ isOpen: !this.state.isOpen });
    };

    render() {
    	return (
    		<nav className="navbar">
    			<div className="nav-center">
    				<div className="nav-header">
    					<Link to="/">
    						<img src={logo} alt="Beach Resort" />
    					</Link>
    				</div>
    			</div>
    		</nav>
    	);
    }

}
</code>

Qui avremo l'image logo che funzionerà come Link per tornare alla Home.
Aggiungiamo inoltre il Button per il toggle all'interno del nav-header nel return del metodo render come il Component Link, aggiungendo all'interno di questo Button l'icon importata:

<code>
render() {
		return (
			<nav className="navbar">
				<div className="nav-center">
					<div className="nav-header">
						<Link to="/">
							<img src={logo} alt="Beach Resort" />
						</Link>
						<button type="button" className="nav-btn">
							<FaAlignRight className="nav-icon" />
						</button>
					</div>
				</div>
			</nav>
		);
	}
</code>

Aggiungiamo a tale Button un Event Handler onClick con la funzione handleToggle come argument:

<code>
						<button
							type="button"
							className="nav-btn"
							onClick={this.handleToggle}
						>
							<FaAlignRight className="nav-icon" />
						</button>
</code>

Aggiungiamo ora un unordered list per visualizzare la list di Links, all'esterno del nav-header ma sempre dentro il nav-center:

<code>
					<ul
						className={this.state.isOpen ? "nav-links show-nav" : "nav-links"}
					>
						<li>
							<Link to="/">Home</Link>
						</li>
						<li>
							<Link to="/rooms">Rooms</Link>
						</li>
					</ul>
</code>

La ul avrà una property className che conterrà un Ternary Operator basato sulla value this.state.isOpen. Se é true avrà le classes CSS nav-links e show-nav, altrimenti solamente nav-links.

Nota: solitamente é più conveniente impostare un Array e cogliere i dati contententi i Links da questo, renderizzandoli attraverso un map, soprattutto se si hanno molti Links da renderizzare. In questo caso avendone solamente due é più rapida come soluzione impostarli manualmente.

## 7. Hotel Project - Hero

Per prima cosa creiamo il Component. Questo Component dovrà essere renderizzato anche nelle altre pages, quindi affronteremo lo creeremo in modo che sia il più dinamico possibile per i nostri scopi.

Creiamo un functional Component che prenda due parametri in entrata: children, cioé gli elements children e hero che si riferirà alla class CSS che imposteremo:

<code>

    import React from "react";

    const Hero = ({ children, hero }) => {
    	return <header className={hero}>{children}</header>;
    };

    export default Hero;

</code>

Testiamo il nostro Component nella Page Home:

<code>

    const Home = () => {
    	return (
    		<>
    			<Hero hero="defaultHero" />
    		</>
    	);
    };

    export default Home;

</code>

Come si può vedere, passiamo all'istanza del Component Hero una class che, data la struttura della dichiarazione del Component, verrà impostata nel parametro className dell'element header del Component. In questo modo riusciremo a dare delle impostazioni delle classes CSS in modo molto dinamico, ogni qualvolta utilizzaremo il Component Hero.

Impostiamo ora delle prop di default, in modo che il nostro Component Hero non venga mai renderizzato vuoto. Per farlo torniamo al nostro Component Hero ed aggiungiamo Hero.defaultProps:

<code>
const Hero = ({ children, hero }) => {
	return <header className={hero}>{children}</header>;
};

Hero.defaultProps = {
hero: "defaultHero",
}

export default Hero;

</code>

Così facendo se l'istanza del Component non prevedesse classes, il Component userà quelle di default, come potrebbe essere per esempio nella Error Page:

<code>
import React from "react";
import Hero from "../components/Hero";

export default function Error() {
return (
<>
<Hero />
</>
);
}

</code>

Ora per completare la Error Page manca solo il banner centrale che ci permetta di tornare alla Home tramite Link.

## 8. Hotel Project - Banner

Creiamo ora un Component Banner, un functional Component che sarà situato per esempio al centro del Component Hero per entrare nella Page Rooms oppure al centro della 404 per indicare il back to Home.

A questo Component passeremo tre props: title, subtitle e children.

Nota: per children si intende i Components che vengono inseriti all'interno del Component sul quale si sta lavorando. Se non passati come prop e poi nel return di tale Component, questi non verranno renderizzati. In genere la prop children é sempre la prima indicata nell'object passato come argument nella dichiarazione del Component.

<code>

    const Banner = ({ children, title, subtitle }) => {
    	return (
    		<div className="banner">
    			<h1>{title}</h1>
    			<div></div>
    			<p>{subtitle}</p>
    			{children}
    		</div>
    	)
    };

</code>

Ora spostiamoci nel Component Home per renderizzare il Banner.
Qui importiamo il Banner oltre al Component Link di React Router Dom.
Cambiamo quindi il Component Home:

<code>
const Home = () => {
	return (
		<>
			<Hero>
				<Banner
					title="luxurious rooms"
					subtitle="deluxe rooms starting at €299"
				>
					<Link to="/rooms" className="btn-primary">
						our rooms
					</Link>
				</Banner>
			</Hero>
		</>
	);
};
</code>

## 8. Hotel Project - Error Page

Utilizziamo quanto visto prima anche per la Error Page, inseriamo il Banner con le due prop all'interno del Component Hero ed all'interno del Component Banner un Link per il return Home:

<code>
export default function Error() {
	return (
		<>
			<Hero>
				<Banner title="404" subtitle="page not found">
					<Link to="/" className="btn-primary">
						return home
					</Link>
				</Banner>
			</Hero>
		</>
	);
}
</code>

## 9. Hotel Project - Rooms Page

Effettuiamo lo stesso procedimento anche con la Rooms Page, dove però mancherà la prop subtitle.
Importiamo il Component Banner e Link, e creiamo la struttura come sopra:

<code>

    const Rooms = () => {
    	return (
    		<Hero hero="roomsHero">
    			<Banner title="our rooms">
    				<Link to="/" className="btn-primary">
    					return home
    				</Link>
    			</Banner>
    		</Hero>
    	);
    };

</code>

## 10. Hotel Project - Home - Services

Creeremo ora un Component riusabile con un title impostato, che verrà per esempio usato per i Services sotto al Banner nella Home.

Creiamo quindi due Components per accogliere questo Component riusabile. Il primo sarà Services.jsx, un class based Component molto basico.

Creiamo ora il Component riusabile, che chiameremo Title.jsx. Questo sarà un functional Component ed accetterà un parametro in entrata, {title}:

<code>

    import React from "react";

    const Title = ({ title }) => {
    	return (
    		<div className="section-title">
    			<h4>{title}</h4>
    			<div></div>
    		</div>
    	);
    };

    export default Title;

</code>

Questo Component verrà quindi importato in Services e in qualunque altro Component si voglia:

<code>
export default class Services extends Component {
	render() {
		return (
			<div>
				<Title title="services" />
			</div>
		);
	}
}
</code>

Importiamo quindi Services nella Home, dove verrà di conseguenza renderizzato anche il Component Title. il Component Services verrà renderizzato sotto il Component Hero:

<code>

    const Home = () => {
    	return (
    		<>
    			<Hero>
    				<Banner
    					title="luxurious rooms"
    					subtitle="deluxe rooms starting at €299"
    				>
    					<Link to="/rooms" className="btn-primary">
    						our rooms
    					</Link>
    				</Banner>
    			</Hero>
    			<Services />
    		</>
    	);
    };

</code>

Ora modifichiamo Services inserendo delle icons dopo averle importate oltre che ad un text. Dichiariamo uno state, che é un object nei class Component (sembra). Questo conterrà un Array di object, ognuno dei quali avrà una property icon, una title ed una info. Creato questo renderizzeremo l'Array tramite un map che restituirà un article con tutte le property degli objects dell'Array inserite correttamente:

<code>
export default class Services extends Component {
	state = {
		services: [
			{
				icon: <FaCocktail />,
				title: "free cocktails",
				info: "cocktails services from the hotel, free drinks on monday "
			},
			{
				icon: <FaHiking />,
				title: "Endless Hiking",
				info: "Hiking services from the hotel, come with us! "
			},
			{
				icon: <FaShuttleVan />,
				title: "Free shuttle",
				info: "Free and fast shuttle van services from the hotel, let's run "
			},
			{
				icon: <FaBeer />,
				title: "Strongest Beer",
				info: "Don't worry, our shuttle van is ready to take you home!"
			}
		]
	};
	render() {
		return (
			<section className="services">
				<Title title="services" />
				<div className="services-center">
					{this.state.map((item, index) => {
						return (
							<article key={index} className="service">
								<span>{item.icon}</span>
								<h6>{item.title}</h6>
								<p>{item.info}</p>
							</article>
						);
					})}
				</div>
			</section>
		);
	}
}
</code>

Facciamo inoltre una piccola aggiunta al CSS per migliorarlo:

<code>
.services h6 {
	letter-spacing: var(--mainSpacing);
	text-transform: capitalize;
}
</code>

## 11. Hotel Project - Data Structure

Ora concentriamoci sulla struttura dei dati in data.jsx e sul context, utilizzando la Context API.
Anche se alla fine del progetto imposteremo il fetch dei dati da ContentFul, al momento utilizziamo i dati in Local, per evitare problemi di accesso ai dati.

La prima cosa da notare é la struttura: questa ricalca quella contenuta in ContentFul, in modo da non dover riscrivere tutto il codice.
Poi vi é la property sys (system) all'inizio di ogni object dell'Array in data.jsx.
Questa contiene un id che, sempre quando effettueremo il fetch dei dati, sarà l'unica contenuta in sys che ci interesserà, anche se ce ne saranno molte altre.

## 12. Hotel Project - Context

Ciò che vogliamo ora é un posto dove raccogliere i dati e che li distribuisca in in giro nell'App.
Questo si può fare anche con Redux, ma una scelta più ponderata e migliore é la Context API.

Creeremo quindi un Context Object con il metodo React.createContext(deafultValue), al quale possiamo fornire una value di default o nulla.

Con questo Context Object avremo accesso a due Components.
Uno sarà Context.Provider (o semplicemente il Provider), che permetterà ai vari Components che fruiscono dei dati (detti Consuming Components) di restare aggiornati (subscribe) sui cambiamenti del Context, cioé non appena avviene un cambiamento nel Context i Consuming Components ne verranno subito informati agendo di conseguenza con una modifica o altro.
Il Provider ci permetterà in sintesi l'accesso al Context da tutto il tree dell'App.

Vi sono vari modi per accedere al Context, li esamineremo.

Creeremo il nostro context.jsx direttamente nella src, non all'interno di qualche sottocartella.

Ricordare che il Provider si occupa di fornire accesso ai dati ai Component che vogliono accedervi in tutto il tree dei Component, infatti avvolgeremo l'intera App nel Provider.
Ricordare che il Consumer accederà invece alle informazioni.

Tecnicamente si può scrivere come:

<code>

    <RoomContext.Provider value={...} />

</code>

Ma qui invece creeremo un class Component, con i dati salvati nello state. Poi creeremo dei metodi per agire su tali dati e passeremo quelli alla property value di RoomContext.Provider. Infatti si può passare a value l'intero object state, non solo una singola value per esempio una string. Restituiremo un Component RoomContext.Provider con una property value quindi, non dimenticando di passare i children altrimenti non verranno visualizzati. Per accedervi nei class Components si usa this.props.children:

<code>

    const RoomContext = React.createContext();

    export default class RoomProvider extends Component {
    state = {};
    	render() {
    		return (
    			<RoomContext.Provider value="hello">
    				{this.props.children}
    			</RoomContext.Provider>
    		);
    	}
    }

</code>

Creato il Provider ora dobbiamo creare il Consumer. Il modo più facile per crearlo é:

<code>

    const RoomConsumer = RoomContext.Consumer;

</code>

Ora dobbiamo esportare sia il Provider sia il Consumer e aggiungiamo all'export anche l'intero Context, utile in talune situazioni:

<code>

    const RoomContext = React.createContext();

    class RoomProvider extends Component {
    	state = {};

    	render() {
    		return (
    			<RoomContext.Provider value={"hello"}>
    				{this.props.children}
    			</RoomContext.Provider>
    		);
    	}
    }

    const RoomConsumer = RoomContext.Consumer;

    export { RoomProvider, RoomConsumer, RoomContext };

</code>

Ora una scelta sarebbe quella di avvolgere tutto il return del Component App.jsx nel Provider, ma avendo React Router Dom é più corretto avvolgere l'intero Component BrowserRouter all'interno di main.jsx (o index.jsx nel tutorial), dopo averlo importato:

<code>

import { RoomProvider } from "./context";

    ReactDOM.createRoot(document.getElementById("root")).render(
    	<React.StrictMode>
    		<RoomProvider>
    			<BrowserRouter>
    				<App />
    			</BrowserRouter>
    		</RoomProvider>
    	</React.StrictMode>
    );

</code>

Qui non avviene nulla di magico, il Component RoomProvider avvolge l'intera App e premette di passare delle prop a tutti i Components interni. Questo sostituisce la tecnica del "prop drilling", il passaggio delle prop da un parent attraverso molti children, anche se non utilizzate dai children intermedi. Il passaggio é necessario per poter trasmettere le prop, cosa che invece non avviene nel caso dell'uso di un context.

## 13. Hotel Project - Featured Rooms

Applichiamo ora i principi appresi sul context e ciò che abbiamo creato nel Component Featured Rooms.
Lo creeremo come un class Component:

<code>

    import React, { Component } from "react";

    export default class FeaturedRooms extends Component {
    	render() {
    	<div>hello from featured rooms</div>;
    	}
    }

</code>

Importiamolo ora nel Component FeaturedRooms ed ora proviamo ad implementare uno dei metodi per cogliere la value fornita dal Context:

<code>

    import { RoomContext } from "../context";

</code>

Qui importiamo l'intero Context, poi dichiariamo all'interno del class based Component:

<code>
export default class FeaturedRooms extends Component {
	static contextType = RoomContext;
	render() {
		<div>hello from featured rooms</div>;
	}
}
</code>

Dichiariamo uno static contextType dandogli la value del context RoomContext.
All'interno della funzione render in seguito dichiariamo una value dandogli come valore this.context per ottenere il contenuto dell'object property value del Provider:

<code>
export default class FeaturedRooms extends Component {
	static contextType = RoomContext;
	render() {
		const value = this.context;
		console.log(value);
		<div>hello from featured rooms {value}</div>;
	}
}
</code>

Ecco dove risiede la magia nel context: possiamo accedere alle value del Provider semplicemente importando il Context e dichiarandone la value.

Modifichiamo ora lo state nel context.jsx per poi passare le property una alla volta:

<code>

    class RoomProvider extends Component {
    	state = {
    		greeting: "hello",
    		name: "john"
    	};
    	render() {
    		return (
    			<RoomContext.Provider value={{ greeting: this.state.greeting }}>
    				{this.props.children}
    			</RoomContext.Provider>
    		);
    	}
    }

</code>

Oppure utilizzare lo Spread Operator per passare tutte le properties dello state object:

<code>
class RoomProvider extends Component {
	state = {
		greeting: "hello",
		name: "john"
	};
	render() {
		return (
			<RoomContext.Provider value={{ ...this.state }}>
				{this.props.children}
			</RoomContext.Provider>
		);
	}
}
</code>

Avendo ora fornito un object cambiamo la dichiarazione della variabile da value a due values destrutturate name e greeting, ricalacando le value nell'object fornito, e di conseguenza il return in FeaturedRooms:

<code>
export default class FeaturedRooms extends Component {
	static contextType = RoomContext;
	render() {
		const { name, greeting } = this.context;
		console.log(value);
		return (
			<div>
				{greeting} {name} from featured rooms
			</div>
		);
	}
}
</code>

Nella prossima fase creeremo un Components Rooms, ne importeremo i dati nel context inserendoli nello state e saremo in grado di passare quindi tali dati agli altri Components.

Qui abbiamo affrontato il modo in cui possiamo accedere al context in un class based Component, per i functional Components vedremo altri modi nelle prossime sezioni, visto che questo non é applicabile.

## 14. Hotel Project - Rooms, Context and Data

Importiamo quindi i dati nel context.jsx, col nome di items.
Modifichiamo lo state nel context inserendo la property rooms, che sarà la lista completa delle camere.
Inseriamo la property sortedRooms, in modo da avere un Array ordinato e filtrato ma subito disponibile per la selezione tra le options nel selector.
Inseriamo la property featuredRooms sia per avere un Array distinto subito pronto nella ricerca, sia per il Component FeaturedRooms.
Inseriamo infine una property loading, per avere un indicatore di quando i dati si stanno caricando, per una schermata di caricamento.

<code>

    class RoomProvider extends Component {
    	state = {
    		rooms: [],
    		sortedRooms: [],
    		featuredRooms: [],
    		loading: true
    	};
    	render() {
    		return (
    			<RoomContext.Provider value={{ ...this.state }}>
    				{this.props.children}
    			</RoomContext.Provider>
    		);
    	}
    }

</code>

Nota: La property loading può essere un eccesso quando si usano dati in locale subito accessibili, ma verrà utilizzata di più in seguito quando richiederemo i dati da ContentFul.
Ad aggiungersi allo state quando andremo ad implemetare il fetch dei dati vi saranno anche dei metodi come getData.

Nota: i dati presenti in items non vengono implementati direttamente nello state perché vogliamo che la fase di loading venga effettivamente eseguita, dove implementeremo una gif nella schermata.

A differenza di un functional Component dove avremo utilizzato un useEffect per modificare le value dello state, qui nel class based Component utilizzeremo il metodo componentDidMount, per avviare le modifiche quando il Component viene montato prima del render.
All'interno di componentDidMount dichiariamo una variabile dove utilizzeremo la funzione formatData passandogli items per formattare i dati:

<code>

    class RoomProvider extends Component {
    	state = {
    		rooms: [],
    		sortedRooms: [],
    		featuredRooms: [],
    		loading: true
    	};
    	render() {
    		return (
    			<RoomContext.Provider value={{ ...this.state }}>
    				{this.props.children}
    			</RoomContext.Provider>
    		);
    	}

    		componentDidMount() {
    			let rooms = this.formatData(items);
    		}
    }

</code>

Ora creiamo la nostra funzione formatData per ricavare un normale object dai dati per semplificare l'accesso alle varie properties, ricavando ogni campo seguendo la struttura dei dati. Ricavati l'id senza gli altri campi ed ogni image presente per quella stanza andremo a creare una variabile con value i campi per una determinata stanza, che avranno comunque i campi id e image ma con altre properties all'interno, e andremo a sostituirvi i campi id e image appena ricavati tramite Spread Operator sfruttando i parametri aggiuntivi. In questo modo avremo un object room con i dati essenziali e i campi id e images puliti:

<code>

    formatData(arr) {
    		let tempItems = arr.map((item) => {
    			let id = item.sys.id;
    			let images = item.fields.images.map((image) => image.fields.file.url);
    			let room = { ...item.fields, images: images, id: id };
    			return room;
    		});
    		return tempItems;
    	}

</code>

Nota: non dimenticare i return in questa fase.

Ora nel log in componentDidMount avremo come rooms tutte le stanze con tutti i dati come li abbiamo riformattati.
Ora sempre in componentDidMount andremo ad utilizzare i dati contenuti in rooms per modificare lo state:

<code>

    componentDidMount() {
    	let rooms = this.formatData(items);
    	console.log(rooms);
    	let featuredRooms = rooms.filter((room) => room.feature === true);
    	this.setState({
    		rooms: rooms,
    		sortedRooms: rooms,
    		featuredRooms: featuredRooms,
    		loading: false
    	});
    }

</code>

Andiamo ora a provare tramite log nel Component FeaturedRooms l'effettivo arrivo dei dati che indichi le tre rooms con la property featured con value true.

Ora prima di completare il render di FeaturedRooms, andremo a creare prima i Component:

• Room, per la visualizzazione della singole stanze sia nella page Rooms, sia nel Component FeaturedRooms

• Loading per le schermate di caricamento riusabile in più parti dell'App.

## 15. Hotel Project - Loading Component

Creiamo quindi il Component Loading, con una gif gear inserito dopo averlo importato:

<code>

    import React from "react";
    import loadingGif from "../assets/gif/loading-arrow.gif";

    export default function Loading() {
    	return (
    		<div className="loading">
    			<h4>rooms data loading...</h4>
    			<img src={loadingGif} alt="spinner" />
    		</div>
    	);
    }

</code>

Importiamo ora questo Component nel Component FeaturedRooms e per prima cosa testiamolo inserendolo nel return.

Creiamo ora un Component Room, molto semplicemente per ora la base di un functional Component:

<code>
const Room = () => {
	return <div>Hello from room</div>;
};

export default Room;

</code>

Importiamolo in FeaturedRooms e proviamolo per sicurezza.
Completeremo le funzionalità e la visualizzazione delle featured rooms nella prossima sezione ma per ora aggiungiamo il title al Component FeaturedRooms utilizzando il Component Title creato in precedenza. Aggiungiamo inoltre tra le properties importate da context anche loading per gestire il caricamento con la relativa schermata e Component. Mapperemo tutte le rooms ora ma, a differenza di quanto fatto finora, lo faremo non all'interno del return direttamente nel JSX ma prima come codice:

<code>
export default class FeaturedRooms extends Component {
	static contextType = RoomContext;
	render() {
		const { loading, featuredRooms: rooms } = this.context;
		rooms = rooms.map((room) => {
			return <Room key={room.id} room={room} />
		})
		return (
			<div>
				from featured rooms
				<Room />
				<Loading />
			</div>
		);
	}
}
</code>

Ora sistemiamo il return, trasformandolo in una section e aggiungendo il Component Title oltre alle rooms appena determinte. Inseriremo queste ultime in un ternary Operator, dove basandoci sulla property loading proveniente dal context.jsx andremo a visualizzare il Component Loading in caso true e le rooms in caso false:

<code>

export default class FeaturedRooms extends Component {
static contextType = RoomContext;
render() {
let { loading, featuredRooms: rooms } = this.context;
rooms = rooms.map((room) => {
return <Room key={room.id} room={room} />;
});
return (

<section className="featured-rooms">
<Title title="featured rooms" />
<div className="featured-rooms-center">
{loading ? <Loading /> : rooms}
</div>
</section>
);
}
}

</code>

Le tre rooms verranno ora visualizzate visto che loading é impostata su false, proveniente dal context.jsx nella funzione componentDidMount.
Se in questa funzione impostassimo loading su true simulando un lungo caricamento, nel Component FeaturedRooms si visualizzarebbe la schermata di Loading tramite il relativo Component proveniente dal Ternary Operator.

Da qui si evince l'importanza di avere una flag loading per gestire una schermata di caricamento. Se i dati non sono presenti si rischia di avere tempi morti nell'App, meglio sempre avere una schermata di caricamento fin tanto che questi non sono presenti.

L'idea ora é che le Room visualizzate renderizzino i vari dati in modo completo con immagine e informazioni basiche, contenendo poi un Link che ci reinderizzi verso la pagina completa della stanza con tutte le infomazioni tramite il Component Room fino ad una Page Room. Questo processo sarà utilizzabile sia in FeaturedRooms che in Rooms, la lista completa filtrabile delle stanze.

## 16. Hotel Project - Room Component

Continuiamo quindi con il Component Room creato nella sezione precedente.
Visti i nostri scopi, importiamo il Component Link da React Router Dom.
Nel Component, destrutturiamo la prop room, come é stata passata in FeaturedRooms, contenente i dati della stanza. Ricaviamo dai dati delle tre stanze solo le prop images, della quale useremo solo la prima immagine, la prop name, la prop slug e quella price.

<code>

    const Room = ({ room }) => {
    	const { name, slug, images, price } = room;
    	return <div>Hello from Room</div>;
    };

</code>

Ora modifichiamo il return:

<code>

    const Room = ({ room }) => {
    	const { name, slug, images, price } = room;
    	return (
    		<article className="room">
    			<div className="img-container">
    				<img src={images[0]} alt="single-room" />
    			</div>
    		</article>
    	);
    };

</code>

Qui creiamo un immagine per la card della stanza in FeaturedRooms, ma se vi fossero problemi nei dati si vedrebbe solo il testo alternativo della stanza. Per questo conviene sempre avere un'immagine alternativa presente ed impostarla per essere visualizzata nel caso quella principale non fosse disponibile per qualsivoglia motivo.

Per impostarla come alternativa di default basterà semplicemente mettere le due alternative con un OR Operator:

<code>

    const Room = ({ room }) => {
    	const { name, slug, images, price } = room;
    	return (
    		<article className="room">
    			<div className="img-container">
    				<img src={images[0] || defaultImg} alt="single-room" />
    			</div>
    		</article>
    	);
    };

</code>

Aggiungiamo ora le altre informazioni alla Card Room nel return del Component:

<code>

    const Room = ({ room }) => {
    	const { name, slug, images, price } = room;
    	return (
    		<article className="room">
    			<div className="img-container">
    				<img src={images[0] || defaultImg} alt="single-room" />
    				<div className="price-top">
    					<h6>€{price}</h6>
    					<p>per night</p>
    				</div>
    				<Link to=""></Link>
    			</div>
    		</article>
    	);
    };

</code>

Ora lavoriamo sul Component Link, basandoci sulla struttura delle Route in App.jsx.
Il link corretto sarà /rooms/:slug. Il parametro slug verrà ricavato dalla proprietà destrutturata in precendeza fornendo così l'url corretto per ogni stanza. Nella prossima sezione imposteremo la Page che importerà i dati corrispondenti corretti basandosi proprio su questa url.

<code>

    const Room = ({ room }) => {
    	const { name, slug, images, price } = room;
    	return (
    		<article className="room">
    			<div className="img-container">
    				<img src={images[0] || defaultImg} alt="single-room" />
    				<div className="price-top">
    					<h6>€{price}</h6>
    					<p>per night</p>
    				</div>
    				<Link to={`/rooms/${slug}`} className="btn-primary room-link">
    					Features
    				</Link>
    			</div>
    		</article>
    	);
    };

</code>

Provando il Link, già ora vedremo che ci porterà alla Page SingleRoom con url corretto.

Aggiungiamo infine un paragraph con la property name per completare la Card della stanza:

<code>

    const Room = ({ room }) => {
    	const { name, slug, images, price } = room;
    	return (
    		<article className="room">
    			<div className="img-container">
    				<img src={images[0] || defaultImg} alt="single-room" />
    				<div className="price-top">
    					<h6>€{price}</h6>
    					<p>per night</p>
    				</div>
    				<Link to={`/rooms/${slug}`} className="btn-primary room-link">
    					Features
    				</Link>
    			</div>
    			<p className="room-info">{name}</p>
    		</article>
    	);
    };

</code>

Come ultima feature per questo Component aggiungiamo la possibilità di determinare il type di prop in arrivo dalle istanze. Importiamo per prima cosa PropTypes da prop-types.

Nota: da React.js v15.5 disponibile in package separato non integrato.

Nota: La struttura di controllo sarà simile ai controlli effettuati nel Model di Node.js.

<code>

...

    	</article>
    		);
    	};

    Room.propTypes = {
    	room: PropTypes.shape({
    		name: PropTypes.string.isRequired,
    		slug: PropTypes.string.isRequired,
    		images: PropTypes.arrayOf(PropTypes.string).isRequired,
    		price: PropTypes.number.isRequired
    	})
    };

export default Room;

</code>

Passiamo quindi alla creazione della SingleRoom Page.

## 17. Hotel Project - SingleRoom Page

Invece di partire immediatamente con il Component effettivo, andiamo a creare prima una funzionalità nel context.jsx chiamata getRoom. Questa funzione accetterà un singolo parametro slug.
Andiamo ad ottenere un Array con le stesse properties della property rooms dello state, che poi andremo ad usare con un metodo degli Array find() per ottenere la stanza con lo slug corrispondente al nostro parametro, restituendo poi la stanza trovata:

<code>
getRoom = (slug) => {
		let tempRooms = [...this.state.rooms];
		const room = tempRooms.find((room) => room.slug === slug);
		return room;
	};
</code>

La differenza tra find e filter é che il primo si ferma al primo risultato trovato e restituisce un object mentre il secondo restituisce un Array con tutti i risultati trovati.

Passiamo ora la function appena creata nel return del render del context all'interno della property value del Provider, in modo da poterla condividere con gli altri Components che ne necessiteranno, in particolare per ottenere i dati cogliendo lo slug dell'url per la Page SingleRoom:

<code>
render() {
		return (
			<RoomContext.Provider value={{ ...this.state, getRoom: this.getRoom }}>
				{this.props.children}
			</RoomContext.Provider>
		);
	}
</code>

Passiamo ora all'effettiva Page SingleRoom cominciando con l'organizzare gli import, prima un immagine per avere uno sfondo nella SingleRoom page, poi il Component Hero, che sarà presente ad inizio pagina, il Banner Component che useremo per visualizzare il name, un Link per reindirizzare alla Page per tutte le Rooms ed infine il context come {RoomContext} per averlo interamente importato:

<code>
import defaultBkg from "../assets/room-1.jpeg";
import Hero from "../components/Hero";
import Banner from "../components/Banner";
import {
	Link
} from "react-router-dom";
import { RoomContext } from "../context";
</code>

Fatto questo andiamo a cogliere il parametro slug dall'url.

Nota: Conversione del Component in functional Component a causa della mancanza della possibilità di leggere le props senza un Hook in React Router v6. Gli Hook possono essere utilizzati solo all'interno di un functional Component.
NON FATTIBILE AL MOMENTO.

Nota: trovata soluzione alternativa anche se bad practice, usare window.location.href.split('/')[4] per determinare lo :slug.

Impostiamo la soluzione trovata ed il nuovo return testando l'Hero Component:

<code>
export default class SingleRoom extends Component {
	constructor(props) {
		super(props);
	}

    state = {
    	slug: window.location.href.split("/")[4],
    	defaultBkg
    };

    static contextType = RoomContext;

    render() {
    	const { getRoom } = this.context;
    	const room = getRoom(this.state.slug);

    	if (!room) {
    		return (
    			<div className="error">
    				<h3>No such room could be found...</h3>
    				<Link to="/rooms" className="btn-primary">
    					Back to rooms
    				</Link>
    			</div>
    		);
    	}

    	// console.log(room);
    	const {
    		name,
    		description,
    		capacity,
    		size,
    		price,
    		extras,
    		breakfast,
    		pets,
    		images
    	} = room;
    	return (
    		<Hero hero="roomsHero">
    			<Banner title={`${name} room`}>
    				<Link to="/rooms" className="btn-primary">
    					back to rooms
    				</Link>
    			</Banner>
    		</Hero>
    	);
    }

}
</code>

Osserviamo ora il risultato ottenuto. Il titolo cambia seguendo lo slug nell'url ma l'immagine di sfondo del Component Hero rimane la stessa, questo é dato dalla class CSS con l'immagine impostata come sfondo. Per sistemare questo problema dobbiamo tenere a mente quale tecnica é meglio usare, considerando che in seguito otteremo i dati con un fetch da ContentFul e quindi le immagini non saranno più stipate in local ma vi si accederà in maniera dinamica.

Per implementare un impostazione dinamica delle immagini utilizzeremo gli Styled Components, che ci permetteranno di inserire tali dati dinamicamente.

Nella prossima sezione daremo uno style dinamicamente a Hero, che accederà dinamicamente alle immagini ed agli altri dati.

## 18. Hotel Project - Styled Components

L'idea generale dietro gli Styled Components é che possiamo attaccare dello style a dei Components, tramite JavaScript utilizzando dei metodi che partono da styled. Per esempio se dichiaro un Button:

<code>

    const Button = styled.button

</code>

A cui attaccherò una string tramite Template Literal:

<code>

    const Button = styled.button`background: palevioletred;`;

</code>

E' possibile tramite gli Styled Components ottenere lo style da un altro Component e modificarne solo le properties desiderate, sempre usando styled, solo come metodo questa volta, ma sempre attaccando alla fine un Template Literal con le nuove properties:

<code>

    const TomatoButton = styled(Button)`background: tomato;`;

</code>

Nota: Ricordarsi di installare ed importare il package styled da styled-components.

Uno dei maggiori vantaggi degli Styled Components è che, all'interno del Template Literal con il CSS, possiamo anche inserire de codice JavaScript in modo da ottenere delle modifiche dinamiche al nostro CSS dello Styled Component.

Per prima cosa quindi installiamo il package tramite npm.
Proviamo quindi gli Styled Components con un Button e proviamolo creando uno StyledHero Component.
In uno Styled Component non vi é bisogno tecnicamente di importate anche React, ma facciamolo per sicurezza. Oltre a questo chiaramente importiamo anche styled da styled-components.

Creiamo quindi lo style per il Component SimpleButton, che poi andremo a sostituire con StyledHero una volta terminato questa prova:

<code>
const SimpleButton = styled.button`
	color: red;
	background: green;
`;

export default SimpleButton;

</code>

Importiamo questo nuovo Styled Component in Home.jsx ed inseriamolo come prova:

<code>
const Home = () => {
	return (
		<>
			<Hero>
				<Banner
					title="luxurious rooms"
					subtitle="deluxe rooms starting at €299"
				>
					<Link to="/rooms" className="btn-primary">
						our rooms
					</Link>
				</Banner>
			</Hero>
			<Services />
			<FeaturedRooms />
			<Button>test button</Button>
		</>
	);
};
</code>

E questo Button funziona. Consideriamo che tutto il codice in StyledHero é JavaScript, quindi possiamo inserirvi delle variabili:

<code>
import styled from "styled-components";

const orange = "#F15025";

const SimpleButton = styled.button`	color: ${orange};
	background: green;
	font-size: 3rem;`;

export default SimpleButton;

</code>

Possiamo quindi facilmente capire che possiamo importare i dati necessari per impostare dinamicamente un'image, cambiandola in base ai dati in arrivo impostandola seguendo la modalità sopra indicata.

Ciò che cerchiamo di fare quindi é ottenere l'immagine nel nostro Styled Component così quando renderizziamo il Component più grande Hero, possiamo utilizzarla senza avere sempre la stessa immagine fissa.

Per prima cosa impostiamo una default image, poi impostiamo il nostro Styled Component StyledHero, copiando le properties dal CSS, per ottenere così la possibilità di modificare quella background:

<code>
import styled from "styled-components";
import defaultImg from "../assets/room-1.jpeg";

const StyledHero = styled.header`	min-height: 60vh;
	background: url("./assets/defaultBcg.jpeg") center/cover no-repeat;
	display: flex;
	align-items: center;
	justify-content: center;`;

export default StyledHero;
</code>

Modifichiamo quindi ora la parte url della value della property background:

<code>

const StyledHero = styled.header`	min-height: 60vh;
	background: url(${defaultImg}) center/cover no-repeat;
	display: flex;
	align-items: center;
	justify-content: center;`;

</code>

Ora avremo la possibilità di passare le props a questo Styled Component, in modo da utilizzarle poi all'interno dello styled.header. Per poter passare le props passiamo alla parte dinamica dello styled.header una funzione, che accetti come parametro le props e restituisca props.img:

<code>
const StyledHero = styled.header`
	min-height: 60vh;
	background: url(${(props) => props.img}) center/cover no-repeat;
	display: flex;
	align-items: center;
	justify-content: center;
`;
</code>

Spostiamoci ora nel SigleRoom Component, dove importeremo lo StyledComponent per prima cosa, modifichiamo poi il return, in modo da far restituire un Component StyledHero invece che uno Hero, passando a questo la prop img uguale alla value images, destrutturata da room sopra, utilizzandone solo il primo element:

<code>
...
const {
			name,
			description,
			capacity,
			size,
			price,
			extras,
			breakfast,
			pets,
			images
		} = room;
		return (
			<StyledHero img={images[0]}>
				<Banner title={`${name} room`}>
					<Link to="/rooms" className="btn-primary">
						back to rooms
					</Link>
				</Banner>
			</StyledHero>
		);
	}
	
</code>

Ora, per ogni stanza, alla quale accederemo usando il Component SingleRoom, avremo un immagine corrispondente presa da room, destrutturata e ottenuta dall'Array images e poi passata come prop al Component StyledHero e poi inserita dinamicamente nel Component renderizzato.

Inseriamo anche l'immagine di default nel codice in modo da avere un'immagine sostituiva nel caso non venissero caricate le altre. Mostreremo due alternative su dove inserirla:

<code>
1- 
<StyledHero img={images[0] || this.state.defaultBkg}>
				<Banner title={`${name} room`}>
					<Link to="/rooms" className="btn-primary">
						back to rooms
					</Link>
				</Banner>
			</StyledHero>

2-
const StyledHero = styled.header`	min-height: 60vh;
	background: url(${(props) => (props.img ? props.img : defaultImg)})
		center/cover no-repeat;
	display: flex;
	align-items: center;
	justify-content: center;`;
</code>

## 19. Hotel Project - Single Room Info and Details

Inseriamo ora tutte le altre informazioni nel Component SingleRoom, per completarlo. Tutto dovrà andare dopo il Component StyledHero, quindi includiamolo in un Fragment ed aggiungiamo il nuovo content di seguito, partendo dalle images:

<code>
return (
			<>
				<StyledHero img={images[0]}>
					<Banner title={`${name} room`}>
						<Link to="/rooms" className="btn-primary">
							back to rooms
						</Link>
					</Banner>
				</StyledHero>
				<section className="single-room">
					<div className="single-room-images">
						{images.map((image, index) => {
							return <img key={index} src={image} alt={name} />;
						})}
					</div>
				</section>
			</>
		);
</code>

Così facendo avremo tutte e quattro le immagini renderizzate di seguito, compresa quella sullo sfondo di StyledHero. Se invece volessimo omettere quella prima immagine dell'Array possiamo farlo destrutturando l'Array images, destrutturato a sua volta su room. Useremo però il destructuring degli Array assieme al rest parameter:

<code>
		const [mainImg, ...defaultImg] = images;
</code>

Come studiato in passato, in questo modo salveremo il primo element in una variabile separata mainImg e tutti gli altri elements, indifferentemente dalla loro quantità, nel nuovo Array defaultImgs.
Quindi nel return del Component userò queste due nuove variabili:

<code>

    return (
    			<>
    				<StyledHero img={mainImg}>
    					<Banner title={`${name} room`}>
    						<Link to="/rooms" className="btn-primary">
    							back to rooms
    						</Link>
    					</Banner>
    				</StyledHero>
    				<section className="single-room">
    					<div className="single-room-images">
    						{defaultImgs.map((image, index) => {
    							return <img key={index} src={image} alt={name} />;
    						})}
    					</div>
    				</section>
    			</>
    		);

</code>

Ora che le immagini sono sistemate, passiamo al resto delle informazioni sulla stanza in un div separato subito sotto al container delle images, completando così la Page Component SingleRoom:

<code>
return (
			<>
				<StyledHero img={mainImg}>
					<Banner title={`${name} room`}>
						<Link to="/rooms" className="btn-primary">
							back to rooms
						</Link>
					</Banner>
				</StyledHero>
				<section className="single-room">
					<div className="single-room-images">
						{defaultImgs.map((image, index) => {
							return <img key={index} src={image} alt={name} />;
						})}
					</div>
					<div className="single-room-info">
						<article className="desc">
							<h3>details</h3>
							<p>{description}</p>
						</article>
						<article className="info">
							<h3>info</h3>
							<h6>price : ${price}</h6>
							<h6>size : {size} SQFT</h6>
							<h6>
								max capacity :{" "}
								{capacity > 1 ? `${capacity} people` : `${capacity} person`}
							</h6>
							<h6>{pets ? "pets allowed" : "no pets allowed"}</h6>
							<h6>{breakfast && "free breakfast included"}</h6>
						</article>
					</div>
				</section>
				<section className="room-extras">
					<h6>extras</h6>
					<ul className="extras">
						{extras.map((item, index) => {
							return <li key={index}>- {item}</li>;
						})}
					</ul>
				</section>
			</>
		);
</code>

Il prossimo Component sarà il Rooms Component. Questo al suo interno avrà due ulteriori Components: uno per la ricerca e uno per l'effettiva visualizzazione delle stanze risultato della ricerca.
Si sfrutterà questo Component per illustrare come accedere al context tramite Functional Component.

## 20. Hotel Project - Rooms

Creiamo quindi dei nuovi Components: un RoomsContainer.jsx, e i due Components che andranno al suo interno, RoomsFilter e RoomsList. Creiamo RoomsContainer come un Functional Component e renderizziamo al suo interno gli altro due:

<code>

    export default function RoomsContainer() {
    	return (
    		<div>
    			Hello from Rooms Container
    			<RoomsFilter />
    			<RoomsList />
    		</div>
    	);
    }

</code>

Anche RoomsList e RoomsFilter saranno due Functional Components.

Inseriamo nella Page Rooms il Component RoomsContainer per renderizzare i risultati dei nostri prossimi lavori sulla Page:

<code>

    const Rooms = () => {
    	return (
    		<>
    			<Hero hero="roomsHero">
    				<Banner title="our rooms">
    					<Link to="/" className="btn-primary">
    						return home
    					</Link>
    				</Banner>
    			</Hero>
    			<RoomsContainer />
    		</>
    	);
    };

</code>

Ora per prima cosa vediamo come possiamo utilizzare il context all'interno dei Functional Components.
L'idea generale é quella di accedere alla value fornita nel return del context.jsx attraverso il Consumer.
Questo viene colto dalla lista di export del context.jsx, chiamato RoomConsumer:

<code>
export { RoomProvider, RoomConsumer, RoomContext };
</code>

Torniamo quindi nel RoomsContainer dove importeremo il RoomConsumer ed il Component Loading per i caricamenti:

<code>
import { RoomConsumer } from "../context";
import Loading from "./Loading";
</code>

Inseriamo quindi l'istanza del Component RoomConsumer e per ottenere i dati in value passeremo una funzione, detta anche "Render Props". Passeremo un parametro a questa funzione, value, che altro non rappresenterà che la property value della quale vogliamo cogliere i dati. Nel return di tale funzione passiamo il div precedente con le istanze dei Components RoomsFilter e RoomsList:

<code>
export default function RoomsContainer() {
	return (
		<RoomConsumer>
			{(value) => {
				console.log(value);
				return (
					<div>
						Hello from Rooms Container
						<RoomsFilter />
						<RoomsList />
					</div>
				);
			}}
		</RoomConsumer>
	);
}
</code>

Destrutturiamo ora il parametro in entrata value:

<code>
export default function RoomsContainer() {
	return (
		<RoomConsumer>
			{(value) => {
				const { loading, sortedRooms, rooms } = value;

    			return (
    				<div>
    					Hello from Rooms Container
    					<RoomsFilter />
    					<RoomsList />
    				</div>
    			);
    		}}
    	</RoomConsumer>
    );

}
</code>

Andremo a passare la property destrutturata sortedRooms al Component RoomsList e quella rooms al Component RoomsFilter, ma in entrambi la prop verrà chiamata rooms.
Impostiamo inoltre un if conditional per renderizzare il Component Loading nel caso la property loading fosse true:

<code>
export default function RoomsContainer() {
	return (
		<RoomConsumer>
			{(value) => {
				const { loading, sortedRooms, rooms } = value;

    			if (loading) {
    				return <Loading />;
    			}

    			return (
    				<div>
    					Hello from Rooms Container
    					<RoomsFilter rooms={rooms} />
    					<RoomsList rooms={sortedRooms} />
    				</div>
    			);
    		}}
    	</RoomConsumer>
    );

}
</code>

Ora vedremo un alternativa all'uso del Consumer per passare delle prop dal context.
Questo verrà definito **Higher Order Component**.
Andiamo nel context.jsx e creiamo una nuova funzione con export annesso chiamata withRoomConsumer dando un parametro Component in entrata. In questa funzione restituiremo una funzione, per questo Higher Order. Praticamente viene restituito un Component da un altro Component. Chiamaremo questa funzione ConsumerWrapper:

<code>

    export function withRoomConsumer(Component) {
    	return function ConsumerWrapper(props){}
    }

</code>

Ora é fondamentale includere come parametro della funzione ConsumerWrapper le props. Queste props non ci saranno in questo caso, sono un argument opzionale, ma se usassimo questo Higher Order Component per il Component RoomsFilter per esempio, la prop sarebbe rooms.

Ora nella funzione ConsumerWrapper restituiremo il Consumer e come in precedenza seguendo la regola inseriremo al suo interno una funzione con parametro value e un return con un Component, preso dall'argument di withRoomConsumer, con delle props passate con lo spread operator per includerle tutte ed una prop context con value uguale a value proveniente dalla funzione stessa:

<code>
export function withRoomConsumer(Component) {
	return function ConsumerWrapper(props) {
		return (
			<RoomConsumer>
				{(value) => <Component {...props} context={value} />}
			</RoomConsumer>
		);
	};
}
</code>

Riscriviamo da zero il Component RoomsContainer usando ora questo Higher Order Component. Importerò quindi tutto ciò che ho usato in precedenza tranne RoomConsumer. Al suo posto imporetermo quindi l'Higher Order Component withRoomConsumer da context.jsx.

<code>
function RoomContainer({ context }) {}

export default withRoomConsumer(RoomContainer);
</code>

Come si può notare usiamo infine il wrapper per avvolgere il Component RoomContainer ed accedere al context.

Scriviamo quindi il Component RoomsContainer, similarmente a prima con la sola differenza che il destructuring avverrà sul context invece che sull'argument value:

<code>
function RoomsContainer({ context }) {
	const { loading, sortedRooms, rooms } = context;

    if (loading) {
    	return <Loading />;
    }

    return (
    	<div>
    		Hello from Rooms Container
    		<RoomsFilter rooms={rooms} />
    		<RoomsList rooms={sortedRooms} />
    	</div>
    );

}

export default withRoomConsumer(RoomsContainer);
</code>

Un'altra alternativa meno articolata come visto nei tutorial precendenti é usare invece gli Hooks.

Ora puliamo il Component RoomsContainer con il quale abbiamo finito:

<code>
function RoomsContainer({ context }) {
	const { loading, sortedRooms, rooms } = context;

    if (loading) {
    	return <Loading />;
    }

    return (
    	<>
    		<RoomsFilter rooms={rooms} />
    		<RoomsList rooms={sortedRooms} />
    	</>
    );

}

export default withRoomConsumer(RoomsContainer);
</code>

Il prossimo Component che completeremo sarà RoomsList.

## 21. Hotel Project - RoomsList

Cominciamo importando il Component Room, necessario per renderizzare la singola stanza.
Passiamo come parametro nel Component la prop rooms scritta nell'istanza in RoomsContainer.

Per prima cosa renderizziamo un message nel caso che l'Array rooms fosse vuoto:

<code>
export default function RoomsList({ rooms }) {
	if (rooms.length === 0) {
		return (
			<div className="empty-search">
				<h3>Unfortunately no rooms matched your search parameters</h3>
			</div>
		);
	}
	return <div>Hello from Rooms List</div>;
}
</code>

Modifichiamo poi il return principale nel caso rooms avesse degli elements, inserendo una section con all'interno un div dove andremo ad eseguire un map sull'Array rooms, restituendo per ogni element un Component Room. Questo avrà come key prop l'id dell'item e come prop room l'item stesso, che destrutturato nel Component Room fornirà tutti i dati da inserire nel Component stesso:

<code>
export default function RoomsList({ rooms }) {
	if (rooms.length === 0) {
		return (
			<div className="empty-search">
				<h3>Unfortunately no rooms matched your search parameters</h3>
			</div>
		);
	}
	return (
		<section className="roomslist">
			<div className="roomslist-center">
				{rooms.map((item) => {
					return <Room key={item.id} room={item} />;
				})}
			</div>
		</section>
	);
}
</code>

Dopo una breve parentesi (non inclusa come appunti) su auto-fill ed auto-fit (meglio il primo con una grossa lista), passiamo quindi al Component RoomsFilter.

## 22. Hotel Project - RoomsFilter

Per prima cosa, ancora prima di iniziare con il Component RoomsFilter, andiamo a modificare il context.jsx.
Nei React Forms vi é un'opzione per inserire i Controlled Inputs.
Ciò significa che ci sarà una value nello state, che andrà a riflettere le opzioni disponibili nel Room Type, con un onChange event handler, i cui risultati andranno a riflettersi nello state stesso.

Andiamo quindi a modificare il context.jsx per ottenere delle value di default aggiuntive allo state utili ai Controlled Inputs. Queste nuove properties di state andranno a ricalcare delle caratteristiche delle stanze:

<code>
class RoomProvider extends Component {
	state = {
		rooms: [],
		sortedRooms: [],
		featuredRooms: [],
		loading: true,
		type: "all",
		capacity: 1,
		price: 0,
		minPrice: 0,
		maxPrice: 0,
		minSize: 0,
		maxSize: 0,
		breakfast: false,
		pets: false
	};
	...
</code>

Ora nella funzione componentDidMount andremo ad impostare le varie properties in base ai dati che ci arriveranno. Questo significa che dovrò andare a recuperare dei dati da impostare per ottenere tutte le stanze comprese nel caricamento iniziale del Component. Quindi per esempio per il price dovrò trovare il prezzo massimo di una stanza nei dati ed usarlo per impostare il limite dello slider al massimo con il Room Price ottenuto dai dati. Così sarà anche per esempio per il valore della Room Size: il valore massimo a destra dovrà essere ottenuto dai dati.

Per calcolare quindi il maxPrice ottenuto dai dati andiamo a creare in componentDidMount una variabile che prenderà per ogni item tramite map l'item.price, quindi con ogni price ottenuto salvato in rooms ora, useremo lo spread operator per indicare di farlo per ogni element di rooms, e da questa serie di valori per ogni stanza andremo a calcolarne il massimo tramite Math.max:

<code>
		let maxPrice = Math.max(...rooms.map((item) => item.price));
</code>

Allo stesso modo andremo a calcolare la maxSize delle stanze disponibile:

<code>
let maxPrice = Math.max(...rooms.map((item) => item.price));
let maxSize = Math.max(...rooms.map((item) => item.size));
</code>

Andiamo quindi a modificare lo state, dalle quattro properties presenti:

<code>
this.setState({
			rooms: rooms,
			sortedRooms: rooms,
			featuredRooms: featuredRooms,
			loading: false
		});
</code>

Andremo ad aggiungere il price e la size con come value quelle che abbiamo appena ricavato dai dati:

<code>
this.setState({
			rooms: rooms,
			sortedRooms: rooms,
			featuredRooms: featuredRooms,
			loading: false,
			price: maxPrice,
			maxPrice,
			maxSize
		});
</code>

Creiamo ora una funzione handleChange per gestire i cambiamenti su ogni campo input del form, che poi andrà a modificare gli elements visualizzati nella RoomsList. Per ora limitiamoci a salvare in variabili i parametri che ci serviranno:

<code>
handleChange = (event) => {
		const type = event.target.type;
		const name = event.target.name;
		const value = event.target.value;
		console.log(type, name, value);
	};
</code>

Passiamo ora questa funzione al Provider nel return del render:

<code>
render() {
		return (
			<RoomContext.Provider
				value={{
					...this.state,
					getRoom: this.getRoom,
					handleChange: this.handleChange
				}}
			>
				{this.props.children}
			</RoomContext.Provider>
		);
	}
</code>

Passiamo quindi alla creazione del Component RoomsFilter.jsx.
Per prima cosa importiamo useContext. Questo é il metodo più recente per importare il context in un Functional Component,
usando gli Hooks.

Importiamo quindi useContext da react, e RoomContext, cioé l'intero context, da context.jsx. Aggiungiamo quindi una variabile nel Component e chiamiamola context. Questa sarà il risultato della chiamata a useContext passando come parametro RoomContext:

<code>
import React, { useContext } from "react";
import { RoomContext } from "../context";
import Title from "../components/Title";

export default function RoomsFilter() {
const context = useContext(RoomContext);
return <div>Hello from Rooms Filter</div>;
}
</code>

Questo é il metodo più veloce e moderno per accedere al context. Chiaramente meglio conoscere anche gli Higher Order Components e i Render Props.

Ora andiamo a destrutturare alcune properties dalla variabile context appena creata. Tutte queste verranno utilizzate negli input per creare dei Controlled Inputs:

<code>

    export default function RoomsFilter() {
    	const context = useContext(RoomContext);
    	const {
    		handleChange,
    		type,
    		capacity,
    		price,
    		minPrice,
    		maxPrice,
    		minSize,
    		maxSize,
    		breakfast,
    		pets
    	} = context;
    	return <div>Hello from Rooms Filter</div>;
    }

</code>

Modifichiamo ora il return, restituendo una section con all'interno il Component Title ed un form, sul quale cominceremo a lavorare per inserire tutti gli input:

<code>
	const context = useContext(RoomContext);
	const {
		handleChange,
		type,
		capacity,
		price,
		minPrice,
		maxPrice,
		minSize,
		maxSize,
		breakfast,
		pets
	} = context;
	return (
		<section className="filter-container">
			<Title title="search rooms"></Title>
			<form className="filter-form">
				
			</form>
		</section>
	);
}
</code>

Qui ci aiuteremo anche con dei commenti vista la grandezza del Component.
Inseriamo all'interno del form un div, con all'interno una label ed un select, che dovrà avere la property name per andare a prendere i dati dal name ottenuto nella funzione handleSubmit, un property id uguale a type per associarsi alla label soprastante, con property htmlFor uguale a type, e una property value uguale alla property type destrutturata dal context. Aggiungiamo infine un onChange event handler sempre nel select in modo che venga eseguita la funzione handleChange ottenuta dal context.jsx:

<code>
return (
		<section className="filter-container">
			<Title title="search rooms"></Title>
			<form className="filter-form">
				{/* select type */}
				<div className="form-group">
					<label htmlFor="type">room type</label>
					<select
						name="type"
						id="type"
						value={type}
						className="form-control"
						onChange={handleChange}
					></select>
				</div>
				{/* end select type */}
			</form>
		</section>
	);
</code>

In questo modo abbiamo creato il primo Controlled Input, ora manca solo inserirvi i vari type di rooms. Per farlo occorrerà escludere i type uguali dalla lista dei type di tutte le stanze. Quest'operazione di può effettuare manualmente, ma considerando che in un futuro occorrerebbe riprendere per mano il codice per il solo fatto che viene aggiunto un nuovo tipo di stanza, ci fa capire che é più conveniente un altro metodo che rilevi i vari type ed escluda i doppi filtrandoli. Prenderemo i dati di partenza dalla prop rooms inserita nell'istanza nel RoomsContainer. Quindi passiamo il parametro alla dichiarazione di RoomsFilter:

<code>
export default function RoomsFilter({ rooms }) {
	const context = useContext(RoomContext);
	...
</code>

Poi nel return all'interno del select aggiungeremo una funzione che restituisca solo le unique values, dopo averla dichiarata separatamente. A questa funzione passeremo due parametri: items che sarà l'Array contenente tutti dati, nel nostro caso rooms, e value, che sarà la property per la quale vogliamo ottenere delle value uniche. Nel nostro caso sarà type, ma potrebbe essere anche la capacity e così via. Per ottenere delle unique values useremo qui uno new Set, che per sua natura accetta solamente delle unique values. Inserendo come parametro nel new Set un map sull'Array iniziale che ricavi per ogni element la value, nel nostro caso type, otterremo una serie di types con doppi, che inseriti nel Set verranno non considerati lasciandoci solamente le unique values:

<code>
const getUnique = (items, value) => {
	return [...new Set(items.map((item) => item[value]))];
};
</code>

Chiameremo quindi la funzione salvando le value nella variabile e subito vi aggiungeremo il type "all" per ottenere tutte le values necessarie per gli option elements:

<code>
let types = getUnique(rooms, "type");
	types = ["all", ...types];
	
	return (
		...
</code>

Creiamo direttamente il jsx per inserirlo nel return una volta pronto:

<code>
let types = getUnique(rooms, "type");
	types = ["all", ...types];
	types = types.map((item, index) => {
		return (
			<option value={item} key={index}>
				{item}
			</option>
		);
	});
</code>

Ora possiamo inserire tutte le option ricavate all'interno dell'element select nel return:

<code>
return (
		<section className="filter-container">
			<Title title="search rooms"></Title>
			<form className="filter-form">
				{/* select type */}
				<div className="form-group">
					<label htmlFor="type">room type</label>
					<select
						name="type"
						id="type"
						value={type}
						className="form-control"
						onChange={handleChange}
					>
						{types}
					</select>
				</div>
				{/* end select type */}
			</form>
		</section>
	);
</code>

Selezionando ora otterremo nel console.log:
this is type: select-one, this is name: type, this is value: family

Questo ci farà capire che possiamo quindi ottenere la selezione nel context e da li poi gestirla nell'handleChange function.

Nota: la selezione ritorna sempre sulla value di all perché nello state nel context al momento vi é la value hard coded "all" nella property type.

Ora che abbiamo i dati provenienti dal select con una value passata dall'option selezionato, andremo a gestire tali dati in handleChange, che coglie le properties provenienti dall'event.

Per la maggior parte degli input andrebbe bene cogliere il type, il name e la value come abbiamo gestito finora nella nostra funzione handleChange. Ma per input come i checkbox c'é invece bisogno di cogliere il check. Per questo andiamo a modificare la nostra funzione. Andiamo ad inserire un ternary per determinare la value, per cogliere se il type é un checkbox o no:

<code>
handleChange = (event) => {
		const target = event.target;
		const value = event.type === "checkbox" ? target.checked : target.value;
		const name = event.target.name;
	};
</code>

Ora andremo ad impostare lo state, dove potremo quindi utilizzare delle variabili dinamiche nel nostro object. Andremo ad impostare il setter cogliendo qualunque value sia il name, con [name], e andremo ad assegnargli la value determinata sopra. Ad ogi selezione andrà quindi ad impostarsi lo state tramite setState e si attiverà anche la funzione this.filterRooms, che andremo ora a creare per filtrare la lista delle rooms in RoomsList:

<code>
handleChange = (event) => {
		const target = event.target;
		const value = event.type === "checkbox" ? target.checked : target.value;
		const name = event.target.name;
		this.setState(
			{
				[name]: value
			},
			this.filterRooms
		);
	};
</code>

Cominciamo a modificare la funzione filterRooms utilizzando la property rooms, non sortedRooms che sarà quella ricavata in seguito. Per ricavarla andiamo prima di tutto ad ottenerla dallo state destrutturandolo e poi salviamola in una nuova variabile tempRooms:

<code>
filterRooms = () => {
		let { rooms, type, capacity, price, minSize, maxSize, breakfast, pets } =
			this.state;
		let tempRooms = [...rooms];
	};
</code>

Ora impostiamo un if conditional dove se il type non é uguale ad "all" allora andremo a filtrare le stanze. Qui useremo un filter per indicare di far restituire solo le rooms che concidono con il corrente type (single, family, presidential...):

<code>
filterRooms = () => {
		let { rooms, type, capacity, price, minSize, maxSize, breakfast, pets } =
			this.state;
		let tempRooms = [...rooms];
		if (type !== "all") {
			tempRooms = tempRooms.filter((room) => room.type === type);
		}
	};
</code>

Ora imposteremo lo state per la sola property sortedRooms che sarà uguale al tempRooms ottenuto, o originale nel caso di type "all":

<code>
filterRooms = () => {
		let { rooms, type, capacity, price, minSize, maxSize, breakfast, pets } =
			this.state;
		let tempRooms = [...rooms];
		if (type !== "all") {
			tempRooms = tempRooms.filter((room) => room.type === type);
		}
		this.setState({
			sortedRooms: tempRooms
		});
	};
</code>

In questo modo otterremo una lista di stanze con lo stesso type nel Component RoomsList.

## 23. Hotel Project - RoomsFilter Guests

Per l'input dei Guests andremo a determinare la capacity di una stanza, quante persone al massimo può ospitare.

Andiamo quindi a creare una struttura jsx similare al div precendente, cambiando solo le properties:

<code>
...
{/* end select type */}
				{/* guests type */}
				<div className="form-group">
					<label htmlFor="capacity">guests</label>
					<select
						name="capacity"
						id="capacity"
						value={capacity}
						className="form-control"
						onChange={handleChange}
					>
						{people}
					</select>
				</div>
				{/* end guests type */}
...
</code>

Creiamo quindi la variabile people che passeremo per creare gli elements option del select. Per farlo andiamo ad utilizzare nuovamente la funzione creata getUnique per ottenere solo values uniche attraverso un Set e passiamo come parametri lo stesso Array rooms e capacity come secondo parametro:

<code>
	let people = getUnique(rooms, "capacity");
</code>

Ora eseguiamo un mapping sull'Array people ottenuto per creare degli elements option dove inserire ogni item ottenuto dal map:

<code>
let people = getUnique(rooms, "capacity");
	people = people.map((item, index) => {
		return (
			<option key={index} value={item}>
				{item}
			</option>
		);
	});
</code>

In questo modo al cambio della value nell'input avremo il problema che la nuova value sarà una string.
Per sistemare questo problema spostiamoci nel context.jsx, dove andremo ad inserire sotto alla destrutturazione dello state nel metodo filterRooms:

<code>
filterRooms = () => {
		let { rooms, type, capacity, price, minSize, maxSize, breakfast, pets } =
			this.state;
		let tempRooms = [...rooms];
		capacity = parseInt(capacity);
		...
}
</code>

Inseriremo poi il filter usando la capacity subito sotto a quello usato per il type:

<code>
filterRooms = () => {
		let { rooms, type, capacity, price, minSize, maxSize, breakfast, pets } =
			this.state;
		let tempRooms = [...rooms];
		capacity = parseInt(capacity);

    	// filter by type
    	if (type !== "all") {
    		tempRooms = tempRooms.filter((room) => room.type === type);
    	}
    	// filter by capacity
    	if (capacity !== 1) {
    		tempRooms = tempRooms.filter((room) => room.capacity >= capacity);
    	}

    	this.setState({
    		sortedRooms: tempRooms
    	});
    };

</code>

Qui quindi se la capacity é uguale ad uno, l'Array non verrà toccato e verrà restituita l'intera lista di rooms, se invece fosse maggiore di uno i risultati verrano filtrati per un valore maggiore od uguale a quello inserito come option del select.

## 24. Hotel Project - RoomsFilter Price

Per il Room Price andremo a variare dagli scorsi due input, creeremo un range con uno Slider per indicare la fascia di prezzo.

Creiamo quindi un nuovo div per il room price sottostante al div per i guests. Qui inseriremo una label ed un imput con properties:
• type = range - per creare uno slider
• name = price - per la label
• min = minPrice - un valore minimo, per questo abbiamo un minPrice
• max = maxPrice - un valore massimo, per questo abbiamo un maxPrice
• id = price - usato con la label
• value = price - il prezzo che abbiamo effettivamente dallo state
• onChange - handleChange - event handler che funziona con la stessa funzione usata in precedenza

<code>
...
{/* end guests */}
				{/* room price */}
				<div className="form-group">
					<label htmlFor="price">price ${price}</label>
					<input
						type="range"
						name="price"
						min={minPrice}
						max={maxPrice}
						id="price"
						value={price}
						onChange={handleChange}
						className="form-control"
					/>
				</div>
{/* end room price */}
...
</code>

La value massima che si imposterà nel range input sarà data dal prezzo massimo di una stanza nell'Array room, 600.

Ora dobbiamo aggiornare il metodo filterRooms nel context.jsx e sistemare, com'é stato per lo scorso input, il type dei dati convertendolo in numbers, visto che al cambio di value usando il range input, questa diviene una string.
Torniamo quindi al context.jsx nel method filterRooms prima utilizziamo il parseInt sul price e poi aggiungiamo sotto all'ultimo if conditional by capacity un riassegnamento alla variabile tempRooms con un nuovo filter. Qui in pratica saltiamo l'if statement per filtrare direttamente l'Array di stanze secondo il price. Qui sfrutteremo il price, che é il massimo, per avviare un filter quando il room.price diviene inferiore a questo, quindi ha subito una modifica:

<code>
filterRooms = () => {
		let { rooms, type, capacity, price, minSize, maxSize, breakfast, pets } =
			this.state;
		let tempRooms = [...rooms];
		capacity = parseInt(capacity);
		price = parseInt(price);

    	// filter by type
    	if (type !== "all") {
    		tempRooms = tempRooms.filter((room) => room.type === type);
    	}
    	// filter by capacity
    	if (capacity !== 1) {
    		tempRooms = tempRooms.filter((room) => room.capacity >= capacity);
    	}
    	// filter by price
    	tempRooms = tempRooms.filter((room) => room.price <= price);

    	// change state
    	this.setState({
    		sortedRooms: tempRooms
    	});
    };

</code>

In questo modo possiamo filtrare i risultati nella RoomsList in base al price impostato nel range input.

## 25. Hotel Project - RoomsFilter Size, Breakfast and Pets

Ora capiamo come filtrare i risultati in base ad una size massima e minima oltre che alla colazione inclusa o meno o l'ospitalità ad animali domestici inclusa o meno.

Cominciamo aggiungendo un nuovo div, similarmente a quanto fatto in precedenza, sotto a quello per il room price, con una label ed un ulteriore div al suo interno.
All'interno di quest'ultimo div inseriremo due input, uno per la minSize e l'altro per la maxSize:

<code>
...
{/* end room price */}
				{/* size */}
				<div>
					<label htmlFor="size">room size</label>
					<div className="size-inputs">
						<input
							type="number"
							name="minSize"
							id="size"
							value={minSize}
							onChange={handleChange}
							className="size-input"
						/>
						<input
							type="number"
							name="maxSize"
							id="size"
							value={maxSize}
							onChange={handleChange}
							className="size-input"
						/>
					</div>
				</div>
				{/* end of size */}
</code>

Aggiungiamo poi un ulteriore div per gli extras, il breakfast ed i pets. Questo conterrà due div con all'interno un input, uno per ogni extra. Subito sotto all'input vi sarà una label. Gli input avranno type checkbox name associato alla label e, a differenza degli altri input che avevano un name, una property checked, che sostituirà appunto name e avrà la value associata dallo state:

<code>
{/* end of size */}
				{/* extras */}
				<div className="form-group">
					<div className="single-extras">
						<input
							type="checkbox"
							name="breakfast"
							id="breakfast"
							checked={breakfast}
							onChange={handleChange}
						/>
						<label htmlFor="breakfast">breakfast</label>
					</div>
					<div className="single-extras">
						<input
							type="checkbox"
							name="pets"
							id="pets"
							checked={pets}
							onChange={handleChange}
						/>
						<label htmlFor="pets">pets</label>
					</div>
				</div>
				{/* end of extras */}
</code>

Ora che abbiamo creato questo setup nel jsx andiamo a implementare il tutto nel context.jsx.

Partiamo dal filtrare per un valore che sia maggiore della minSize e minore della minSize, subito sotto al filter del price nel metodo filterRooms:

<code>

    	// filter by price
    	tempRooms = tempRooms.filter((room) => room.price <= price);

    	// filter by size
    	tempRooms = tempRooms.filter(
    	(room) => room.size >= minSize && room.size <= maxSize
    	);

</code>

Ora aggiungeremo il filter per il breakfast ed i pets subito sotto a quello appena scritto:

<code>
// filter by breakfast
		if (breakfast) {
			tempRooms = tempRooms.filter((room) => room.breakfast === true);
		}

    	// filter by pets
    	if (pets) {
    		tempRooms = tempRooms.filter((room) => room.pets === true);
    	}

</code>

Nota: O semplicemente if (pets) {
tempRooms = tempRooms.filter((room) => room.pets);
}

Con questo abbiamo completato la parte di filtering e la Page Rooms.

## 26. Hotel Project - Local data and Hosting

Adesso ci si presentano davanti una serie di problemi dovuti al fatto dell'accessibilità dei dati nel caso di un Hosting del sito. Questo diventa immediatamente chiaro nel caso si volesse aggiungere una room alla lista, con relative images, da aggiungere poi a data.jsx ecc.

Sarebbe nettamente migliore la situazione se vi fosse una risorsa esterna dove andremo ad impostare i nostri dati, separatamente dal progetto.

Per questo come detto in precedenza useremo Contentful.com.
Questo é di preciso un headless CMS.

Per connetterci a ContentFul useremo l'API dedicata con API key e url.

Aggiungiamo ai dati come spiegato più stanze possibili.

NOTA: Aggiungere altre stanze

## 27. Hotel Project - Data from ContentFul

Ora otteniamo i dati da ContentFul. Andiamo ad installare il package per contentful con npm e poi andiamo ad analizzare la documentazione per JavaScript, precisamente il metodo getEntries, quello di cui abbiamo bisogno.

Per prima cosa andremo a importare contentful con il require.
Poi creeremo una const client con il metodo contenful.createClient(). Questo metodo avrà come parametro un object con due properties: lo space usato su ContentFul e l'accessToken.

Aggiorniamo però il codice ad ES6 importando il package con un import.
Per farlo creiamo un nuovo file, Contentful.jsx.

Fatto questo inseriamo l'export default createClient() al quale passeremo come parametro l'object sopra descritto:

<code>
import { createClient } from "contentful";

export default createClient({
space: "ds5net672qjd",
accessToken: "zkDp_1nZ90TjNmQz9NUX-ifkp2nuxffgwY0x_ILYdEs"
});

</code>

I valori per le due properties dell'object si trovano in ContentFul.com nei Settings --> API Keys --> Accedere al set di dati al quale si vuole connettersi --> usare le value di "spaces" e "Content Delivery API - access token".

Nota: prima di publicare su GitHub questo progetto occorrerà prima creare le Environment Variables.

Ora passiamo al context.jsx. Importiamo ciò che viene esportato in contentFul.jsx come Client:

<code>
import Client from "./Contentful";
</code>

Ora possiamo usare i metodi forniti dal package. Quelli che useremo di più saranno getEntries e getEntry, nello specifico per ottenere tutte le entries o una singola.

Partiamo con getEntries. Utilizziamo il metodo ricevendo una Promise come risposta e per ora usando il then per gestirla:

<code>
Client.getEntries().then((response) => console.log(response));
</code>

Testiamo così se vediamo i dati.
Per filtrare i dati a solo una Collection o Content Model usiamo l'id di tale Content Model. Lo inseriremo come value di una property content_type in un object come parametro del metodo getEntries:

<code>
Client.getEntries({
	content_type: "exampleReactHotelProject"
}).then((response) => console.log(response));
</code>

Ora che abbiamo i nostri dati, ristrutturiamo la nostra App.
Scriveremo la funzione nominata nella parte iniziale del tutorial: getData. Questo sempre all'interno del context.jsx.

Muoveremo tutte le funzionalità della funzione componentDidMount all'interno della funzione getData e poi in componentDidMount andremo a eseguire quest'ultima funzione.

La funzione sarà asincrona, in modo da usare un async await ed un try catch per cogliere anche eventuali errori.
Inseriremo una variabile response con il codice scritto sopra, il metodo getEntries di Client da ContentFul:

<code>
getData = async () => {
		try {
			let response = await Client.getEntries({
				content_type: "exampleReactHotelProject"
			});
		} catch (error) {
			console.log(error);
		}
	};
</code>

Ora inseriamo il contenuto di componentDidMount modificando il primo parametro da items a response.items:

<code>
getData = async () => {
		try {
			let response = await Client.getEntries({
				content_type: "exampleReactHotelProject"
			});
			let rooms = this.formatData(response.items);
			let featuredRooms = rooms.filter((room) => room.featured === true);

    		let maxPrice = Math.max(...rooms.map((item) => item.price));
    		let maxSize = Math.max(...rooms.map((item) => item.size));

    		this.setState({
    			rooms: rooms,
    			sortedRooms: rooms,
    			featuredRooms: featuredRooms,
    			loading: false,
    			price: maxPrice,
    			maxPrice,
    			maxSize
    		});
    	} catch (error) {
    		console.log(error);
    	}
    };

</code>

Facciamo poi eseguire la funzione a componentDidMount:

<code>
componentDidMount() {
		this.getData();
	}
</code>

Ed ora disponiamo dei dati attivi sull'App che, considerando la struttura scritta in precedenza, gestisce allo stesso modo dei dati locali anche quelli esterni da ContentFul senza errori.

Un ulteriore cosa che possiamo modificare é l'ordine di visualizzazione delle rooms, ma attraverso il parametro order proveniente da ContentFul.
Questa sarà una property passata all'object parametro di getEntries, assieme a content_type:

<code>
let response = await Client.getEntries({
				content_type: "exampleReactHotelProject",
				// order: "sys.createdAt",
				// order: "fields.price",
				order: "-fields.price"
			});
</code>

## 28. Hotel Project - Deploy

Publicheremo il nostro progetto su GitHub ed inseguito il Deploy su Netlify.

Prima di questo però sposteremo le string delle API Keys su delle Environment variables.

Creiamo quindi il file .env.development e quello .gitignore che escluda il .env dal versionamento.
Nel file .env.development andiamo a creare le variabili con relative value:
<code>
REACT_APP_API_SPACE=xxxxxxxxxx
REACT_APP_ACCESS_TOKEN=xxxxxxxxxxxxxxx
</code>

Modifichiamo quindi il file Contentful.jsx per utilizzare le environment variables:

<code>
import { createClient } from "contentful";

export default createClient({
space: import.meta.env.VITE_REACT_APP_API_SPACE,
accessToken: import.meta.env.VITE_REACT_APP_ACCESS_TOKEN
});

</code>

Fatto questo creiamo la Repo su GitHub e publichiamo il sito con la solita procedura.

Andiamo su Netlify e clickiamo Add new site --> import an existing Project --> Git --> selezioniamo il progetto.

Ora nella schermata occorre creare manualmente le Environment Variables come sul file.

Nota: il file env dev'essere nominato env.development per funzionare correttamente.

Ora il progetto é finito e publicato su Netlify:

https://react-hotel-project-icarus.netlify.app/

# Sesta parte - Projects - React LinkedIn Clone

## 1. LinkedIn Clone - Introduction

Questo progetto consiste nella creazione di clone di LinkedIn, usando React.js per lo sviluppo e Firebase per il Database utenti e l'Hosting del sito finale.

In questo progetto sarà possibile registrarsi, publicare dei post, modificarli e cancellarli. Inoltre sarà possibile connettersi con altri utenti registrati, vedere il profilo di ogni utente e altro.

## 2. LinkedIn Clone - The Base Setup

Inizializziamo il progetto con Vite ed installiamo con npm install i packages di base. Creiamo poi un nuovo progetto su Firebase, configuriamo per una Web App, installiamo i packages necessari, creiamo poi un nuovo file firebaseConfig.jsx, dove andremo a copiare il contenuto proposto da Firebase:

<code>
import { initializeApp } from "firebase/app";

const firebaseConfig = {
apiKey: "AIzaSyCb1aia5WTXhgV6a69rT3LZSDvQQN4Vxy4",
authDomain: "linkedin-clone-icarus.firebaseapp.com",
projectId: "linkedin-clone-icarus",
storageBucket: "linkedin-clone-icarus.appspot.com",
messagingSenderId: "1015617473473",
appId: "1:1015617473473:web:c9948666188059166bbd40"
};

const app = initializeApp(firebaseConfig);

</code>

Esportiamo quindi l'ultima costante app:

<code>
export const app = initializeApp(firebaseConfig);
</code>

Sistemata rapida ad index.css.

Ora spostiamoci nella cartella src del nostro progetto.
Qui creeremo gli endpoint per il login ed il register alla nostra App.
Creeremo quindi una cartella api, con all'interno un Component AuthAPI.jsx con all'interno una funzione per ora solamente:

<code>
export const LoginAPI = () => {
  
} 
</code>

Creiamo una cartella pages, con una Page dedicata alla funzione appena creata che chiameremo Login.jsx.
Creiamo al suo inteno un Functional Component:

<code>
import React from "react";

export default function Login() {
return <div>login</div>;
}

</code>

Creiamo ora una cartella components, dove creeremo un Component LoginComponent.jsx.
Qui creeremo un Functional Component:

<code>

export default function LoginComponent() {
return (

<div>
<h1>LoginComponent</h1>
</div>
);
}

</code>

Importiamo ora il Component LoginComponent all'interno della page Login.jsx, e renderizziamolo nel return.

Passiamo ora all'installazione del package di react-router-dom.
Questa volta seguiremo la documentazione con questo tutorial.

Importiamo in main.jsx:

<code>
import { createBrowserRouter, RouterProvider } from "react-router-dom";
</code>

Creiamo ora una cartella routes, dove creeremo un file index.jsx.
In questo file andremo a creare il nostro router, da documentazione:

<code>
import { createBrowserRouter } from "react-router-dom";

export const router = createBrowserRouter([
{
path: "/",
element: <div>Hello world!</div>
}
]);

</code>

Andremo ad impostare quindi come prima pagina principale la pagina di Login creata in precedenza:

<code>
import { createBrowserRouter } from "react-router-dom";
import Login from "../pages/Login";

export const router = createBrowserRouter([
{
path: "/login",
element: <Login />
}
]);

</code>

Andiamo ad importare ora il router appena creato in main.jsx:
<code>
import { router } from "./routes";
</code>

E andiamo a sostituire l'istanza del Component App.jsx con un RouterProvider con property router e value relativa al nostro router appena creato:

<code>
import React from "react";
import ReactDOM from "react-dom/client";
import { RouterProvider } from "react-router-dom";
import { router } from "./routes";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
<React.StrictMode>
<RouterProvider router={router} />
</React.StrictMode>
);

</code>

Facciamo questo perché tutta la logica del progetto non passerà più da App.jsx ma dal router e gli altri Component ad esso relativi.

Nota: Per provare l'App adesso dovremo andare in localhost/login, visto che la route basica "/" non é ancora stata impostata.

Cancelliamo quindi i relativi file App.jsx e App.css.

Passiamo ora al LoginComponent.jsx, dove andremo ad importare il Component LoginAPI e creeremo un button:

<code>
import { LoginAPI } from "../api/AuthAPI";

export default function LoginComponent() {
return (

<div>
<h1>LoginComponent</h1>
<button className="login-btn">Log In to LinkedIn</button>
</div>
);
}
</code>

Per dare uno style a questo nuovo button, andremo ad installare per la prima volta sass.

Andiamo a creare una cartella sass con all'interno un file LoginComponent.scss.
Importiamo tale file in LoginComponent.jsx.
<code>
import "../sass/LoginComponent.scss";
</code>

Scriviamo un CSS di base in LoginComponent.scss:
<code>
.login-btn {
width: 150px;
height: 30px;
}

</code>

Ora in LoginComponent.jsx andremo ad effettuare una chiamata alla LoginAPI e per farlo creeremo una funzione che chiameremo poi nell'Event Handler onClick nel button:

<code>
export default function LoginComponent() {
	const login = () => {
		LoginAPI();
	};
	return (
		<div>
			<h1>LoginComponent</h1>
			<button onClick={login} className="login-btn">Log In to LinkedIn</button>
		</div>
	);
}
</code>

Altre modifiche CSS.

Andiamo ora a creare il corpo del Functional Component AuthAPI.jsx la cui funzione che viene chiamata qui nel Component.
Questo Functional Component avrà al suo interno uno snippet di codice che andremo a prendere in Firebase.com su Authentication --> Inizia --> Login and password e abilitiamolo.

Nel file AuthAPI.jsx andiamo ad importare i componenti per il Login con email e password, salviamo in una variabile la chiamata a getAuth proveniente da questi import:

<code>
import { signInWithEmailAndPassword, getAuth } from "firebase/auth";

let auth = getAuth();

export const LoginAPI = () => {};

</code>

La variabile auth ora conterrà tutti i parametri da firebaseConfig.jsx, dopo aver importato il file nel main.jsx.
Possiamo quindi chiamare il metodo signInWithEmailAndPassword:

<code>
let auth = getAuth();

export const LoginAPI = () => {
signInWithEmailAndPassword();
};
</code>

Qui ora dovremo passare i nostri dati di login come parametri:

<code>
import { signInWithEmailAndPassword, getAuth } from "firebase/auth";

let auth = getAuth();

export const LoginAPI = (email, password) => {
signInWithEmailAndPassword(auth, email, password);
};

</code>

Attenzione: taglio nel tutorial, modifiche ad AuthAPI.jsx:

<code>
import { signInWithEmailAndPassword, getAuth } from "firebase/auth";

let auth = getAuth();

export const LoginAPI = (email, password) => {
try {
signInWithEmailAndPassword(auth, email, password);
} catch (error) {
console.log(error);
}
};

</code>

Torniamo ora in LoginComponent.jsx. Creiamo degli input fields nel jsx:

<code>
export default function LoginComponent() {
	const [credentials, setCredentials] = useState({});
	const login = () => {
		LoginAPI(credentials.email, credentials.password);
	};
	return (
		<div>
			<h1>LoginComponent</h1>
			<div className="auth-inputs">
				<input
					className="common-input"
					type="email"
					placeholder="Enter your email"
					onChange={(event) =>
						setCredentials({ ...credentials, email: event.target.value })
					}
				/>
				<input
					className="common-input"
					type="password"
					placeholder="Enter your password"
					onChange={(event) =>
						setCredentials({ ...credentials, password: event.target.value })
					}
				/>
			</div>
			<button onClick={login} className="login-btn">
				Log In to LinkedIn
			</button>
		</div>
	);
}
</code>

Qui abbiamo creato degli input per email e password, creato uno state "credentials" e, dopo averla importata, chiamata la funzione LoginAPI passandole due parametri, credentials.email e credentials.password.

NOTA: tutorial confuso in questo momento.

Spostiamoci su AuthAPI.jsx e creiamo un nuovo Component, RegisterAPI.
Questo sarà molto similare al precendente LoginAPI, ma chiameremo al suo interno createUserWithLoginAndPassword:

<code>

</code>

Da ultimare: tutorial a tratti incomprensibile.

# Settima parte - Documentation - react.dev/learn

## 1. Documentation - Describing the UI

React.js é una libreria JavaScript per renderizzare User Interfaces (UI). Le UI sono costituite da piccole unità come buttons, text, images e altro. React ti permette di combinarle in Components riusabili e annidabili. Dai web sites alle App per mobile, tutto sullo schermo può essere suddiviso in Components.

### 1. Documentation - Describing the UI - Your first component

Le Applicazioni React sono costruite da pezzi isolati di UI chiamati Components. Un Component React é una funzione JavaScript che può essere cosparsa con il markup.

I Components possono essere piccoli come buttons o grandi come intere Pages.

<code>

function Profile() {
return (
<img src="https://i.imgur.com/MK3eW3As.jpg"
      alt="Katherine Johnson"/>
)
}

export default function Gallery() {
return (

<section>
<h1>Amazing Scientists</h1>
<Profile />
<Profile />
<Profile />
</section>
);
}

</code>

### 2. Documentation - Describing the UI - Importing and exporting components

Si possono dichiarare molti components in un singolo file, ma i file di grandi dimensioni possono risultare di difficile navigazione. Per risolvere questo problema si può esportare (export) un Component in un file proprio, e poi importare (import) tale Component in un altro file

### 3. Documentation - Describing the UI - Writing markup with JSX

Ogni Component React é una funzione JavaScript che può contenere del markup che React renderizza nel browser. I Components React usano un'estensione sintattica (syntax extension) chiamata JSX che reppresenta tale markup. Il JSX somiglia molto all'HTML, ma é più stricter (rigoroso / severo / preciso / ferreo) e può visualizzare informazioni dinamiche.

Se si incolla del markup HTML preesistente in un Component React, non sempre funzionerà.

Come strumenti per la conversione si possono usare dei Converter (non consigliato).

### 4. Documentation - Describing the UI - JavaScript in JSX with curly braces

JSX permette di scrivere del markup simile all'HTML dentro ad un file JavaScript, mantenendo la logica di rendering e il content nello stesso posto. A volte vogliamo aggiungere della logica JavaScript o riferirci a proprietà dinamiche dentro al markup. In questa situazione possiamo usare le parentesi grafe { } nel JSX per "aprire una finestra" a JavaScript.

### 5. Documentation - Describing the UI - Passing props to a component

I Components React usano le props per cominicare tra loro. Ogni Component parent può passare delle informazioni ai suoi components child dando loro delle prop. Le prop possono ricordare degli attributi HTML, ma si può passare ogni value JavaScript attraverso queste, inclusi objects, array, funzioni e persino altro JSX.

### 6. Documentation - Describing the UI - Conditional Rendering

I Components hanno spesso bisogno di visualizzare cose diverse in base a diverse condizioni. In React si può renderizzare condizionalmente del JSX usando le sintassi come gli if statements, && e ternary operators ? : .

### 7. Documentation - Describing the UI - Rendering lists

Spesso si vorrà visualizzare molteplici Components similari da una collezione di dati. Si possono usare le Higher Order Functions di JavaScript come filter e map con React per filtrare e trasformare un array di dati in un array di Components.

Per ogni item dell'array ci sarà bisogno di specificare una "key". Di solito é prassi usare un ID da un database come key. Le key permettono a React di tenere traccia di ogni posto di un item nella lista persino se la lista cambia.

### 8. Documentation - Describing the UI - Keeping components pure

Alcune funzioni JavaScript sono pure, altre no.
Una funzione pura:
• si occupa dei propri affari. Non cambia nessun object o variabile che esisteva prima che fosse chiamata.
• stesso input stesso output. Dati gli stessi input, una funzione pura dovrebbe sempre restituire lo stesso risultato.

Scrivendo i Components rigorosamente come funzioni pure, si possono evitare un'intera categoria di bug e comportamenti imprevedibili mano a mano che il codice cresce.

Si può rendere un Component puro passando una prop invece che modificando una variabile preesistente.

## 2. Your First Component

I Components sono uno dei concetti chiave di React.js. Sono le fondamenta sulle quali si costruirà la UI, che li rende il posto perfetto per cominciare.

### 2.1 Components: UI building blocks

Nell'HTML vi sono dei documents con una struttura ricca e variegata.

A differenza delle App web tradizionali dove tutto é più separato, React permette di combinare il markup, il CSS e JavaScript in Components personalizzati, degli elements della UI riusabili per l'App.

Come per i tag HTML, si possono comporre, ordinare e annidare Components per disegnare intere pagine.

Più il progetto cresce più si noterà che per vari design si potranno riutillizzare i Components già scritti per comporli, velocizzando lo sviluppo.

### 2.2 Components: Defining a component

Un Component React é una funzione JavaScript che può essere innestata con il markup.

<code>
export default function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3Am.jpg"
      alt="Katherine Johnson"
    />
  )
}
</code>

Ecco come costruire un Component:

• 1 - Esporta il component - il prefisso export default é standard JavaScript syntax - permette di marcare la funzione principale in un file così da importarla in altri file.

• 2 - Definisci una funzione - con function Profile(){} si definisce una funzione con il name di Profile

Nota: Il name di un Component deve cominciare con una maiuscola, altrimenti non funzioneranno anche se sono funzioni JavaScript a tutti gli effetti.

• 3 - Aggiungi il markup - anche se viene restituito un tag HTML, questo é JavaScript. Questa sintassi é detta JSX.
Il markup può essere scritto dopo il return in una sola riga o in molteplici, contenuto tra parentesi tonde.

### 2.3 Components: Using a component

Una volta definito il Component può essere annidato in altri Components.

<code>

function Profile() {
return <img src="https://i.imgur.com/MK3eW3Am.jpg" alt="Katherine Johnson" />;
}

export default function Gallery() {
return (

<section>
<h1>Amazing Scientists</h1>
<Profile />
<Profile />
<Profile />
</section>
);
}

</code>

Cosa vede il browser? Si notino le differenze dei casi:

• <section></section> é lowercase, quindi react sa che ci riferiamo ad un tag HTML.
• <Profile /> comincia con una Capitol Letter P, quindi React sa che vogliamo usare un nostro Component chiamato Profile, che contiene altri tag HTML e così via.

### 2.4 Components: Nesting and organizing components

Quando si hanno piccoli components o strettamente legati tra loro possono essere mantenuti nello stesso file, ma quando il file cresce é meglio dividere tutto in file separati.

Nell'esempio precedente visto che i Components Profile vengono renderizzati all'interno di quello Gallery, possiamo dire che Gallery é un parent Component, che renderizza ogni Profile come un "child".

Questa é una parte fondamentale di JavaScript, si possono definire i Components una volta e poi usarli in molti posti tutte le volte che vogliamo.

Nota: I Components possono renderizzare altri Components, ma non si possono mai annidare le loro dichiarazioni.
Quando un component necessita di dati da un parent, si passano attraverso le prop, non si annidano le dichiarazioni.

## 3. Importing and Exporting Components

La magia dei Components risiede nella loro riusabilità. Si possono anche creare Components che sono composti da altri Components. Ma più Components si annidano, più ha senso dividerli in file differenti. Fare questo permette di mantenere i file facili da leggere velocemente e riusare i Components in più posti.

### 3.1. The root component file

Tutti i Components generalmente, tranne casi specifici come per esempio in Next.js o altri, vivono in un root Component file chiamato App.js o App.jsx.

### 3.2. Exporting and importing a component

E' sempre sensato muovere i Components fuori dal file root, cioé scriverli in file separati. Se volessimo riutilizzarli altrove, altrimenti non potremmo.

Per muovere un Component:
• creare un nuovo file js o jsx ed inserirvi il codice del Component
• export della funzione della dichiarazione del Component con export default
• import di tale Component nel file dove lo si userà, con import di default o named.

<code>
In App.jsx

import React from "react";

import Gallery from "./components/Gallery";

function App() {
return (

<div className="App">
{/_ 2.2 _/}
<Gallery />
</div>
);
}

In Gallery.jsx

function Profile() {
return <img src="https://i.imgur.com/MK3eW3Am.jpg" alt="Katherine Johnson" />;
}

export default function Gallery() {
return (

<section>
<h1>Amazing Scientists</h1>
<Profile />
<Profile />
<Profile />
</section>
);
}

</code>

L'esempio qui riportato é diviso in due file Components ora.

Nota: come sappiamo i file js/jsx si possono importare senza indicarne l'estensione.
Un file non può avere più di un export default, ma può avere quanti named exports si desiderino.

Sintassi export default:

export dafault function Button(){}
import Button from "..Button.js"

Sintassi export named:

export function Button(){}
import {Button} from "..Button.js"

Quando si scrive un import di default si può usare qualsiasi name di voglia dopo l'import.
Quando si scrive un named import il nome DEVE corrispondere da entrambi i lati, da qui il nome named imports.

Solitamente si usa il default export se il file esporta solo un Component, mentre se si esportano molteplici Components e values si usano i named exports.

Dare sempre nomi con significato, evitare Components senza name.

### 3.3. Exporting and importing multiple components from the same file

Partendo dall'esempio precedente se volessimo esportare anche il Component Profile oltre che Gallery dovremmo quindi usare i named exports invece che uno di default, visto che si possono avere molteplici named exports in un file.

Nota: per ridurre la confusione spesso si sceglie di usare o un tipo o un altro o almeno di non mixarli nello stesso file.

<code>
In Gallery.jsx:

export function Profile() {
return <img src="https://i.imgur.com/MK3eW3Am.jpg" alt="Katherine Johnson" />;
}

export default function Gallery() {
return (

    <section>
    <h1>Amazing Scientists</h1>
    		<Profile />
    		<Profile />
    		<Profile />
    </section>

);
}

In App.jsx:

import Gallery from "./components/Gallery";
import { Profile } from "./components/Gallery";

function App() {
return (

    <div className="App">
    		<Gallery />
    		<Profile />
    </div>
    );

}

export default App;

</code>

Ora Gallery.jsx possiede due exports, uno di dafault e un named.

## 4. Writing Markup with JSX

JSX é un'estensione per JavaScript che permette di scrivere un markup simile all'HTML dentro ad un file JavaScript. Anche se vi sono altri modi per scrivere dei Components, la maggior parte degli sviluppatori React preferisce la brevità del JSX, e la maggior parte delle codebase la usa.

### 4.1. JSX: Putting markup into JavaScript

Per molti anni la struttura delle pagine web é rimasta invariata con content nell'HTML, design nel CSS e logica in JavaScript, spesso in file separati.

Ma visto che il web é divenuto più interattivo la logica ha aumentato la determinazione del content. JavaScript ha sovrastato HTML. Per questo motivo in React il rendering della logica e del markup vivono insieme nello stesso posto, i Components.

Mantenere la logica di un Button e il suo markup assieme assicura che resteranno sincronizzati tra loro. Allo stesso modo i dettagli che non sono relazionati come il markup di un Button ed il markup di una Sidebar, sono isolati gli uni dagli altri, rendendoli più sicuri nei cambiamenti.

Ogni Component React é una funzione JavaScript che può contenere del markup che React renderizzerà nel browser. I Components React utilizzano un'estensione sintattica chiamata JSX per rappresentare tale markup. JSX somiglia molto ad HTML, ma é più rigoroso e può visualizzare informaziono dinamiche.

Nota: JSX e React sono due cose separate. Sono spesso usate insieme ma possono essere usate indipendentemente.
JSX é un'estensione sintattica, mentre React.js é una library JavaScript.

### 4.2. Converting HTML to JSX

Spesso il copia incolla diretto di HTML in un Component non funziona. Occorre rispettare alcune regole rispetto all'HTML.

Nota: Molte volte si riesce a cogliere gli errori dai messaggi in console.

### 4.3. The Rules of JSX

- Restituire un singolo root element
  Per restituire molteplici elements da un Component occorre avvolgerli in un singolo tag parent, come per esempio un div o un Fragment, un tag vuoto. Un Fragment permette di raggruppare degli elements senza lasciare traccia nell'HTML tree.

  Nota: perché vi é la necessità di avvolgere tutto in una singola root?
  JSX sembra HTML ma in realtà viene trasformato in un object JavaScript. Non si possono restituire due objects da una funzione senza avvolgerli in un Array.

- Chiudere tutti i tag
  JSX necessita che tutti i tag siano chiusi esplicitamente, sia quelli normali che i self-closing come img dev'essere <img />.

- camelCase in quasi ogni caso
  Il JSX si trasforma in JavaScript e gli attributes scritti in JSX si trasformano in keys di objects JavaScript. Di solito nei propri Components vogliamo leggere tali attributes nelle variabili. I nomi quindi hanno delle limitazioni, per esempio non possono contentere trattini, punti o parole riservate come class o extends. Per questo in React gli attributi HTML e SVG sono scritti in camelCase.

  Nota: per ragioni storiche gli attributi aria-_ e data-_ sono scritti come nell'HTML con i trattini.

### 4.4. Pro-Tip: Use a JSX Converter

Si possono usare dei converter per tradurre da HTML e SVG esistente a JSX.

### 4.5. Exercises

Sistemare il codice in modo che sia JSX valido:
<code>

</code>

<code>
export default function Bio() {
  return (
    <>
    <div className="intro">
      <h1>Welcome to my website!</h1>
    </div>
    <p className="summary">
      You can find my thoughts here.
      <br /><br />
      <b>And <i>pictures</i></b> of scientists!
    </p>
    </>
  );
}

</code>

Corretto :white_check_mark:

## 5. JavaScript in JSX with Curly Braces

JSX permette di scrivere del markup simile ad HTML dentro ad un file JavaScript, mantenendo la logica di rendering ed il content nello stesso posto. A volte si vuole aggiungere della logica JavaScript o una reference ad una property dinamica dentro al markup. In questa situazione useremo le parentesi grafe { } nel JSX per aprire una porta a JavaScript.

### 5.1. Passing strings with quotes

Quando si vuole passare un attribute string al JSX, basta inserirli in singole o doppie quotes:

<code>
export default function Avatar() {
  return (
    <img
      className="avatar"
      src="https://i.imgur.com/7vQD0fPs.jpg"
      alt="Gregorio Y. Zara"
    />
  );
}
</code>

Qui le varie values vengono passate come string.

Se si vuole specificare dinamicamente una property basta sostituire la parte della value con le parentesi grafe ed inserire il name della variabile:

<code>
export function Avatar() {
	const avatar = "https://i.imgur.com/7vQD0fPs.jpg";
	const description = "Gregorio Y. Zara";
	return <img className="avatar" src={avatar} alt={description} />;
}
</code>

### 5.2. Using curly braces: A window into the JavaScript world

Il JSX é un modo particolare di scrivere del codice JavaScript, ciò significa che é possibile usare il codice JavaScript dentro a questo usando le parentesi grafe {}.

<code>
export function TodoList() {
	const name = "Gregorio Y. Zara";
	return <h1>{name}'s To Do List</h1>;
}
</code>

Cambiando la value della variabile name qui, cambierà anche ciò che verrà renderizzato e visualizzato.

Dentro alle parentesi grafe {...} funziona qualunque espressione JavaScript, incluse le chiamate alle funzioni:

<code>
const today = new Date();

function formatDate(date) {
return new Intl.DateTimeFormat("en-US", { weekday: "long" }).format(date);
}

export function TodoList() {
const name = "Gregorio Y. Zara";
return (

<h1>
{name}'s To Do List for {formatDate(today)}
</h1>
);
}
</code>

### 5.3. Where to use curly braces

Si possono usare le curly braces solamente in due modi dentro al JSX:

- Come text direttamente dentro un tag JSX il codice <h1>{name}'s To Do List</h1> funzionerà, questo <{tag}>Gregorio Y. Zara's To Do List</{tag}> non funzionerà.

- Come attribute immediatamente dopo il segno di uguale, come src={avatar} che leggerà la variabile avatar, ma src="{avatar}" passerà solamente la string "{avatar}".

### 5.4. Using "double curlies": CSS and other objects in JSX

Oltre a strings, numbers e altre espressioni JavaScript, si possono passare anche objects nel JSX. Gli objects sono indicati con le le parentesi grafe, come {firstname: "Alex", lastname: "Valente"}. Quindi per passare un object JavaScript al JSX occorre avvolgere tale object in un altro paio di parentesi grafe: person={{firstname: "Alex", lastname: "Valente"}}.

Per esempio con del CSS scritto come style inline, a necessità, si userà:

<code>

    export function TodoList() {
    	const name = "Gregorio Y. Zara";
    	return (
    		<>
    			<h1>
    				{name}'s To Do List for {formatDate(today)}
    			</h1>
    			<ul
    				style={{
    					backgroundColor: "black",
    					color: "pink"
    				}}
    			>
    				<li>Improve the videophone</li>
    				<li>Prepare aeronautics lectures</li>
    				<li>Work on the alcohol-fuelled engine</li>
    			</ul>
    		</>
    	);
    }

</code>

Nota: Notare l'uso del camelCase nelle properties nell'object CSS all'interno delle parentesi grafe dell'attribute style.

### 5.5. More fun with JavaScript objects and curly braces

Si possono spostare varie espressioni in un object, e riferirsi ad esse nel JSX attraverso le parentesi grafe:

<code>

const person = {
name: "Gregorio Y. Zara",
theme: {
backgroundColor: "black",
color: "pink"
}
};

export function TodoList() {
return (
<>

<h1>
{person.name}'s To Do List for {formatDate(today)}
</h1>
<ul style={person.theme}>
<li>Improve the videophone</li>
<li>Prepare aeronautics lectures</li>
<li>Work on the alcohol-fuelled engine</li>
</ul>
</>
);
}
</code>

In quest'esempio l'object JavaScript person contiene una string name ed un object theme. Il Component può usare queste values come visto da person (person.name, person.theme).

JSX é un templating language minimale perché lascia organizzare i dati e la logica usando JavaScript.

Esercizio più difficile:

<code>
const baseUrl = 'https://i.imgur.com/';
const person = {
  name: 'Gregorio Y. Zara',
  imageId: '7vQD0fP',
  imageSize: 's',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
return (

<div style={person.theme}>
<h1>{person.name}'s Todos</h1>
<img
        className="avatar"
        src="{baseUrl}{person.imageId}{person.imageSize}.jpg"
        alt={person.name}
      />
<ul>
<li>Improve the videophone</li>
<li>Prepare aeronautics lectures</li>
<li>Work on the alcohol-fuelled engine</li>
</ul>
</div>
);
}

</code>

Soluzione:

<code>
const baseUrl = 'https://i.imgur.com/';
const person = {
  name: 'Gregorio Y. Zara',
  imageId: '7vQD0fP',
  imageSize: 's',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
return (

<div style={person.theme}>
<h1>{person.name}'s Todos</h1>
<img
className="avatar"
src={`${baseUrl}${person.imageId}${person.imageSize}.jpg`}
alt={person.name}
/>
<ul>
<li>Improve the videophone</li>
<li>Prepare aeronautics lectures</li>
<li>Work on the alcohol-fuelled engine</li>
</ul>
</div>
);
}

</code>

Corretto e funzionante, cambia solo uso Template string invece che somma di string.

## 6. Passing Props to a Component

I Components React.js usano le props per comunicare tra loro. Ogni parent Component passa alcune informazioni ai suoi Components child dando loro delle props. Le props potrebbero sembrare degli attributes HTML, ma si può passarvi ogni value JavaScript attraverso questo, inclusi objets, array e funzioni.

### 6.1. Familiar Props

Le props sono informazioni che si passano ad un tag JSX. Alcuni esempi possono essere className, src, alt, width, height...

Le props che si passano ad un tag sono predefinite, ma si possono passare le props che si vogliono ai Components che creiamo noi stessi.

### 6.2. Passing props to a component

Partiamo dal codice senza props:

<code>
export function Profile() {
	return <Avatar />;
}
</code>

Possiamo dare qui ad Avatar delle props in due punti:

- 1: Passare delle props al child Component.
  Prima passiamo delle props ad Avatar. Per esempio, passiamo due props - person (object) e size (number)

  <code>
  	export function ProfileOne() {
  		return (
  			<Avatar person={{ name: "Lin Lanying", imageId: "1bX5QH6" }} size={100} />
  		);
  	}
  </code>

  Ora si possono leggere queste props dentro il Component Avatar

- 2: Leggere le props dentro al child component
  Si possono ora leggere queste props elencando i loro names {person, size} separati da virgola e avvolti in parentesi grafe, inserendoli come parametro nella funzione child, in questo caso Avatar.

    <code>
    function Avatar({ person, size }) {
    	
    }
    </code>

  Ora basta aggiungere della logica nel Component in modo che le props person e size vengano usate per il rendering:

    <code>
    	function Avatar({ person, size }) {
    		return (
    			<img
    				className="avatar"
    				src={getImageUrl(person)}
    				alt={person.name}
    				width={size}
    				height={size}
    			/>
    		);
    	}

        export default function Profile() {
        	return (
        		<>
        			<Avatar
        				size={100}
        				person={{ name: "Katsuko Saruhashi", imageId: "YfeOqp2" }}
        			/>
        			<br />
        			<hr />
        			<Avatar
        				size={80}
        				person={{
        					name: "Aklilu Lemma",
        					imageId: "OKS67lh"
        				}}
        			/>
        			<br />
        			<hr />
        			<Avatar size={50} person={{ name: "Lin Lanying", imageId: "1bX5QH6" }} />
        		</>
        	);
        }

    </code>

  Le props permettono di pensare a parent e child Components indipendetemente.
  Si può modificare person o size dentro a Profile senza pensare a come le userà Avatar. Similarmente si può cambiare come Avatar usa le prop senza considerare Profile.

  Le props sono come gli arguments in una funzione, in effetti sono l'unico argument che un Component accetta, un object props, che prima abbiamo destrutturato nelle due properties dell'object:

    <code>
  function Avatar(props) {
  	let person = props.person;
  	let size = props.size;
  	return (
  		<img
  			className="avatar"
  			src={getImageUrl(person)}
  			alt={person.name}
  			width={size}
  			height={size}
  		/>
  	);
  }
    </code>

Di solito però non si necessita dell'intero object props, quindi destrutturarlo risulta una scelta migliore.
Nota: Ricordare sempre le parentesi grafe nella destrutturazione delle props.

### 6.3. Specifying a default value for a prop

Se si vuole dare ad una prop una value di default da utilizzare in caso di nessuna value specificata, lo si può fare nella destrutturazione inserendo un uguale = e la value di default dopo il parametro:

<code>
function Avatar({ person, size = 100 }) {
	return (
		<img
			className="avatar"
			src={getImageUrl(person)}
			alt={person.name}
			width={size}
			height={size}
		/>
	);
}
</code>

La value di default viene usata solamente se la prop é mancante o viene passata a questa un undefined, ma se si passasse null o 0 la value di default non verrà usata.

### 6.4. Forwarding props with the JSX spread syntax

A volte occorre passare tutte le props ad un Component child, per farlo in modo breve, senza ripetitività, si può usare la spread syntax:

<code>
function Profile(props) {
	return (
		<div className="card">
			<Avatar {...props} />
		</div>
	);
}
</code>

Questo permette di passare tutte le props di Profile ad Avatar senza elencarle singolarmente.
Usare questa tecnica con moderazione, non usarla sempre.

### 6.5. Passing JSX as children

E' abbastanza usuale trovare due tag annidati, ma si può annidare anche un Component all'interno di un altro Component:

<code>
	<Card>
			<Avatar />
	</Card>
</code>

Quando si annida del content in un tag JSX, il parent Component riceverà tale Content in una prop chiamata "children".
Il Component Card qui riceverà una prop children, impostata su Avatar e la renderizzerà all'interno di un div:

<code>
export default function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}
</code>

Questo é un pattern molto flessibile, che permette di leggere le prop dei children dal parent per esempio, senza importare i children nella dichiarazione del parent.

In questo caso si può notare che Card é come se avesse un buco, indicato da children, e il parent di Card, Profile, indica con cosa riempirlo:

<code>
export default function Profile() {
	return (
		<Card>
			<Avatar
				size={100}
				person={{ name: "Katsuko Saruhashi", imageId: "YfeOqp2" }}
			/>
		</Card>
	);
}
</code>

Un esempio comune di uso sono i visual wrappers: panels, grids ecc.

### 6.6. How props change over time

Il Component presentato qui riceverà due props dal suo parent. Questo utilizzerà lo state per accogliere i cambiamenti di color:

<code>
export function Clock({ color, time }) {
	return (
		<>
			<h1 style={{ color: color }}>{time}</h1>
		</>
	);
}
</code>

Cambiano color attraverso un input si otterrà un cambiamento immediato, grazie al rerender dello state. Questo sta ad illustrare che un Component può ricevere differenti props nel tempo. Le props non sono sempre statiche.

Comunque le props sono immutabili. Quando un Component ha bisogno di cambiare le sue prop, per esempio in risposta ad un'interazione dell'utente o per nuovi dati, dovrà richiedere al parent Component di passare differenti props, un nuovo object. Le vecchie prop saranno messe da parte e il JavaScript engine libererà la memoria ad esse dedicate.

Non si deve cambiare le prop in arrivo, per rispondere ad un input dell'utente vi é la necessità di usare il "set state", la funzione setter dello state.

### 6.7. Challanges

1- Estrarre un Profile da:

<code>
export default function Gallery() {
  return (
    <div>
      <h1>Notable Scientists</h1>
      <section className="profile">
        <h2>Maria Skłodowska-Curie</h2>
        <img
          className="avatar"
          src={getImageUrl('szV5sdG')}
          alt="Maria Skłodowska-Curie"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            physicist and chemist
          </li>
          <li>
            <b>Awards: 4 </b> 
            (Nobel Prize in Physics, Nobel Prize in Chemistry, Davy Medal, Matteucci Medal)
          </li>
          <li>
            <b>Discovered: </b>
            polonium (element)
          </li>
        </ul>
      </section>
      <section className="profile">
        <h2>Katsuko Saruhashi</h2>
        <img
          className="avatar"
          src={getImageUrl('YfeOqp2')}
          alt="Katsuko Saruhashi"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            geochemist
          </li>
          <li>
            <b>Awards: 2 </b> 
            (Miyake Prize for geochemistry, Tanaka Prize)
          </li>
          <li>
            <b>Discovered: </b>
            a method for measuring carbon dioxide in seawater
          </li>
        </ul>
      </section>
    </div>
  );
}
</code>

Risposta:

<code>
	function ProfileExercise({
		name,
		imageUrl,
		width,
		height,
		profession,
		awards,
		discovered
	}) {
		console.log(imageUrl);
		return (
			<section className="profile">
				<h2>{name}</h2>
				<img
					className="avatar"
					src={getImageUrl(imageUrl)}
					alt={name}
					width={width}
					height={height}
				/>
				<ul>
					<li>
						<b>Profession: </b>
						{profession}
					</li>
					<li>
						<b>Awards: {awards.length} </b>({awards.join(", ")})
					</li>
					<li>
						<b>Discovered: </b>
						{discovered}
					</li>
				</ul>
			</section>
		);
	}

    export function Gallery() {
    	return (
    		<div>
    			<h1>Notable Scientists</h1>
    			<ProfileExercise
    				name="Maria Skłodowska-Curie"
    				imageUrl="szV5sdG"
    				width="70"
    				height="70"
    				profession="physicist and chemist"
    				awards={[
    					"Nobel Prize in Physics",
    					"Nobel Prize in Chemistry",
    					"Davy Medal",
    					"Matteucci Medal"
    				]}
    				discovered="a method for measuring carbon dioxide in seawater"
    			/>
    			<ProfileExercise
    				name="Katsuko Saruhashi"
    				imageUrl="YfeOqp2"
    				width="70"
    				height="70"
    				profession="geochemist"
    				awards={["Miyake Prize for geochemistry", "Tanaka Prize"]}
    				discovered="polonium (element)"
    			/>
    		</div>
    	);
    }

</code>

Corretto :white_check_mark:

2- Corretto :white_check_mark:

3- Soluzione:

<code>
function Card({children}){
  return (
    <div className="card">
    {children}
    </div>
  )
}

export default function Profile() {
return (

<div>
<Card>
<div className="card-content">
<h1>Photo</h1>
<img
            className="avatar"
            src="https://i.imgur.com/OKS67lhm.jpg"
            alt="Aklilu Lemma"
            width={70}
            height={70}
          />
</div>
</Card>
<Card>
<div className="card-content">
<h1>About</h1>
<p>Aklilu Lemma was a distinguished Ethiopian scientist who discovered a natural treatment to schistosomiasis.</p>
</div>
</Card>
</div>
);
}

</code>

Corretto :white_check_mark:

## 7. Conditional Rendering

I Components hanno spesso bisogno di visualizzare cose diverse in base a diverse condizioni. In React.js si può renderizzare in modo condizionale usando la sintassi JavaScript, come gli if statements, e gli operatori &&, || ed il Ternary Operator.

### 7.1. Conditionally returning in JSX

Partiamo da un esempio con un Component PackingList che renderizza vari Components Item che possono essere segnati come impacchettati o no:

<code>
	function Item({ name, isPacked }) {
		return <li className="item">{name}</li>;
	}

    export default function PackingList() {
    	return (
    		<section>
    			<h2>Samantha's Packing List</h2>
    			<ul>
    				<Item isPacked={true} name="Space suit" />
    				<Item isPacked={false} name="Helmet with golden leaf" />
    				<Item isPacked={true} name="Photo of Family" />
    			</ul>
    		</section>
    	);
    }

</code>

Come si può notare alcuni Item hanno la prop impostata su true o false. Supponiamo di voler aggiungere un checkmark agli items se isPacked é true.
Lo si può fare aggiungendo uno statement if / else:
<code>
function Item({ name, isPacked }) {
if (isPacked) {
return <li className="item">{name} ✔</li>;
}
return <li className="item">{name}</li>;
}
</code>

Con questo cambiamento verrà renderizzato un diverso JSX tree in base alla condizione.

In React il control flow, come le condizioni, viene gestito da JavaScript.

### 7.2. Conditionally returning nothing with null

In alcune situazioni non si vuole renderizzare qualcosa, per esempio se non volessimo renderizzare nulla nel caso di isPacked uguale a false nell'esempio precedente. In questo caso restituiamo null:

<code>
	function Item({ name, isPacked }) {
		if (isPacked) {
			return null;
		}
		return <li className="item">{name}</li>;
	}
</code>

In questo caso se isPacked é true non restituiamo nulla, altrimenti restituiamo del JSX da renderizzare.

Nella pratica restituire null da un Component non è comune. Più comunemente restituiamo includendo o escludendo il Component nel parent Component del JSX.

### 7.3. Conditionally including JSX

Vi é chiaramente una somiglianza nel rendering mostrato precedentemente di:

<code>

return <li className="item">{name} ✔</li>;

e

return <li className="item">{name}</li>;

</code>

Anche se la duplicazione non é dannosa, in caso di Components più grandi, può diventare difficile da mantenere e gestire.

In tali situazioni si può includere del JSX per rendere il codice più DRY (Don't Repeat Yourself).

### 7.4. Conditionally (ternary) operator (? :)

Invece di duplicare come sopra possiamo impiegare del codice JavaScript:

<code>
	function Item({ name, isPacked }) {
		return <li className="item">
			{isPacked ? name + "✔" : name}
		</li>
	}
</code>

Nota: in React questi due esempi sono completamente equivalenti.

Si possono aggiungere anche ulteriori tag HTML oltre che a newlines e parentesi e altro:

<code>
function Item({ name, isPacked }) {
  return <li className="item">
    {isPacked ?
      <del>
      {name + " ✔"}
    </del> : name}
  </li>
}
</code>

Questo stile funziona bene per semplici condizioni, ma occorre usarlo con moderazione. Se vi sono troppe condizioni in un Component occorre considerare di estrarre dei child Components per pulire il codice. Usare variabili e funzioni per sistemare espressioni complesse é sempre utile.

### 7.5. Logical AND operator (&&)

L'operatore logico && viene usato quando si vuole renderizzare del JSX quando una condizione é vera, o non renderizzare niente in caso contrario.
Nell'esempio precedente possiamo renderizzare in modo condizionale il checkmark solo se isPacked é true:

<code>
function Item({ name, isPacked }) {
	return (
		<li className="item">
			{name} {isPacked && " ✔"}
		</li>
	);
}
</code>

Si può leggere: se isPacked é true allora (&&) renderizza il checkmark, altrimenti no.

La JavaScript expression && restituisce la value alla destra, nel nostro caso il checkmark, se la condizione sulla sinistra é vera. Ma se la condizione é falsa l'intera espressione diviene false. React considera false come un buco nel tree JSX, proprio come null o undefined, e non renderizza nulla al suo posto.

Nota: non utilizzare numeri nelle comparazioni condizionali con && o ||. Questi vengono visti come true anche in caso di 0. Piuttosto usare un value > 0 con comparatore di maggioranza o minoranza per creare una condizione true / false sfruttabile dal condizionale.

### 7.6. Conditionally assigning JSX to a variable

Quando non si può usare gli shortcuts come &&, || o Ternary Operator, conviene usare un if statement appoggiandosi ad una variabile.
Dichiarando una variabile con let con value del JSX e riassegnadola all'interno dell'if statement se la condizione é true possiamo poi usare tale variabile all'interno di un element per visualizzare una cosa o un'altra:

<code>

    function Item({ name, isPacked }) {
    	let itemContent = name;
    	if (isPacked) {
    		itemContent = name + " ✔";
    	}
    	return <li className="item">{itemContent}</li>;
    }

</code>

Questo stile é più prolisso e articolato ma molto più flessibile.
Chiaramente nell'assegnamento della variabile e nel successivo riassegnamento può essere contenuto anche del JSX, non solo testo.

### 7.7. Exercises

1-

<code>
	function Item({ name, isPacked }) {
		return (
			<li className="item">
				{name} {isPacked ? "✔" : "❌"}
			</li>
		);
	}
</code>

Corretto :white_check_mark:

2-

<code>
function Item({ name, importance }) {
  return (
    <li className="item">
      {name} {importance > 0 && <i>"(Importance: " + importance + ")"</i>}
    </li>
  );
}
</code>

Oppure:

<code>
function Item({ name, importance }) {
  return (
    <li className="item">
      {name} {importance > 0 && <i>{`(Importance: ${importance})`}</i>}
    </li>
  );
}
</code>

3-

<code>
function Drink({ name }) {
  let part = 'bean';
  let caffeineCont = "80–185 mg/cup";
  let age = '1,000+ years';
  if(name === "tea"){
    part = "leaf";
    caffeineCont = '15–70 mg/cup';
    age = '4,000+ years';
  }
  return (
    <section>
      <h1>{name}</h1>
      <dl>
        <dt>Part of plant</dt>
        <dd>{part}</dd>
        <dt>Caffeine content</dt>
        <dd>{caffeineCont}</dd>
        <dt>Age</dt>
        <dd>{age}}</dd>
      </dl>
</code>

Corretto :white_check_mark:

## 8. Rendering Lists

Spesso si vogliono mostrare Components multipli similari tra loro da una collection di dati. Si possono usare dei metodi degli Array di JavaScript per manipolare un Array di dati. Qui useremo filter() e map() con React.js per filtrare e trasformare un Array di dati in un Array di Components.

### 8.1. Rendering data from arrays

Partendo da una lista:

<code>
	<ul>
		<li>Creola Katherine Johnson: mathematician</li>
		<li>Mario José Molina-Pasquel Henríquez: chemist</li>
		<li>Mohammad Abdus Salam: physicist</li>
		<li>Percy Lavon Julian: chemist</li>
		<li>Subrahmanyan Chandrasekhar: astrophysicist</li>
	</ul>
</code>

Osserviamo che l'unica differenza tra i vari items della list é il loro Content, i loro dati. In situazioni come queste, una lista di commenti, una galleria di immagini profilo ecc, si possono archiviare i dati in objects o array e usare metodi come map() e filter() per renderizzare delle liste composte da tali dati.

Partendo quindi da una base di dati in un Array, usiamo un metodo map per restituire per ogni element dell'array un list element con corrispondente element dell'array come content:

<code>

    const people = [
    	"Creola Katherine Johnson: mathematician",
    	"Mario José Molina-Pasquel Henríquez: chemist",
    	"Mohammad Abdus Salam: physicist",
    	"Percy Lavon Julian: chemist",
    	"Subrahmanyan Chandrasekhar: astrophysicist"
    ];

    export function List() {
    	const listItems = people.map((person) => {
    		return <li>{person}</li>;
    	});
    	return <ul>{listItems}</ul>;
    }

</code>

Nota: errore della unique "key" verrà spiegato in seguito.

### 8.2. Filtering arrays of items

I dati possono essere molto più strutturati chiaramente di un semplice Array di strings, come:

<code>
const peopleData = [
	{
		id: 0,
		name: "Creola Katherine Johnson",
		profession: "mathematician"
	},
	{
		id: 1,
		name: "Mario José Molina-Pasquel Henríquez",
		profession: "chemist"
	},
	{
		id: 2,
		name: "Mohammad Abdus Salam",
		profession: "physicist"
	},
	{
		name: "Percy Lavon Julian",
		profession: "chemist"
	},
	{
		name: "Subrahmanyan Chandrasekhar",
		profession: "astrophysicist"
	}
];
</code>

Se volessimo mostrare solo le persone con una profession pari a "chemist" per esempio, potremmo usare il metodo filter per restituire tutte queste persone.
Come ricordiamo questo metodo passa gli items attraverso un "test", una funzione che resituisce true o false, e restituisce un nuovo Array composto da solo quegli items che passano il test restituendo true.

Considerando di ricevere i dati nella variabile people da un file data.jsx, il nostro codice sarà:

<code>
export default function List() {
	const chemist = people.filter((person) => person.profession === "chemist");
	console.log(chemist);
	const listItems = chemist.map((person) => {
		return (
			<li>
				<img src={getImageUrl(person)} alt={person.name} />
				<p>
					<b>{person.name}</b>
					{" " + person.profession + " "}
					known for {person.accomplishment}
				</p>
			</li>
		);
	});
	return <ul>{listItems}</ul>;
}
</code>

Nota: uso dell'Arrow function senza parentesi grafe, return implicito, altrimenti occorre return esplicito. Con le parentesi grafe viene detto un "block body". Questo permette molteplici righe di codice ma richiede il return esplicito.

### 8.3. Keeping list items in order with key

Per risolvere il problema elencato dalla console per i list items, occorre utilizzare una key per ogni item di un array renderizzato. Questa può essere una string od un number che identifica in modo univoco l'item in tale array:

<code>
<li key={person.id}>
				<img src={getImageUrl(person)} alt={person.name} />
				<p>
					<b>{person.name}</b>
					{" " + person.profession + " "}
					known for {person.accomplishment}
				</p>
			</li>
</code>

Le keys indicano a React a quale item dell'Array un Component corrisponde, così da abbinarli in seguito.
Questo diviene essenziale quando gli items di un Array possono muoversi, come nel caso dell'uso di un metodo sort(), o quando vengono inseriti nuovi items o rimossi. Una key ben scelta aiuta React a dedurre cosa sta succedendo esattamente, ed eseguire i corretti aggiornamenti nel DOM tree.

Piuttosto che creare delle key nel codice JavaScript, conviene includerle direttamente nei dati come in questo caso.

Nota: se si dovessero restituire più elements da un singolo item di una lista o non si potesse restituire l'element "li" si opti non per la short syntax del Fragment <></> ma invece quella esplicita <Fragment></Fragment> o <React.Fragment></React.Fragment>, che accettano una key come property ma poi scompaiono dal DOM tree, così facendo restituiscono una flat list di altri elements.

### 8.4. Where to get your key

Differenti sorgenti di dati forniscono differenti sorgenti di keys:

- Data from a database: se i dati provengono da un database, si possono utilizzare le key/ID del database, che sono uniche per natura

- Locally generated data: se i dati sono generati e hanno la loro persistenza localmente, si usi un counter incrementale, come crypto.randomUUID() o packeges come uuid, al momento della creazione degli items.

### 8.5. Rules of keys

- Le Keys devono essere uniche tra le loro siblings, le keys degli altri items nell'Array. Se sono uguali ad altre keys di altri Array sono corrette.

- Le Keys non devono assolutamente cambiare, o perderanno il loro scopo. Non generare le keys durante il rendering.

### 8.6. Why does React need keys?

Le keys servono allo stesso modo del nome dei file in una cartella. Se avessero un numero crescente e venisse eliminato un file, non si capirebbe più quale file é quello corretto.
Le Keys permettono di identificare in modo univoco un item tra i suoi simili. Una Key ben scelta fornisce informazioni rispetto alla sua posizione nell'Array. Persino se la posizione cambia durante il rendering, la Key permette a React di identificare l'item per tutto il suo ciclo di vita.

Nota: non utilizzare l'index di un Array, può cambiare. Come neanche usare Math.random(), che cambia per ogni render, rendendo vana l'identificazione di un item TRA i vari render e rerender. Le keys sono usate solo da React, non vanno a conferire un ID ad un Component, che occorre indicare esplicitamente come property se lo si desidera applicare, come:

<code>

    <Profile key={id} userId={id} />

</code>

### 8.7. Exercises

1-
<code>

    	export default function List() {
    		const chemists = people.filter((person) => person.profession === 'chemist').map(person =>
    			<li key={person.id}>
    				<img
    					src={getImageUrl(person)}
    					alt={person.name}
    				/>
    				<p>
    					<b>{person.name}:</b>
    					{' ' + person.profession + ' '}
    					known for {person.accomplishment}
    				</p>
    			</li>
    		);
    		const others = people.filter((person) => person.profession !== 'chemist').map(person =>
    			<li key={person.id}>
    				<img
    					src={getImageUrl(person)}
    					alt={person.name}
    				/>
    				<p>
    					<b>{person.name}:</b>
    					{' ' + person.profession + ' '}
    					known for {person.accomplishment}
    				</p>
    			</li>
    		);
    		return (
    			<article>
    				<h1>Chemists</h1>
    				<ul>{chemists}</ul>
    				<h1>Others</h1>
    				<ul>{others}</ul>
    			</article>
    		);
    	}

</code>

Corretto :white_check_mark:

2-

<code>
import {Fragment} from "react";
import { recipes } from './data.js';

export default function RecipeList() {
return (

<div>
<h1>Recipes</h1>
<hr />
{recipes.map((recipe) => {
let ingredients = recipe.ingredients.map((item, index) => {
return <li key={recipe.id + index}>{item}</li>
})
return (
<Fragment key={recipe.id}>
<h2>{recipe.name}</h2>
<ul>
{ingredients}
</ul>
</Fragment>
)
})}
</div>
);
}

</code>

Corretto :white_check_mark:

Soluzione tutorial migliore --->

<code>
	import { recipes } from './data.js';

    export default function RecipeList() {
    	return (
    		<div>
    			<h1>Recipes</h1>
    			{recipes.map(recipe =>
    				<div key={recipe.id}>
    					<h2>{recipe.name}</h2>
    					<ul>
    						{recipe.ingredients.map(ingredient =>
    							<li key={ingredient}>
    								{ingredient}
    							</li>
    						)}
    					</ul>
    				</div>
    			)}
    		</div>
    	);
    }

</code>

3-
<code>
import { recipes } from './data.js';
import {Fragment} from "react";

    function Recipe({id, name, ingredients}){
    	return (
    		<Fragment>
    					<h2>{name}</h2>
    					<ul>
    						{ingredients.map(ingredient =>
    							<li key={ingredient}>
    								{ingredient}
    							</li>
    						)}
    					</ul>
    				</Fragment>
    	)
    }

    export default function RecipeList() {
    	return (
    		<div>
    			<h1>Recipes</h1>
    			{recipes.map(recipe =>
    				<Recipe key={recipe.id} id={recipe.id} name={recipe.name} ingredients={recipe.ingredients} />
    			)}
    		</div>
    	);
    }

</code>

Corretto :white_check_mark:
Piccolo appunto, usare ingredient come key nel li element

4-

<code>

    const poem = {
    	lines: [
    		'I write, erase, rewrite',
    		'Erase again, and then',
    		'A poppy blooms.'
    	]
    };

    export default function Poem() {
    	return (
    		<article>
    			{poem.lines.map((line, index) =>
    			{
    				if(index !== 0 && index !== poem.lines.length){
    				return (
    					<Fragment key={index}>
    						<hr />
    						<p key={index}>
    							{line}
    						</p>
    					</Fragment>
    							)
    			}
    			return  <p key={index}>
    					{line}
    				</p>
    			}

    			)}
    		</article>
    	);
    }

</code>

Soluzione funzionante, dubbia quella del tutorial.

## 9. Keeping Components Pure

Alcune funzioni JavaScript sono pure. Le funzioni pure eseguono un calcolo e nulla altro. Scrivendo rigorosamente i Components come funzioni pure si può evitare un'intera classe di bug e comportamenti imprevedibili mano a mano che la base del codice cresce. Per ottenere questi vantaggi, comunque, ci sono alcune regole da seguire.

### 9.1. Purity: Components as formulas

In Computer Science, e specialmente nel mondo del functional programming, un funzione pura é una funzione con le seguenti caratteristiche:

- Si occupa dei propri affari: non cambia nessun object o variabile esistente prima che venga chiamata

- Stesso input, stesso output: dati gli stessi input, una funzione pura dovrebbe sempre restituire lo stesso risultato.

Un esempio può essere una formula matematica, come per esempio
y = 2x. Questo darà sempre un risultato doppio rispetto all'input. Tradotto in funzione:

<code>
function double(number){
	return 2 * number;
}
</code>

Questa é una funzione pura, inserito 3 uscirà SEMPRE 6.

React.js é disegnato intorno a questo concetto. React assume che ogni Component che si scrive sia una funzione pura. Questo significa che i Components React che si scrivono devono sempre restituire lo stesso JSX dati gli stessi input:

<code>
	function Recipe({ drinkers }) {
		return (
			<ol>
				<li>Boil {drinkers} cups of water.</li>
				<li>
					Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
				</li>
				<li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
			</ol>
		);
	}

    export default function CompleteRecipe() {
    	return (
    		<section>
    			<h1>Spiced Chai Recipe</h1>
    			<h2>For two</h2>
    			<Recipe drinkers={2} />
    			<h2>For a gathering</h2>
    			<Recipe drinkers={4} />
    		</section>
    	);
    }

</code>

Quando si passa drinkers={2} a Recipe, questa restituirà del JSX contenente 2 cups of water, sempre. Se ne verranno passate 4 il JSX restituirà 4 cups d'acqua, sempre.

Si possono pensare ai Components come delle ricette: se si seguono e non vengono introdotti nuovi ingredienti durante il processo di cottura, si otterrà lo stesso piatto ogni volta. Il piatto é il JSX che il Component serve a React per il render.

### 9.2. Side Effects: (un)intended consequences

Il processo di rendering di React deve sempre essere puro. I Components dovrebbero solo restituire il proprio JSX, non cambiare un qualsiasi object o variabile che esisteva precedentemente al rendering, visto che questo li renderebbe impuri.

Ecco un Component che rompe questa regola:

<code>
	let guest = 0;

    function Cup() {
    	// Bad: changing a preexisting variable!
    	guest = guest + 1;
    	return <h2>Tea cup for guest #{guest}</h2>;
    }

    export default function TeaSet() {
    	return (
    		<>
    			<Cup />
    			<Cup />
    			<Cup />
    		</>
    	);
    }

</code>

Questo Component legge e riscrive una variabile guest dichiarata fuori da questo. Questo significa che chiamando questo Component molteplici volte produrrà JSX differente. Si può sistemare questo problema passando invece guest come prop:

<code>

    	function Cup({ guest }) {
    		return <h2>Tea cup for guest #{guest}</h2>;
    	}

    export default function TeaSet() {
    	return (
    		<>
    			<Cup guest={1} />
    			<Cup guest={2} />
    			<Cup guest={3} />
    		</>
    	);
    }

</code>

In generale non ci si dovrebbe aspettare che i Components vengano renderizzati in un determinato ordine. Non importa se si chiama y=2x prima o dopo y=5x. Entrambe dovrebbero risolversi indipendentemente l'una dall'altra. Allo stesso modo un Component dovrebbe "pensare a se stesso", e non tentare di coordinarsi o dipedere da altri Components durante il rendering.

### 9.3. Detecting impure calculations with StrictMode

In React.js vi sono tre tipi di input che si possono leggere durante il rendering: le props, lo state ed il context. Si dovrebbe sempre trattare questi input come read-only.

Quando si vuole cambiare qualcosa in risposta ad un input dell'utente si dovrebbe usare setState invece di scrivere una variabile. Non si dovrebbero mai cambiare variabili preesistenti o objects mentre il Component é in fase di rendering.

React offre una "Strict Mode" nella quale si chiamano tutte le funzioni dei Components due volte durante il develpment. Chiamando queste funzioni due volte, la Strict Mode aiuta a trovare eventuali Components che rompono le regole elencate sopra.

La Strict Mode non ha effetti in production, quindi non rellenteremo l'App agli utenti. Per optare per la Strict Mode, basta avvolgere il Root Component in <React.StrictMode>, alcuni framework lo fanno di default.

### 9.4. Local mutation: Your Component's little secret

Nell'esempio soprastante il problema era che il Component cambiava una variabile preesistente durante il rendering. Questa viene chiamata una "mutation".

Comunque é sicuro cambiare variabili o objects appena create durante il rendering. Nell'esempio si crea un empty array, lo si assegna ad una variabile cup e poi si esegue il push di una dozzina di elements su questo:

<code>
	function Cup({ guest }) {
		return <h2>Tea cup for guest #{guest}</h2>;
	}
	export function TeaGathering() {
		let cups = [];
		for (let i = 0; i <= 12; i++) {
			cups.push(<Cup key={i} guest={i} />);
		}
		return cups;
	}
</code>

Se la varaibile cups o l'array fossero stati creati fuori dalla funzione TeaGathering, fuori dal suo scope quindi, sarebbe stato un problema.
Qui va bene perché la variabile viene creata e modificata durante lo stesso rendering, dentro a TeaGathering. Nessun codice fuori da TeaGathering saprà mai che questo sia accaduto. Questa viene chiamata "local mutation".

### 9.5. Where you can cause side effects

Qualcosa deve cambiare ad un certo punto, anche se il functional programming punta molto alla purezza. Questi cambiamenti, aggiornare lo screen, iniziare un'animazione, cambiare i dati, sono chiamati Side Effects. Queste sono cose che accadono "di lato", non durante il rendering.

In React, i Side Effect accadono solitamente dentro agli Event Handlers, al click di un button, al change in un input ecc.
Anche se gli event handlers venissero definiti dentro al Component, non si eseguirebbero durante il rendering. Quindi gli Event Handlers non hanno bisogno di essere puri.

Se tutte le opzioni sono esaurite e non si trovasse il corretto Event Handler per il nostro Side Effect, si potrebbe comunque attaccarlo a questo restituendo del JSX con una chiamata a useEffect nel Component. Questo dice a React di eseguirlo in seguito, dopo il rendering, nella fase quindi durante la quale i Side Effects sono ammessi. Questo approccio dovrebbe essere l'ultima risorsa comunque.

Quando possibile invece meglio provare ad esprimere la propria logica solamente con il render.

### 9.6. Why does React take care about purity?

Scrivere funzioni pure fa acquisire alcune abitudini e disciplina. Ma sblocca anche fantastiche opportunità:

- I Components potrenno eseguirsi in diversi environment, per esempio sul server. Visto che restituiscono lo stesso risultato dati gli stessi input, un Component può servire più requests dagli utenti

- Si possono migliorare le performance saltando il rendering di quei Components i quali input non sono cambiati. Questo é sicuro perché le funzioni pure restituisco sempre lo stesso risultato, quindi sono sicuri da salvare nella cache.

- Se qualche dato cambia nel mezzo del rendering di un tree di un Component profondo, React ricomincia il rendering senza perdere tempo ad ultimare il render ormai datato. La purezza rende sicuro fermare i calcoli anche ogni volta.

Ogni nuova feature di React che costruiamo si avvantaggia grazie alla purezza. Dal fetch dei dati, alle animazioni, alle performance, mantenendo i Component puri si sblocca il potenziale del paradigma di React.js.

### 9.7. Exercises

1-

<code>
	import {useEffect} from "react";

    export default function Clock({ time }) {
    	let hours = time.getHours();
    	useEffect(()=> {
    		if (hours >= 0 && hours <= 6) {
    		document.getElementById('time').className = 'night';
    	} else {
    		document.getElementById('time').className = 'day';
    	}
    	}, [hours])

    	return (
    		<h1 id="time">
    			{time.toLocaleTimeString()}
    		</h1>
    	);
    }

</code>

Soluzione funzionante, dubbia quella del tutorial oltre alla descrizione della task.

2-

<code>
	import Panel from './Panel.js';
	import { getImageUrl } from './utils.js';

    export default function Profile({ person }) {
    	return (
    		<Panel>
    			<Header person={person} />
    			<Avatar person={person} />
    		</Panel>
    	)
    }

    function Header({person}) {
    	return <h1>{person.name}</h1>;
    }

    function Avatar({person}) {
    	return (
    		<img
    			className="avatar"
    			src={getImageUrl(person)}
    			alt={person.name}
    			width={50}
    			height={50}
    		/>
    	);
    }

</code>

Perfetto :white_check_mark:

3-

<code>
	export default function StoryTray({ stories }) {
		let newStories = [...stories];
		newStories.push({
			id: 'create',
			label: 'Create Story'
		});

    	return (
    		<ul>
    			{newStories.map((story, index) =>
    				{return <li key={story.id}>
    					{story.label}
    				</li>}
    			)}
    		</ul>
    	);
    }

</code>

Perfetto :white_check_mark:
Seconda soluzione tutorial

## 10. Adding Interactivity

Alcune cose sullo schermo si aggiornano in risposta all'input dell'utente. Per esempio clickare un su di un'immagine di una gallery. In React, i dati che cambiano nel tempo vengono chiamati State. Si può aggiungere uno State ad ogni Components, ed aggiornarlo quando lo necessitiamo. Qui capiremo come scrivere Components che gestiscano le interzioni, aggiornino il loro State e mostrino differenti output nel tempo.

### 10.1. Responding to events

React permette di aggiungere degli event handlers al JSX.
Gli Event Handlers sono delle funzioni che vengono attivate in risposta all'interazione dell'utente come il click, hover, focus negli input del form e così via.

I Components integrati, come i button, supportano solamente gli events integrati nel browser come onClick. Comunque si possono anche creare dei propri Components e dare alle proprie Event Handler props qualsiasi name specifico dell'applicazione che desideriamo.

<code>
	export default function App() {
		return (
			<Toolbar
				onPlayMovie={() => alert('Playing!')}
				onUploadImage={() => alert('Uploading!')}
			/>
		);
	}

    function Toolbar({ onPlayMovie, onUploadImage }) {
    	return (
    		<div>
    			<Button onClick={onPlayMovie}>
    				Play Movie
    			</Button>
    			<Button onClick={onUploadImage}>
    				Upload Image
    			</Button>
    		</div>
    	);
    }

    function Button({ onClick, children }) {
    	return (
    		<button onClick={onClick}>
    			{children}
    		</button>
    	);
    }

</code>

### 10.2. State: a component's memory

I Components hanno spesso bisogno di cambiare ciò che c'é sullo schermo come risultato di un'interazione.
Di conseguenza i Components hanno la necessità di "ricordare" le cose: la value corrente dell'input, l'immagine corrente, lo shopping cart. In React, tale tipo di memoria specifica del Components viene definita State.

Si può aggiungere uno State ad un Component con un Hook useState.

Gli Hook sono speciali funzioni che permettono di usare le features di React. Lo State é una di queste features. L'Hook useState permette di dichiarare una State Variable.
Questa prende lo State iniziale (initial state) e restituisce una coppia di values: lo state corrente (current state) e una funzione setter che permette di aggiornare lo state corrente.

<code>

    let [index, setIndex] = useState(0);
    let [showMore, setShowMore] = useState(false);

</code>

Ecco un esempio:

<code>
	import React, { useState } from "react";
	import { sculptureList } from "../sculptureData";

    export default function SculptureGallery() {
    	const [index, setIndex] = useState(0);
    	const [showMore, setShowMore] = useState(false);
    	const hasNext = index < sculptureList.length - 1;

    	function handleNextClick() {
    		if (hasNext) {
    			setIndex(index + 1);
    		} else {
    			setIndex(0);
    		}
    	}

    	function handleMoreClick() {
    		setShowMore(!showMore);
    	}

    	let sculpture = sculptureList[index];

    	return (
    		<>
    			<button onClick={handleNextClick}>Next</button>
    			<h2>
    				<i>{sculpture.name} </i>
    				by {sculpture.artist}
    			</h2>
    			<h3>
    				({index + 1} of {sculptureList.length})
    			</h3>
    			<button onClick={handleMoreClick}>
    				{showMore ? "Hide" : "Show"} details
    			</button>
    			{showMore && <p>{sculpture.description}</p>}
    			<img src={sculpture.url} alt={sculpture.alt} />
    		</>
    	);
    }

</code>

### 10.3. Render and commit

Prima che i Components vengano visualizzati sullo schermo, devono essere renderizzati da React. Capire i passaggi in questo processo aiuterà a pensare a come il codice viene eseguito e spiegherà il suo comportamento.

Immaginiamo che React sia un cameriera che prende le richieste dai clienti e porta loro gli ordini.
Il processo di richiesta e servire UI ha questi tre step:

- Triggering (attivazione) del render (consegnare l'ordine della cena alla cucina)
- Rendering del Component (preparare l'ordine nella cucina)
- Committing al DOM (mettere l'ordine in tavola)

### 10.4. State as a snapshot

A differenza delle normali varibili di JavaScript, lo State di React si comporta più come un'istantanea (snapshot).
Impostarlo non cambia la State Variable che si ha, ma invece causa un re-render.

Vedi dettagli nei capitoli successivi.

### 10.5. Queueing a series of state updates

In quest'esempio il click nel button +3 causerà l'aumento dello score di solo +1:

<code>
	import { useState } from 'react';

    export default function Counter() {
    	const [score, setScore] = useState(0);

    	function increment() {
    		setScore(score + 1);
    	}

    	return (
    		<>
    			<button onClick={() => increment()}>+1</button>
    			<button onClick={() => {
    				increment();
    				increment();
    				increment();
    			}}>+3</button>
    			<h1>Score: {score}</h1>
    		</>
    	)
    }

</code>

Vedi dettagli nei capitoli successivi.

Impostando lo State esegue una richiesta per un rerender, ma non lo cambia nel codice che si sta eseguendo. Quindi qui score continuerà ad essere 0 anche dopo aver chiamato la funzione setter:

<code>
console.log(score);  // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score);  // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score);  // 0
setScore(score + 1); // setScore(0 + 1);
console.log(score);  // 0
</code>

Si può sistemare passando una updater function quando si imposta lo State, ora sostituendo setScore(score + 1) con setScore( s => s + 1) sistemerà la cosa. Questo permette di mettere in coda molteplici aggiornamenti dello State:

<code>
	export function Counter() {
		const [score, setScore] = useState(0);

    	function increment() {
    		setScore((s) => s + 1);
    	}

    	return (
    		<>
    			<button onClick={() => increment()}>+1</button>
    			<button
    				onCLick={() => {
    					increment();
    					increment();
    					increment();
    				}}
    			>
    				+3
    			</button>
    			<h1>Score: {score}</h1>
    		</>
    	);
    }

</code>

Vedi dettagli nei capitoli successivi.

### 10.6. Updating objects in state

Lo State può ospitare qualunque tipo di value JavaScript, inclusi gli objects. Non si possono però cambiare gli objects e gli Array che sono ospitati nello State di React direttamente.
Invece quando si vuole aggiornare un object ed un array abbiamo bisogno di crearne uno nuovo, o una copia di uno esistente e poi aggiornare lo State usando quella copia.

Di solito si usa la spread sintax per copiare gli objects e gli array che si vuole cambiare.
Aggiornare un object annidato può essere fatto in questo modo:

<code>
	export function Form() {
		const [person, setPerson] = useState({
			name: "Niki de Saint Phalle",
			artwork: {
				title: "Blue Nana",
				city: "Hamburg",
				image: "https://i.imgur.com/Sd1AgUOm.jpg"
			}
		});

    	function handleNameChange(event) {
    		setPerson({
    			...person,
    			name: event.target.value
    		});
    	}

    	function handleTitleChange(event) {
    		setPerson({
    			...person,
    			artwork: {
    				...person.artwork,
    				title: event.target.value
    			}
    		});
    	}

    	function handleCityChange(event) {
    		setPerson({
    			...person,
    			artwork: {
    				...person.artwork,
    				city: event.target.value
    			}
    		});
    	}

    	function handleImagechange(event) {
    		setPerson({
    			...person,
    			artwork: {
    				...person.artwork,
    				image: event.target.value
    			}
    		});
    	}

    	return (
    		<>
    			<label>Name: </label>
    			<input value={person.name} onChange={handleNameChange} />
    			<label>Title: </label>
    			<input value={person.artwork.title} onChange={handleTitleChange} />
    			<label>City: </label>
    			<input value={person.artwork.city} onChange={handleCityChange} />
    			<label>Image: </label>
    			<input value={person.artwork.image} onChange={handleImagechange} />
    			<p>
    				<i>{person.artwork.title}</i>
    				{" by "}
    				{person.name}
    				<br />
    				(located in {person.artwork.city})
    			</p>
    			<img src={person.artwork.image} alt={person.artwork.title} />
    		</>
    	);
    }

</code>

### 10.7. Updating arrays in state

Gli Array sono un altro tipo di object mutabile di JavaScript che si può archiviare nello State e dovrebbe essere trattato come un read-only. Proprio come gli objects, quando si vuole aggiornare un Array archiviato nello State, si ha bisogno di crearne uno nuovo, o una copia di uno esistente, e poi impostare lo state (set) per usare il nuovo array:

<code>
	let nextId = 3;
	const initialList = [
		{ id: 0, title: "Big Bellies", seen: false },
		{ id: 1, title: "Lunar Landscape", seen: false },
		{ id: 2, title: "Terracotta Army", seen: true }
	];

    export function BucketList() {
    	const [list, setList] = useState(initialList);

    	function handleToggle(artwordId, nextSeen) {
    		setList(
    			list.map((artwork) => {
    				if (artwork.id === artwordId) {
    					return { ...artwork, seen: nextSeen };
    				} else {
    					return artwork;
    				}
    			})
    		);
    		return (
    			<>
    				<h1>Art bucket List</h1>
    				<h2>My list of art to see: </h2>
    				<ItemList artworks={list} onToggle={handleToggle} />
    			</>
    		);
    	}
    }

    function ItemList({ artworks, onToggle }) {
    	return (
    		<ul>
    			{artworks.map((artwork) => (
    				<li key={artwork.id}>
    					<label>
    						<input
    							type="checkbox"
    							checked={artwork.seen}
    							onChange={(event) => {
    								onToggle(artwork.id, event.target.checked);
    							}}
    						/>
    						{artwork.title}
    					</label>
    				</li>
    			))}
    		</ul>
    	);
    }

</code>

## 11. Responding to Events

React permette di avere degli Event Handlers nel JSX. Gli Event Handlers sono delle funzioni create da noi che vengono attivate in risposta a delle interazioni.

### 11.1. Adding event handlers

Per aggiungere un Event Handler, occorre prima definire una funzione e poi passarla come una prop al corretto tag JSX.

Partendo da:

<code>

    export function Button() {
    	return (
    		<button>I'm a Button</button>
    	)
    }

</code>

Si può per esempio mostrare un messaggio quando un utente compie un click:

- Dichiarando una funzione handleClick dentro al Component Button
- Implementando la logica dentro tale funzione (console.log qui)
- Aggiungendo onClick={handleClick} a button JSX

<code>

    export function TestButton() {
    	function handleClick() {
    		console.log("You clicked me");
    	}
    	return <button onClick={handleClick}>Click Me</button>;
    }

</code>

Abbiamo definito la funzione handleClick e poi l'abbiamo passata come una prop a button.
handleClick é un Event Handler.

Le funzioni Event Handler:

- sono solitamente definite dentro ai Components
- hanno names che cominciano con "handle..." seguito dal name dell'Event, questa é una convenzione.

In alternativa si può definire un event handler inline nel JSX:

<code>

    	<button onClick={function handleClick() {
    			console.log('Click');
    		}}>
    		Click Me
    	</button>
    	s

</code>

O con la Arrow Function:

<code>

    		<button onClick={() => {
    				console.log('Click');
    			}}>
    			Click Me
    		</button>

</code>

Tutti questi stili sono equivalenti, anche se gli Event Handler inline sono convenienti per le funzioni corte, non lunghe.

Nota: Le funzioni passate agli event handlers onEvent devono essere passate, non chiamate:

<button onClick={handleClick}>Corretto</button>
<button onClick={handleClick()}>Errato</button>

Nel primo esempio si dice a React di ricordare la funzione e di chiamarla solo quando avviene il Click.
Nel secondo esegue immediatamente la funzione durante il rendering, senza click.

### 11.2. Reading props in event handlers

Visto che gli Event Handlers sono dichiarati internamente ad un Component, hanno accesso alle prop di tale Component.

Ecco un button che una volta clickato mostra la propria prop message:

<code>
	function AlertButton({ message, children }) {
		return <button onClick={() => console.log(message)}>{children}</button>;
	}

    export function Toolbar() {
    	return (
    		<div>
    			<AlertButton message="Playing">Play Movie</AlertButton>
    			<AlertButton message="Uploading">Upload Image</AlertButton>
    		</div>
    	);
    }

</code>

Questo permette ai due buttons di mostrare differenti messaggi.

### 11.3. Passing event handlers as props

Di solito vogliamo che sia il Component parent a specificare l'Event Handler del child.
Considerando ad esempio i buttons: in base a dove useremo un Button Component, si vorrà che venga eseguita una funzione differente, come sopra una che avvia un film e una che carica un'immagine.

Per farlo si passi una prop che il Component riceve dal suo parent come Event Handler come:

<code>
	function Button({ onClick, children }) {
		return <button onClick={onClick}>{children}</button>;
	}

    function PlayButton({ movieName }) {
    	function handlePlayClick() {
    		console.log(`Playing ${movieName}`);
    	}

    	return <Button onClick={handlePlayClick}>Play "{movieName}!"</Button>;
    }

    function UploadButton() {
    	return (
    		<Button onClick={() => console.log("Uploading")}>Upload Image</Button>
    	);
    }

    export function NewToolbar() {
    	return (
    		<div>
    			<PlayButton movieName="Kiki's Delivery Service" />
    			<UploadButton />
    		</div>
    	);
    }

</code>

Qui il Component Toolbar renderizza un PlayButton e un UploadButton:

- PlayButton passa handlePlayClick come prop onClick al Button all'interno
- UploadButton passa () => console.log('Uploading') come prop onClick al Button all'interno

Infine il Button Component accetta una prop chiamata onClick. Il Component passa tale prop direttamente all'element <button></button> integrato del browser con onClick={onClick}.
Questo dice a React di chiamare la funzione passata nel momento in cui avviene un click.

Se si usa un [design system](https://uxdesign.cc/everything-you-need-to-know-about-design-systems-54b109851969) é comune per i Components come i Buttons contenere dello styling ma non specificare il comportamento. Invece, i Components come PlayButton passeranno l'Event Handler.

### 11.4. Naming event handler props

I Components integrati come un "button" o un "div" supportano solamente i browser events names come onClick. Comunque, quando costruiamo i nostri Components possiamo scegliere.

Per convenzione, le event handlers props cominciano con on...seguito da una lettera maiuscola.

Per esempio la prop onClick del Component Button può essere chiamata onSmash:

<code>
	function Button({ onSmash, children }) {
		return <button onClick={onSmash}>{children}</button>;
	}

    export default function Buttons() {
    	return (
    		<div>
    			<Button onSmash={() => console.log("Playing")}>Play Movie</Button>
    			<Button onSmash={() => console.log("Updating")}>Update Image</Button>
    		</div>
    	);
    }

</code>

Da quest'esempio si evince che il <button></button> del browser ha ancora bisogno di una prop chiamata onClick, ma il name della prop ricevuto dal Component Button possiamo sceglierlo.

Quando un Component supporta interazioni multiple, conviene conferire dei names che siano specifici per i concetti dell'app.

### 11.5. Event Propagation

Gli Event Handlers coglieranno anche gli events da ogni children che il Component potrà avere. Si dice che l'event "scoppia" (bubbles) o "si propaga" in su nel tree: comincia dove avviene l'event e poi risale per il DOM tree.

Qui il div contiene due buttons. Sia il div che ogni button hanno i propri handlers onClick. Quando si clickerà su un button anche l'event handler del parent si attiverà:

<code>
	export function Toolbar() {
		return (
			<div
				className="Toolbar"
				onClick={() => {
					console.log("Toolbar clicked");
				}}
			>
				<button onClick={() => console.log("Play")}>Play</button>
				<button onClick={() => console.log("Upload")}>Upload</button>
			</div>
		);
	}

</code>

Se si clickerà invece solo sulla Toolbar, non sui buttons, si attiverà un solo event handler.

Nota: Tutti gli Events si propagano tranne onScroll, che funziona solamente sul tag JSX al quale é attaccato.

### 11.5. Stopping propagation

Gli Event Handlers ricevono un event object come loro argument. Per convenzione viene chiamato "e" o "event". Si può usare questo object per leggere informazioni sull'event.

Quest'event object può essere usato per bloccare la propagation. Se si vuole prevenire che un event raggiunga i parent Components, si dovrà chiamare event.stopPropagation() come fa questo Button Component:

<code>

    function Button({ onClick, children }) {
    	return (
    		<button
    			onClick={(event) => {
    				event.stopPropagation();
    				onClick();
    			}}
    		>
    			{children}
    		</button>
    	);
    }

    export function NewToolbar() {
    	return (
    		<div
    			className="Toolbar"
    			onClick={() => {
    				console.log("Toolbar clicked");
    			}}
    		>
    			<Button onClick={() => console.log("Play")}>Play</Button>
    			<Button onClick={() => console.log("Upload")}>Upload</Button>Button
    		</div>
    	);
    }

</code>

Quando si esegue un click su un button:

1. React chiama l'Event Handler onClick passato a <button></button>

2. Tale Handler, definito in Button compie le seguenti azioni:

   - chiama event.stopPropagation(), prevenendo l'ulteriore propagazione dell'event
   - chiama la funzione onClick, che é la prop passata dal Component Toolbar

3. Tale funzione, definita nel Component Toolbar, mostra l'alert relativo al button clickato

4. Visto che la propagazione é stata bloccata, l'onClick del parent div non si esegue.

Di conseguenza all'uso di event.stopPropagation() verrà eseguito il singolo alert nel button premuto. Fermare la propagazione ha quindi senso per questa UI, visto che clickare su un button non é lo stesso che clickare sul suo container.

### 11.6. Capture phase events

In rari casi, si può voler cogliere tutti gli events negli elements child, persino se fermano la propagazione. Per esempio si vuole loggare ogni click agli analytics, senza tener conto della logica di propagazione.
Si può farlo aggiungendo il termine "Capture" alla fine del name dell'event:

<code>
	<div
					onClickCapture={() => {
						// questo si esegue per primo
					}}
				>
					<button onClick={(event) => event.stopPropagation()}></button>
					<button onClick={(event) => event.stopPropagation()}></button>
	</div>
</code>

Ogni event si propaga in tre fasi:

1. Viaggia in giù, chiamando tutti gli handlers onClickCapture
2. Esegue l'handler dell'element clickato
3. Viaggia in su, chiamando tutti gli handlers onClick

I Capture Events sono utili per codici come Routers e analytics, ma probabilemente non si usaranno nel codice per un App.

### 11.7. Passing handlers as alternative to propagation

Si noti come questo click handler esegua un linea di codice e solo poi chiami la prop onClick passata dal parent:

<code>
	function Button({ onClick, children }) {
		return (
			<button
				onClick={(event) => {
					event.stopPropagation();
					onClick();
				}}
			>
				{children}
			</button>
		);
	}
</code>

Si può aggiungere anche altro codice a questo handler prima di chiamare l'event handler del parent onClick.
Questo codice fornisce un'alternativa alla propagation. Permette al child Component di gestire l'event, mentre lascia al parent Component specificare del comportamento addizionale.
A differenza delle propagation non é automatico. Ma il beneficio di questo pattern é che si può chiaramente seguire l'intera catena di codice che si esegue come risultato di qualche event accaduto.

Se si fa affidamento sulla propagazione ed é difficile tracciare quali handlers si eseguono e perché, si può provare quest'approccio.

### 11.8. Preventing default behaviour

Alcuni events del browser hanno un comportamento di default associato. Per esempio un submit event di un form, che avviene quando un button all'interno di questo viene clickato, e ricaricherà l'intera pagina di default.

Per ovviare a questo comportamento e bloccarlo si può chiamare event.preventDefault() sull'event object del onsubmit Event del form element:

<code>
	export default function Signup() {
		return (
			<form onSubmit={e => {
				e.preventDefault();
				alert('Submitting!');
			}}>
				<input />
				<button>Send</button>
			</form>
		);
	}
</code>

ATTENZIONE: Non confondere event.stopPropagation() e event.preventDefault().
Sono entrambi utili ma non relazionati tra loro:

- event.stopPropagation() ferma gli event handlers uguali attaccati ai tag superiori nel tree dall'attivarsi

- event.prevantDefault() previente il comportamento di default del browser per alcuni events che ce l'hanno.

### 11.9. Can event handlers have side effects?

Sì, gli Event Handlers sono il posto migliore per piazzare i Side Effects.

A differenza delle funzioni di rendering, gli event handlers non necessitano di essere puri, quindi sono un ottimo posto per cambiare qualcosa - per esempio cambiare una value di un input in risposta alla digitazione sulla tastiera, o cambiare una lista in risposta alla pressione su di un button. Comunque per poter cambiare qualche informazione, occorre prima qualche modo per archiviarla. In React, questo viene fatto usando lo State, una memoria di un Component.

### 11.10. Exercises

1-
<code>
export default function LightSwitch() {
function handleClick() {
let bodyStyle = document.body.style;
if (bodyStyle.backgroundColor === 'black') {
bodyStyle.backgroundColor = 'white';
} else {
bodyStyle.backgroundColor = 'black';
}
}

    	return (
    		<button onClick={handleClick}>
    			Toggle the lights
    		</button>
    	);
    }

</code>

2.1-
<code>

    export default function ColorSwitch({
    	onChangeColor
    }) {
    	return (
    		<button onClick={onChangeColor}>
    			Change color
    		</button>
    	);
    }

</code>

Perfetto :white_check_mark:

2.2-
<code>
export default function ColorSwitch({
onChangeColor
}) {
return (
<button onClick={(event)=>{
event.stopPropagation();
onChangeColor();
}}>
Change color
</button>
);
}

</code>

Perfetto :white_check_mark:

## 12. State: A Component's Memory

I Components hanno spesso bisogno di cambiare ciò che viene visualizzato sullo schermo come risultato di un'interazione.
Digitare in un form dovrebbe aggiornare l'input field, clickando su "next" un'immagine di un carousel dovrebbe cambiare, clickando "buy" dovrebbe inserire un prodotto nel cart.
I Components hanno bisogno di "ricordare" codice: la value dell'input corrente, l'immagine corrente, uno shopping cart.
In React.js questo tipo di memoria specifica del Component viene chiamata State.

### 12.1. When a regular variable isn't enough

Ecco un Component che renderizza un'image di una scultura. Clickando su next dovrebbe mostrare la successiva in base all'index, ma non funziona:

<code>

    import { sculptureList } from './data.js';

    export default function Gallery() {
    	let index = 0;

    	function handleClick() {
    		index = index + 1;
    	}

    	let sculpture = sculptureList[index];

    	return (
    		<>
    			<button onClick={handleClick}>Next</button>
    			<h2>
    				<i>{sculpture.name}</i>
    				by {sculpture.artist}
    			</h2>
    			<h3>
    				({index + 1} of {sculptureList.length})
    			</h3>
    			<img src={sculpture.url} alt={sculpture.alt} />
    			<p>{sculpture.description}</p>
    		</>
    	);
    }

</code>

L'Event Handler handleClick aggiorna una variabile locale. Ma due cose prevengono che tale cambiamento sia visibile:

1. Le variabili locali NON PERSISTONO tra i render. Quando React renderizza questo Component una seconda volta, lo fa da zero - non considera nessun cambiamento nelle variabili locali.

2. I cambiamenti alle variabili locali NON ATTIVANO i render. React non si rende conto di avere bisogno di renderizzare nuovamente il Component con i nuovi dati.

Per aggiornare un Component con nuovi dati, occorre che accadano due cose:

1. CONSERVARE i dati tra i render

2. ATTIVARE il render del Component da parte di React con i nuovi dati (re-rendering).

L'Hook "useState" fornisce queste due cose:

1. Una State Variable per CONSERVARE i dati tra i render

2. Una State Setter Function per aggiornare la variabile ed ATTIVARE il render del Component da parte di React nuovamente.

### 12.2. Adding a state variable

Per aggiungere una State Variable, occorre importare l'Hook useState da React:

<code>

    import React, {useState} from "react";

</code>

Poi rimpiazziamo la variabile locale dall'esempio:

<code>

    const [index, setIndex] = useState(0);

</code>

Qui:

- index é la State variable
- setIndex é la setter function

Nota: la sintassi [...,...] qui si chiama Array destructuring e permette di leggere delle value da un Array.
L'Array restituito dall'Hook useState ha sempre esattamente due items.

Così lavorano insieme nella funzione handleClick:

<code>
	function handleClick() {
			setIndex(index + 1);
	}
</code>

Ora l'esempio funziona come dovrebbe:

<code>
	export default function Gallery() {
		const [index, setIndex] = useState(0);

    	function handleClick() {
    		setIndex(index + 1);
    	}

    	let sculpture = sculptureList[index];

    	return (
    		<>
    			<button onClick={handleClick}>Next</button>
    			<h2>
    				<i>{sculpture.name}</i>
    				by {sculpture.artist}
    			</h2>
    			<h3>
    				({index + 1} of {sculptureList.length})
    			</h3>
    			<img src={sculpture.url} alt={sculpture.alt} />
    			<p>{sculpture.description}</p>
    		</>
    	);
    }

</code>

---> Attenzione: non si potrebbe assegnare direttamente un valore ad una State Variable (index + 1). <---

Usare piuttosto la prevValue, primo parametro nella Updater Function passata alla setter function:

<code>
	function handleClick() {
			setIndex((prevIndex) => prevIndex + 1);
	}
</code>

### 12.3. Meet your first Hook

In React useState, come ogni altra funzione che cominci con use... , viene definito un Hook.

Gli Hooks sono funzioni speciali disponibili solo mentre React sta renderizzando. Permettono di agganciare (hook into) diverse features di React.js.

Nota: Gli Hooks possono essere usati solo al top level dei Component e negli Hooks propri. Non si possono chiamare gli Hooks dentro a conditions, loops o altre funzioni annidate.
Gli Hooks sono funzioni ma é utile pensarli come dichiarazioni incondizionate sulle necessità di un Component. Si usano (use) le features di React al top level del Component similarmente a come si "import" i moduli.

### 12.4. Anatomy of useState

Quando si chiama useState, si sta dicendo a React che vogliamo che questo Component ricordi qualcosa:

<code>
		const [index, setIndex] = useState(0);
</code>

In questo caso index.

Nota: convenzione const [something, setSomething].

L'unico argument di useState é l'initial value della State Variable. In questo esempio 0.

Ogni volta che il Component viene renderizzato, useState ci restituisce un Array contente due values:

1. La State Variable (index) con la value archiviata

2. La State Setter Function (setIndex) che può aggiornare la State Variable ed attivare il render del Component da parte di React nuovamente.

Nella fattispecie con:

<code>
		const [index, setIndex] = useState(0);
</code>

Accade che:

1. **Il Component viene renderizzato la prima volta** perché si passa 0 a useState come initial value per index, restituirà [0, setIndex]. React ricorda che 0 é la State Value più recente.

2. **Lo State viene aggiornato** quando un utente clicka il button, viene chiamato setIndex. index é zero ed il risultato della funzione é setIndex(1). Questo dice a React di ricordare che index é 1 adesso e attiva un altro render.

3. **Il secondo render del Component** React vede ancora useState(0), ma proprio perché React ricorda che si ha impostato index ad 1, restituisce [1, setIndex] invece.

4. E così via.

### 12.5. Giving a component multiple state variables

Si possono inserire tutte le State Variables che si vuole del type che si vuole in un Component.

Questo Component ha due State Variables, un number index e un boolean showMore sul quale avviene un toggle quando si clicka "Show Details":

<code>
	export default function Gallery() {
		const [index, setIndex] = useState(0);
		const [showMore, setShowMore] = useState(false);

    	function handleNextClick() {
    		setIndex((prevIndex) => prevIndex + 1);
    	}

    	function handleMoreClick() {
    		setShowMore(!showMore);
    	}

    	let sculpture = sculptureList[index];

    	return (
    		<>
    			<button onClick={handleNextClick}>Next</button>
    			<h2>
    				<i>{sculpture.name}</i>
    				by {sculpture.artist}
    			</h2>
    			<h3>
    				({index + 1} of {sculptureList.length})
    			</h3>
    			<button onClick={handleMoreClick}>{showMore ? "Hide" : "Show"}</button>
    			{showMore && <p>{sculpture.description}</p>}
    			<img src={sculpture.url} alt={sculpture.alt} />
    			<p>{sculpture.description}</p>
    		</>
    	);
    }

</code>

E' una buona idea avere molteplici State Variables se il loro State non é relazionato.
Ma se si nota che si cambiano spesso due State variables insieme, potrebbe essere più facile combinarle insieme in una unica. Per esempio se si ha un form con molti fields, é più conveniente avere una singola State Variable che ospiti un object piuttosto che una State variable per ogni field.

Vedi cap. Choosing the State Structure

### 12.6. How do React know which state to return

Seguendo un ordine dettato dalle dichiarazioni dello State e salvando tutto in un Array, anche senza nessun identifier, visto che non ne viene passato nessuno, React é in grado di relazionare tutto in un ordine di chiamata stabile ad ogni render nello stesso Component.

Dettagli in React Hooks: Not Magic, Just Arrays

Vedi esempio funzionamento State, avanzato.

### 12.7. State is isolated and private

Lo State é locale ad un'istanza di Component presente nello screen. In altre parole, se si renderizza lo stesso Component due volte, ogni copia avrà uno State completamente isolato. Cambiare una di queste non avrà effetto sull'altra.

In quest'esempio, il Component Gallery viene renderizzato due volte con nessun cambiamento nella sua logica. Si noterà che questi sono indipendenti tra loro:

<code>
	export default function Page() {
		return (
			<div className="Page">
				<Gallery />
				<Gallery />
			</div>
		);
	}
</code>

Questo é quello che rende diverso lo State dalle regular variables che si potrebbero dichiarare nel top level di un modulo. Lo State non é legato ad una particolare chiamata di una funzione o un posto nel codice, ma é "locale" ad uno specifico posto nello screen. Si renderizzano due Gallery Commponents, quindi il loro State viene archiviato separatamente.

Si noti inoltre come il Page Component "non sappia nulla" dello State di Gallery, persino se ce ne sia effettivamente uno.
A differenza delle props, lo State è completamente privato nel Component che lo dichiara. Il parent Component non può cambiarlo. Questo permette di aggiungere lo State ad ogni Component o rimuoverlo senza impattare il resto dei Components.

E se volessimo che i Components Gallery mantenessero sincronizzati i loro State? Il modo corretto di farlo in React é rimuovere lo State dai child Components e aggiungerlo al loro parent condiviso più vicino.
Vedi Sharing State Between Components.

### 12.7. Exercises

1-

<code>
	import { useState } from 'react';
	import { sculptureList } from './data.js';

    export default function Gallery() {
    	const [index, setIndex] = useState(0);
    	const [showMore, setShowMore] = useState(false);

    	function handleNextClick() {

    			<!-- questo:  -->

    		if (index >= sculptureList.length - 1){
    			setIndex(0);
    		} else {
    			setIndex(index + 1);
    		}

    			<!-- oppure: -->

    		setIndex(prevIndex => {
    			if(prevIndex >= sculptureList.length - 1){
    				return 0;
    			} else {
    				return prevIndex + 1;
    			}
    		})
    	}

    		function handlePrevClick() {
    		setIndex(prevIndex => {
      if(prevIndex === 0 ){
        return prevIndex = sculptureList.length - 1;
      } else {
        return prevIndex - 1;
      }
    })

}

    	function handleMoreClick() {
    		setShowMore(!showMore);
    	}

    	let sculpture = sculptureList[index];
    	return (
    		<>
    			<button onClick={handleNextClick}>
    				Next
    			</button>
    				<button onClick={handlePrevClick}>
        		Prev
      		</button>
    			<h2>
    				<i>{sculpture.name} </i>
    				by {sculpture.artist}
    			</h2>
    			<h3>
    				({index + 1} of {sculptureList.length})
    			</h3>
    			<button onClick={handleMoreClick}>
    				{showMore ? 'Hide' : 'Show'} details
    			</button>
    			{showMore && <p>{sculpture.description}</p>}
    			<img
    				src={sculpture.url}
    				alt={sculpture.alt}
    			/>
    		</>
    	);
    }

</code>

Corretto :white_check_mark:

2-

<code>
		export default function Form() {
			const [firstName, setFirstName] = useState('');
			const [lastName, setLastName] = useState('');

    		function handleFirstNameChange(e) {
    			setFirstName(e.target.value)
    		}

    		function handleLastNameChange(e) {
    			setLastName(e.target.value)
    		}

    		function handleReset() {
    			setFirstName('');
    			setLastName('');
    		}

    		return (
    			<form onSubmit={e => e.preventDefault()}>
    				<input
    					placeholder="First name"
    					value={firstName}
    					onChange={handleFirstNameChange}
    				/>
    				<input
    					placeholder="Last name"
    					value={lastName}
    					onChange={handleLastNameChange}
    				/>
    				<h1>Hi, {firstName} {lastName}</h1>
    				<button onClick={handleReset}>Reset</button>
    			</form>
    		);
    	}

</code>

Perfetto :white_check_mark:

3-

<code>
import { useState } from 'react';

    export default function FeedbackForm() {
    	const [isSent, setIsSent] = useState(false);
    	const [message, setMessage] = useState('');
    <!-- Corretto così -->

    	if (isSent) {
    		return <h1>Thank you!</h1>;
    	} else {
    		// eslint-disable-next-line
    		<!-- Errore qui * -->
    		return (
    			<form onSubmit={e => {
    				e.preventDefault();
    				alert(`Sending: "${message}"`);
    				setIsSent(true);
    			}}>
    				<textarea
    					placeholder="Message"
    					value={message}
    					onChange={e => setMessage(e.target.value)}
    				/>
    				<br />
    				<button type="submit">Send</button>
    			</form>
    		);
    	}
    }

</code>

Nota: lo State va dichiarato sempre al top level di un Component

Perfetto :white_check_mark:

4-

<code>
	export default function FeedbackForm() {

    	function handleClick() {
    		let name = (prompt('What is your name?'));
    		alert(`Hello, ${name}!`);
    	}

    	return (
    		<button onClick={handleClick}>
    			Greet
    		</button>
    	);
    }

</code>

Perfetto :white_check_mark:

## 13. Render and Commit

Prima che i Components siano visualizzati sullo screen, devono essere renderizzati da React.js. Capire i passaggi in questo processo aiuterà a pensare a come il codice si esegue e spiegherà il suo comportamento.

Immaginiamo che i Components siano dei camerieri nella cucina, che stanno assemblando dei piatti usando i vari ingredienti.
In questo scenario, React é il cameriere che prende le requests dai clienti e porta loro gli ordini.

Questo processo di richieste e servizio di UI ha tre passaggi:

1. Triggering - Attivare un render (ordine portato in cucina)
2. Rendering - Renderizzare il Component (preparazione dell'ordine)
3. Committing - Commit al DOM (mettere l'ordine nel tavolo)

### 13.1. Step 1: Trigger a render

Queste sono le due ragioni per le quali un Component viene renderizzato:

1. E' il render iniziale del Component
2. Lo State del Component, o di uno dei suoi ancestors, é stato aggiornato

### 13.1.1. Initial render

Quando l'App si avvia, si ha bisogno di attivare il render iniziale. Viene fatto chiamando il metodo createRoot con target DOM node, e poi chiamando il suo metodo render() con il Component:

<code>
	import Image from './Image.js';
	import { createRoot } from 'react-dom/client';

    const root = createRoot(document.getElementById('root'))
    root.render(<Image />);

</code>

### 13.1.2 Re-renders when state updates

Una volta che il Components ha eseguito la renderizzazione iniziale, si possono attivare ulteriori altri render aggiornando lo State con la setter function. Aggiornare lo State del Component mette in coda automaticamente un render.

Questo é come fossero ulteriori ordini che cliente, come thé, frutta, dessert, che vengono inserite dopo il primo ordine.

### 13.2. Step 2: React renders your components

Dopo che si attiva un render, React chiama i Components per capire cosa mostrare sullo screen.
"Rendering" significa che React sta chiamando i Components.

- Nell'initial render, React chiamerà il root Component
- Per i render subseguenti React chiamerà la funzione Component il quale State é stato aggiornato attivando il render.

Questo processo é recursive: se il Component restituisce qualche altro Component, React renderizzarà tale Component in seguito, e via così in caso di Components sempre più annidati.
Questo processo continua finché tutti i Components annidati sono finiti e React sa esattamente cosa visualizzare sullo schermo.

In quest'esempio, React chiamerà Gallery ed Image varie volte:

<code>
	export default function Gallery() {
		return (
			<section>
				<h1>Inspiring Sculptures</h1>
				<Image />
				<Image />
				<Image />
			</section>
		);
	}

    function Image() {
    	return (
    		<img
    			src="https://i.imgur.com/ZF6s192.jpg"
    			alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    		/>
    	);
    }

</code>

- Durante il rendering iniziale, React creerà i DOM nodes per la section, h1 e tre tag img
- Durante il re-render, React calcolerà quali delle loro properties, se ce ne sono, dovranno essere cambiate dal precedente render. Non verrà fatto nulla con quelle informazioni fino alla prossima fase, quella di commit.

Nota: Il rendering dovrebbe sempre essere un calcolo puro, quindi seguendo le regole viste in precedenza:

- Stessi input, stessi output. Dati gli stessi input un Component dovrebbe restituire sempre lo stesso putput.
- Non dovrebbe mai cambiare nessun object o variabile esistente in precedenza.

La non osservanza di queste regole può portare a bug e comportamenti inaspettati. Quando si sviluppa in StrictMode, React chiama ogni funzione di un Component due volte proprio per individuare errori dalle funzioni impure.

Nota IMPORTANTE: Il comportamento di default di renderizzare tutti i Components annidati all'interno del Component aggiornato non é ottimale per le performance se il Component é molto alto nel DOM tree. Se ci si trova in un problema di performance, vi sono varie metodologie di ottimizzazione descritte nella sezione
Vedi Optimizing Performance - vecchi docs
Conviene non ottimizzare prematuramente.

### 13.3. Step 3: React commits changes to the DOM

Dopo il rendering dei Components (il fatto di venire chiamati), React modificherà il DOM.

- Per il render iniziale, React userà l'API del DOM con il metodo appendChild() per inserire tutti i DOM nodes che ha creato sullo screen
- Per i re-render, React applicherà le minime operazioni necessarie (calcolate durante il rendering) per far corrispondere l'ultimo output del rendering.

React cambia i DOM nodes solamente se vi é una differenza tra i render.
Per esempio, qui un Component che viene rirenderizzato con diverse props passate dal parent ogni secondo. Si noti come si possa aggiungere del text nell'input, aggiornando quindi la sua value, ma il text non scompaia quando nel Component avviene il rerender:

<code>
	export default function Clock({ time }) {
		return (
			<>
				<h1>{time}</h1>
				<input />
			</>
		);
	}
</code>

Questo funziona perché, durante l'ultimo passaggio, React aggiorni solamente il content dell'h1 con la nuova prop time. Vede solamente che l'input appare nel JSX nello stesso posto dell'ultima volta, quindi React non tocca l'input o la sua value.

### 13.4. Epilogue: Browser paint

Dopo che il rendering é stato fatto e React ha aggiornato il DOM, il browser ridisegnerà lo screen. Sebbene questo processo sia definito come "browser rendering", ci riferiremo a questo come "painting" per evitare confusione in questi docs.

## 14. State as a Snapshot

Le State variables possono sembrare come delle variabili regolari di JavaScript che si possono leggere e in cui scrivere.
Comunque, lo State si comporta più come un'istantanea (snapshot). Impostarlo non cambia la State variable che già abbiamo, ma invece attiva un re-render.

### 14.1. Setting state triggers renders

Si potrebbe pensare che la User Interface cambi in risposta all'event generato dallo user, come un click. In React, questo funziona un po' differentemente a questo modello mentale.

Nella sezione precendente, abbiamo visto che impostare lo State richiede un re-render da React. Questo significa che per un'interfaccia che reagisca all'event, occorre aggiornare lo State.

In quest'esempio, quando si preme "send", la funzione setIsSent(true) dice a React di re-renderizzare la UI:

<code>

    import { useState } from "react";

    export default function Form() {
    	const [isSent, setIsSent] = useState(false);
    	const [message, setMessage] = useState("Hi!");

    	if (isSent) {
    		return <h1>Your message is on its way!</h1>;
    	}

    	return (
    		<form
    			onSubmit={(event) => {
    				event.preventDefault();
    				setIsSent(true);
    				sendMessage(message);
    			}}
    		>
    			<textarea
    				placeholder="Message"
    				value={message}
    				onChange={(event) => setMessage(event.target.value)}
    			/>
    			<button type="submit">Send</button>
    		</form>
    	);
    }

    function sendMessage(message) {
    	// ...
    }

</code>

Ecco cosa accade quando si clicka il button:

1. L'event handler onSubmit si esegue
2. setIsSent(true) imposta isSent su true e mette in coda un nuovo render
3. React re-renderizza il Component secondo la nuova value di isSent.

Vediamo ora più da vicino la relazione tra lo State ed il rendering.

### 14.2. Rendering takes a snapshot in time

Rendering significa che React sta chiamando il Component, che é una funzione. Il JSX restituito da tale funzione é come un'istantanea dell UI in un determinato momento.
Le sue props, gli event handlers, e le local variables sono tutte calcolate usando il loro State al momento del render.

A differenza di una fotografia o un frame di un film, lo "snapshot" della UI che si restituisce é interattivo. Include la logica come gli event handlers che specificano cosa accade in risposta agli input. React aggiorna lo screen per far corrispondere questo snapshot e connette gli event handlers. Come result, premendo un button attiverà l'event handler click nel JSX.

Quando React re-renderizza un Component:

1. React chiama nuovamente la funzione
2. La funzione restituisce un nuovo snapshot JSX
3. React aggiorna poi lo screen per far corrispondere lo snapshot che viene restituito

Come una memoria per il Component, lo State non é come una variabile regolare che scompare dopo che la funzione esegue il return. Lo State vive effettivamente in React stesso, come fosse in uno scaffale, fuori dalla funzione del Component. Quando React chiama il Component, React da un'istantanea dello State per quel render in particolare dopo averlo modificato. Il Component restituisce uno snapshot della UI con un set fresco di props ed event handlers nel suo JSX, tutto calcolato usando le State values da tale render.

In quest'esempio ci si aspetterebbe che clickando "+3" il counter venga incrementato di 3, visto che la setter function viene chiamata 3 volte:

<code>
	export default function Counter() {
		const [number, setNumber] = useState(0);

    	return (
    		<>
    			<h1>{number}</h1>
    			<button onClick={() => {
    				setNumber(number + 1);
    				setNumber(number + 1);
    				setNumber(number + 1);
    			}}>+3</button>
    		</>
    	)
    }

</code>

Si noti invece che lo State "number" viene incrementato solo di uno per click.

Impostare (setting) lo State lo cambia solamente per il successivo render. Durante il primo render, number é 0. Qui vi é il perché in questo render dell'handler onClick la value di number é ancora 0 persino dopo la chiamata a setNumber(number + 1):

<code>
				<button onClick={() => {
					setNumber(number + 1);
					setNumber(number + 1);
					setNumber(number + 1);
				}}>+3</button>
</code>

Questo é ciò che questo handler del click dice a React di fare:

1. setNumber(number + 1): number é 0 quindi setNumber(0 + 1).
   - React si prepara a cambiare number ad 1 nel successivo render
2. setNumber(number + 1): number é 0 quindi setNumber(0 + 1).
   - React si prepara a cambiare number ad 1 nel successivo render.
3. setNumber(number + 1): number é ancora 0 quindi sempre setNumber(0 + 1).
   - React si prepara a cambiare sempre la value di number, 0, in 1 nuovamente.

Persino se si chiama tre volte come qui setNumber(number + 1), in questo handler number é sempre 0, quindi si finirà per impostare 1 per 3 volte. Ecco perché quando l'event handler é finito, React re-renderizza il Component con number uguale ad 1 piuttosto che 3.

Si può inoltre visualizzare questo mentalmente sostituendo le State Variables con le loro value nel codice. Visto che la State variable number é 0 per questo render, il suo event handler si mostrerà come:

<code>
	<button onClick={() => {
		setNumber(0 + 1);
		setNumber(0 + 1);
		setNumber(0 + 1);
	}}>+3</button>
</code>

Per il successivo render, number sarà 1, quindi l'handler click di questo render può essere visualizzato così:

<code>
	<button onClick={() => {
			setNumber(1 + 1);
			setNumber(1 + 1);
			setNumber(1 + 1);
		}}>+3</button>
</code>

Questo é il motivo per il quale clickando il button nuovamente il counter andrà a 2 e via discorrendo.

### 14.3. State over time

Ora si provi ad indovinare cosa verrà mostrato nell'alert dopo aver clickato il button:

<code>

    export default function Counter() {
    	const [number, setNumber] = useState(0);

    	return (
    		<>
    			<h1>{number}</h1>
    			<button onClick={() => {
    				setNumber(number + 5);
    				alert(number);
    			}}>+5</button>
    		</>
    	)
    }

</code>

Risposta 5 - Errrato - Risposta 0.

Usando il metodo della sostituzione mostrato prima:

<code>
		setNumber(0 + 5);
		alert(0);
</code>

Il render avviene dopo l'event handler.
Ma se inseriamo un timer sull'alert? Questo si attiverà dopo il re-render del Component? Sarà 0 o 5?

<code>
	export default function Counter() {
		const [number, setNumber] = useState(0);

    	return (
    		<>
    			<h1>{number}</h1>
    			<button onClick={() => {
    				setNumber(number + 5);
    				setTimeout(() => {
    					alert(number);
    				}, 3000);
    			}}>+5</button>
    		</>
    	)
    }

</code>

Risposta ancora 0 - Corretto

Lo State archiviato in React potrà anche essere cambiato al momento dell'esecuzione del timer, ma é stato schedulato usando uno snapshot dello State al momento in cui lo user ha interagito con questo, l'ha clickato.

La value di una State variable non cambia mai tra i render, persino se il codice dell'event handler é asincrono. Dentro tale onClick del render, la value di number continua ad essere 0 persino se la setter function viene chiamata. La sua value viene "fissata" quando React "ha scattato un'istantanea" della UI chiamando il Component.

Ecco un esempio di come questo rende gli event handlers meno inclini agli errori nel timing. Qui abbiamo un form che manda un message con un delay di cinque secondi.

Immaginiamo lo scenario:

1. Il button "Send" viene premuto, mandando "Hello" ad Alice
2. Prima che il delay di cinque secondi finisca, si cambia la value del field "To" in "Bob".

Cosa ci si aspetta che mostri l'alert?
Risposta Alice - Corretto

<code>
	export default function Form() {
		const [to, setTo] = useState('Alice');
		const [message, setMessage] = useState('Hello');

    	function handleSubmit(e) {
    		e.preventDefault();
    		setTimeout(() => {
    			alert(`You said ${message} to ${to}`);
    		}, 5000);
    	}

    	return (
    		<form onSubmit={handleSubmit}>
    			<label>
    				To:{' '}
    				<select
    					value={to}
    					onChange={e => setTo(e.target.value)}>
    					<option value="Alice">Alice</option>
    					<option value="Bob">Bob</option>
    				</select>
    			</label>
    			<textarea
    				placeholder="Message"
    				value={message}
    				onChange={e => setMessage(e.target.value)}
    			/>
    			<button type="submit">Send</button>
    		</form>
    	);
    }

</code>

React mantiene le values dello State "fisse" (fixed) all'interno di un render di un event handler. Non vi é bisogno di preoccuparsi che lo State venga cambiato mentre il codice é i esecuzione.

Ma se volessimo leggere l'ultimo State prima del re-render?
Allora si userà la State Updater Function, vedi prossima sezione.

### 14.4. Exercises

1-

Risposta: No, non fa differenza inserire l'alert prima o dopo la funzione setter. Lo State é relativo al render.

Perfetto :white_check_mark:

<code>
export default function TrafficLight() {
const [walk, setWalk] = useState(true);

    	function handleClick() {
    		setWalk(!walk);
    		walk ? alert("Stop is next") : alert("Walk is next");
    	}

    	return (
    		<>
    			<button onClick={handleClick}>
    				Change to {walk ? 'Stop' : 'Walk'}
    			</button>
    			<h1 style={{
    				color: walk ? 'darkgreen' : 'darkred'
    			}}>
    				{walk ? 'Walk' : 'Stop'}
    			</h1>
    		</>
    	);

</code>

Quasi Perfetto :white_check_mark:

## 15. Queuering a Series of State Updates

Impostare una State Variable metterà in coda un altro render. Ma a volte si vogliono eseguire moltelici operazioni sulla value prima di mettere in coda il successivo render. Per fare questo, aiuta capire come React esegue il batch degli aggiornamenti dello State.

### 15.1. React batches state updates

Ci si potrebbe aspettare che clickando il button "+3" il counter si incrementi di tre visto che si chiama la setter function setNumber tre volte:

<code>
	export default function Counter() {
		const [number, setNumber] = useState(0);

    	return (
    		<>
    			<h1>{number}</h1>
    			<button onClick={() => {
    				setNumber(number + 1);
    				setNumber(number + 1);
    				setNumber(number + 1);
    			}}>+3</button>
    		</>
    	)
    }

</code>

Ricordare precedente sezione, ricordare la sostituzione della value di state nel codice:

<code>
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
</code>

Ma qui vi é da tenere in considerazione un altro fattore. React aspetta finché tutto il codice negli event handlers non sia stato eseguito prima di processare gli aggiornamenti dello State. Questo perché il re-render avviene solamente DOPO tutte queste chiamate di setNumber().

Per capire meglio questo ricordiamo l'esempio del cameriere. Questo non porterà in cucina l'ordine prima del primo piatto.
Invece il cameriere lascerà che tu finisca il tuo ordine, ti lascerà apportarvi dei cambiamenti e prenderà gli ordini delle altre persone al tavolo.

Questo ti permetterà di aggiornare molteplici State Variables - persino da molteplici Components - senza l'attivazione di troppi re-render. Ma questo significa anche che la UI non sarà aggiornata fino a che ogni event handler e e tutto il codice al loro interno non sarà completato.
Questo comportamento, conosciuto anche come BATCHING, rende la React App molto più veloce. Evita anche la confusione di interagire con render finiti a metà dove solo alcune delle variabili sono state aggiornate.

React non esegue il batching attraverso multipli events intenzionali come il click - ogni click viene gestito separatamente. Si può stare certi che React eseguirà il batching solo quando é generalemente sicuro farlo. Per assicurasi questo, per esempio, se il click di un primo button disabilita un form, il secondo click non eseguirà nuovamente il submit.

### 15.2. Updating the same state multiple times before the next render

Si tratta di un caso d'uso non comune, ma se si volesse aggiornare la stessa State variable varie volte prima del successivo render, invece di passare passare la State value successiva come setNumber(number + 1), si può passare una funzione che calcola il successivo State basato sulla precedente nella coda, come setNumber(n => n + 1). Questo é un modo di dire a React di "fare qualcosa con la State Value" invece di solo sostituirla.

Si provi quest'esempio ora:

<code>
	export function Counter() {
		const [number, setNumber] = useState(0);

    	return (
    		<>
    			<h1>{number}</h1>
    			<button
    				onClick={() => {
    					setNumber((n) => n + 1);
    					setNumber((n) => n + 1);
    					setNumber((n) => n + 1);
    				}}
    			>
    				+3
    			</button>
    		</>
    	);
    }

</code>

Qui il Counter aumenterà di tre.
La funzione n => n + 1 viene definita una "updater function".
Quando si passa un'updater function ad una setter di uno State:

1. React mette in coda questa funzione perché venga processata dopo che é stato eseguito tutto il restante codice nell'event handler.

2. Durante il successivo render, React viaggia attraverso la cosa e restituisce lo State finale aggiornato.

<code>
	setNumber((n) => n + 1);
	setNumber((n) => n + 1);
	setNumber((n) => n + 1);
</code>

Ecco come React funziona attraverso queste linee di codice mentre si eseguendo l'event handler:

1. setNumber( n => n + 1): é una funzione. React la aggiunge alla coda.
2. setNumber(n => n + 1): é una funzione. React la aggiunge alla coda di nuovo.
3. setNumber( n => n + 1): é una funzione. React la aggiunge alla coda nuovamente.

Quando verrà chiamato setState durante il successivo render, React vieaggerà attraverso la coda. Il precedente State number era 0, quindi sarà questo che React passerà alla prima updater function come argument n. Poi React prende la value restituita di questa precedente updater function e la passa alla successiva updater come n e così via:

<code>
	queued update	n	returns
	n => n + 1	0	0 + 1 = 1
	n => n + 1	1	1 + 1 = 2
	n => n + 1	2	2 + 1 = 3
</code>

React archivierà poi 3 come risultato finale e lo restituirà da useState.

Questo é il motivo per cui clickando "+3" nell'esempio vi é un incremento corretto della value di 3.

### 15.3. What happens if you update state after replacing it

Osservando l'esempio, si provi a capire quale sarà il risultato mostrato:

<code>
	export default function Counter() {
		const [number, setNumber] = useState(0);

    	return (
    		<>
    			<h1>{number}</h1>
    			<button onClick={() => {
    				setNumber(number + 5);
    				setNumber(n => n + 1);
    			}}>Increase the number</button>
    		</>
    	)
    }

</code>

Risposta: 1 - Errata.

Risposta: 6.

Ecco cosa dice questo event handler a React di fare:

1. setNumber(number + 5): number é 0, quindi setNumber(0 + 5). React aggiunge "sostituisci con 5" alla sua coda.

2. setNumber(n => n + 1): n => n + 1 é un'updater function. React aggiunge tale funzione alla coda.

Durante il successivo render, React viaggia attraverso la coda dello State:

<code>
	queued update			n						returns
	“replace with 5”	0 	(unused)	5
	n => n + 1				5						5 + 1 = 6
</code>

React archivia 6 come risultato finale e lo restituisce da useState.

Nota: Si avrà notato che setState(5) funziona come setState(n => 5), ma n non viene usato, vedi conseguenze esempio successivo.

### 15.4. What happens if you replace state after updating it

Provare a rispondere con quest'esempio. Quale sarà la value di number?

<code>
	export default function Counter() {
		const [number, setNumber] = useState(0);

    	return (
    		<>
    			<h1>{number}</h1>
    			<button onClick={() => {
    				setNumber(number + 5);
    				setNumber(n => n + 1);
    				setNumber(42);
    			}}>Increase the number</button>
    		</>
    	)
    }

</code>

Risposta: 42 - Corretto.

Ecco come React funziona tra queste linee di codice mentre esegue questo event handler:

1. setNumber(number + 5): number é 0, quindi setNumber(0 + 5). React aggiunge "sostituisci con 5" alla sua coda.

2. setNumber(n => n + 5): n => n + 1 é un'updater function. React aggiunge tale function alla sua coda.

3. setNumber(42): React aggiunge "sostituisci con 42" alla sua coda.

Durante il successivo render, React viaggia attraverso la coda dello State:

<code>
	queued update			n						returns
	“replace with 5”	0 (unused)	5
	n => n + 1				5						5 + 1 = 6
	“replace with 42”	6 (unused)	42
</code>

Poi React archivia 42 come risultato finale e lo restituisce da useState.

Per riassumere, ecco come si dovrebbe pensare a quello che si sta passando alla funzione setter dello State setNumber:

- Un'updater function viene aggiunta alla coda

- Tutte le altre value aggiungono un "sostituisci con ..." alla coda, ignorando qualunque altra cosa si trovi prima nella coda.

Dopo che l'event handler é stato completato, React attiverà un re-render. Durante il re-render, React processerà la coda. Le updater functions si eseguiranno durante il rendering, quindi le updater functions DEVONO essere PURE e restituire solo il result. Non conviene provare ad aggiornare lo State da dentro a queste o eseguire altri Side Effects. In Strict Mode, React eseguirà ogni updater function due volte (ma scarterà il secondo risultato) per aiutare a trovare errori.

### 15.5. Naming Conventions

E' comune dare come nome all'argument dell'updater function con le prime lettere della corrispondente state variable:

<code>
	setEnabled(e => !e)
	setLastName(ln => ln.reverse())
	setFriendCount(fc => fc * 2)
</code>

Se si preferisce un codice più prolisso, un'altra convenzione comune é quella di ripetere il nome completo della State variable, come setEnabled(enabled => !enabled).

Ancora un'altra convenzione alternativa é quella di usare il prefisso prev (previous) come:
setEnabled(prevEnabled => !prevEnabled).

### 15.6. Exercises

1-

<code>
	export default function RequestTracker() {
		const [pending, setPending] = useState(0);
		const [completed, setCompleted] = useState(0);

    	async function handleClick() {
    		setPending(pending + 1);
    		await delay(3000);
    		setPending(prevPending => prevPending - 1);
    		setCompleted(prevComplete => prevComplete + 1);
    	}

    	return (
    		<>
    			<h3>
    				Pending: {pending}
    			</h3>
    			<h3>
    				Completed: {completed}
    			</h3>
    			<button onClick={handleClick}>
    				Buy
    			</button>
    		</>
    	);
    }

    function delay(ms) {
    	return new Promise(resolve => {
    		setTimeout(resolve, ms);
    	});
    }

</code>

Corretto :white_check_mark:

2-

<code>

    import {useState} from "react";

    export function getFinalState(baseState, queue) {
    	let finalState = baseState;

    		for (let update of queue) {
    		if (typeof update === 'function') {
    			return () => update(); <-- da correggere
    		} else {
    			return update
    		}
    	}

    	// TODO: do something with the queue...

    	return finalState;
    }

</code>

NON RIUSCITO

Soluzione:

<code>
export function getFinalState(baseState, queue) {
  let finalState = baseState;

// TODO: do something with the queue...

for (let update of queue){  
 if(typeof update === "function"){

        console.log(finalState)
        finalState = update(finalState);
    } else {
      finalState = update;
    }

}

return finalState;
}
</code>

## 16. Updating Objects in State

Lo State può ospitare qualsiasi tipo di value JavaScript, inclusi gli objects. Ma non si dovrebbero cambiare gli objects ospitati nello State di React direttamente. Invece, quando si vuole aggiornare un object, si ha bisogno di crearne uno nuovo (o eseguirne un copia di uno eistente), e poi impostare lo State per usare tale copia.

### 16.1. What's a mutation?

Si possono archiviare tutti i tipi di value JavavaScript nello State. Abbiamo visto esempi con numeri, stringhe e booleans. Questi tipi si definiscono "immutabili", cioé che non sono cambiabli o "read-only". Si può sostituire la value dopo aver attivato un re-render usando una funzione setter come setX(5), ma questo sostituisce una value precedente, il numero precedente stesso non cambia. Non é possibile effettuare nessun tipo di cambiamento nelle value primitive integrate come numbers, string e booleans.

Ora consideriamo un object nello State:

<code>
	const [position, setPosition] = useState({ x: 0, y: 0 });
</code>

Tecnicamente é possibile cambiare i contents dell'object stesso. Questa viene chiamata una "mutation":

position.x = 5;

Comunque anche se gli objects nello State di React sono tecnicamente mutabili, dovrebbero essere trattati come immutabili. Invece di mutarli, dovrebbero sempre essere sostituiti.

### 16.2. Treat state as read-only

Si dovrebbe sempre trattare ogni JavaScript object che si inserisce nello State come read-only.

Questo esempio ospita un object nello State per rappresentare la posizione corrente del pointer. Il punto rosso si suppone si muoverà quando si muoverà il cursore nell'area. Ma il dot resta nella posizione iniziale:

<code>
	export default function MovingDot() {
		const [position, setPosition] = useState({ x: 0, y: 0 });

    	return (
    		<div
    			onPointerMove={(event) => {
    				position.x = event.clientX;
    				position.y = event.clientY;
    			}}
    			style={{ position: "relative", widht: "100vw", height: "100vh" }}
    		>
    			<div
    				style={{
    					position: "absolute",
    					backgroundColor: "red",
    					borderRadius: "50%",
    					transform: `translate(${position.x}px, ${position.y}px)`,
    					left: -10,
    					top: -10,
    					width: 20,
    					height: 20
    				}}
    			></div>
    		</div>
    	);
    }

</code>

Il problema chiaramente risiede nel codice:

<code>
onPointerMove={(event) => {
				position.x = event.clientX;
				position.y = event.clientY;
			}}
</code>

Questo codice modifica l'object assegnato a position dal precendente render. Ma senza usare la setting function dello State, React non ha idea che l'object é cambiato. Quindi React non compie nessun'azione in risposta all'event. E' come provare a cambiare l'ordine dopo che si é già cominciato a mangiare il piatto. Anche se la mutazione dello State a volte funziona, non é consigliata. Si dovrebbe trattare la State value a cui si ha accesso in un render come read-only.

Per attivare un re-render in questo caso, occorre creare un nuovo object e passarlo alla setter function dello State:

<code>
	onPointerMove={(event) => {
					setPosition({
						x: event.clientX,
						y: event.clientY
					});
				}}
</code>

Con setPosition si sta dicendo a React:

- sostituisci position con questo nuovo object
- renderizza nuovamente questo Component

Si noti come il punto rosso segua il cursore quando si passa sopra alla preview area.

### 16.3. Local mutation is fine

Il codice come questo crea problemi perché modifica un object esistente nello State:

<code>
position.x = event.clientX;
position.y = event.clientY;
</code>

Ma un codice come questo va assolutamente bene perché si sta mutando un nuovo object che si ha appena creato:

<code>
const nextPosition = {};
nextPosition.x = event.clientX;
nextPosition.y = event.clientY;
setPosition(nextPosition);
</code>

Infatti é completamente equivalente a scrivere:

<code>
setPosition({
	x: event.clientX,
	y: event.clientY
});
</code>

La mutation é un problema solo quando si sta cambiando un object esistente che é già nello State. Mutare un object appena creato va bene perché non vi sono ancora altre reference a questo. Cambiarlo non va ad impattare accidentalmente qualcosa che dipende da questo. Questa viene definita "local mutation". Si può addirittura effettuare una local mutation mentre si sta eseguendo il rendering. E' molto conveniente e ok.

### 16.4. Copying objects with spread syntax

Nel precendente esempio, l'object position é sempre creato da zero dalla posizione corrente del cursore. Ma a volte, vogliamo includere dei dati esistenti come parte di un nuovo object che si sta creando. Per esempio, si vuole aggiornare un solo field di un form, ma mantenere le precedenti values per tutti gli altri fields.

Questi input fields non funzionano perché gli onChange handlers mutano lo State:

<code>
	export default function ObjForm() {
		const [person, setPerson] = useState({
			firstName: "Barbara",
			lastName: "Hepworth",
			email: "bhepworth@sculpture.com"
		});

    	function handleFirstNameChange(event) {
    		person.firstName = event.target.value;
    	}

    	function handleLastNameChange(event) {
    		person.lastName = event.target.value;
    	}

    	function handleEmailChange(event) {
    		person.email = event.target.value;
    	}

    	return (
    		<>
    			<label>
    				First name:
    				<input value={person.firstName} onChange={handleFirstNameChange} />
    			</label>
    			<label>
    				Last name:
    				<input value={person.lastName} onChange={handleLastNameChange} />
    			</label>
    			<label>
    				Email:
    				<input value={person.email} onChange={handleEmailChange} />
    			</label>
    			<p>
    				{person.firstName},<br />
    				{person.lastName},<br />({person.email})
    			</p>
    		</>
    	);
    }

</code>

Per esempio, questa linea muta lo State da un render passato:
<code>

    person.firstName = event.target.value;

</code>

Il modo migliore per ottenere ciò che vogliamo é creare un nuovo object e passarlo a setPerson. Qui si vorrà anche copiare i dati già esistenti in questo, visto che solo uno dei fields sarà cambiato:

<code>

    function handleFirstNameChange(event) {
    		setPerson({
    			firstName: event.target.value,
    			lastName: person.lastName,
    			email: person.email
    		});
    	}

</code>

Si può usare per semplificare il codice la spread syntax per gli objects, così non occorrerà copiare ogni property separatamente:

<code>

    function handleLastNameChange(event) {
    		setPerson({
    			...person,
    			lastName: event.target.value
    		});
    	}

</code>

Qui si copieranno tutte le properties dell'object person (...person) ma si sovrascriverà la property lastName con la value del target dell'event.

Si noti inoltre come in quest'esempio non venga dichiarata una singola State variable per ogni input field, ma invece tutti i dati sono raggruppati in un unico object nella State variable person, che é molto conveniente:

<code>
	export default function ObjForm() {
		const [person, setPerson] = useState({
			firstName: "Barbara",
			lastName: "Hepworth",
			email: "bhepworth@sculpture.com"
		});

    	function handleFirstNameChange(event) {
    		setPerson({
    			firstName: event.target.value,
    			lastName: person.lastName,
    			email: person.email
    		});
    	}

    	function handleLastNameChange(event) {
    		setPerson({
    			...person,
    			lastName: event.target.value
    		});
    	}

    	function handleEmailChange(event) {
    		setPerson({
    			...person,
    			email: event.target.value
    		});
    	}

    	return (
    		<>
    			<label>
    				First name:
    				<input value={person.firstName} onChange={handleFirstNameChange} />
    			</label>
    			<label>
    				Last name:
    				<input value={person.lastName} onChange={handleLastNameChange} />
    			</label>
    			<label>
    				Email:
    				<input value={person.email} onChange={handleEmailChange} />
    			</label>
    			<p>
    				{person.firstName},<br />
    				{person.lastName},<br />({person.email})
    			</p>
    		</>
    	);
    }

</code>

Si noti che la ... spread syntax é poco profonda. Questa copia le properties ad un solo livello di profondità. Questo significa che é molto veloce, ma anche che se si vuole aggiornare una property annidata, si dovrà usarla più di una volta.

### 16.5. Using a single event handler for multiple fields

Si possono usare le parentesi quadre [] dentro alla definizione di un object per specificare una property con name dinamico.
Ecco lo stesso esempio di prima, ma con un singolo event handler invece dei tre differenti di prima:

<code>
	export default function ObjForm() {
		const [person, setPerson] = useState({
			firstName: "Barbara",
			lastName: "Hepworth",
			email: "bhepworth@sculpture.com"
		});

    	function handleChange(event) {
    		setPerson({
    			...person,
    			[event.target.name]: event.target.value
    		});
    	}

    	return (
    		<>
    			<label>
    				First name:
    				<input
    					name="firstName"
    					value={person.firstName}
    					onChange={handleFirstNameChange}
    				/>
    			</label>
    			<label>
    				Last name:
    				<input
    					name="lastName"
    					value={person.lastName}
    					onChange={handleLastNameChange}
    				/>
    			</label>
    			<label>
    				Email:
    				<input name="email" value={person.email} onChange={handleEmailChange} />
    			</label>
    			<p>
    				{person.firstName},<br />
    				{person.lastName},<br />({person.email})
    			</p>
    		</>
    	);
    }

</code>

Qui event.target.name usato tra le parentesi quadre [], si riferisce alla property name presente in ogni input field del DOM, se scritta.

### 16.6. Updating a nested object

Consideriamo una struttura annidata come questa:

<code>
	export default function ObjFormNested() {
		const [person, setPerson] = useState({
			name: "Niki de Saint Phalle",
			artwork: {
				title: "Blue Nana",
				city: "Hamburg",
				image: "https://i.imgur.com/Sd1AgUOm.jpg"
			}
		});
	}
</code>

Se si volesse aggiornare person.artwork.city, é chiaro come farlo con una mutation:

person.artwork.city = "New Delhi";

Ma in React, occorre trattare lo State come immutabile. Per poter cambiare la property city, si dovrà prima produrre un nuovo object artwork (pre-popolato con i dati provenienti dal precedente), e poi produrre un nuovo object person che punti al nuovo object artwork:

<code>
	const nextArtwork = { ...person.artwork, city: "New Delhi" };
  const nextPerson = { ...person, artwork: nextArtwork };
  setPerson(nextPerson);
</code>

O, scritto in un'unica chiamata alla funzione:

<code>
	setPerson({
			...person,
			artwork: {
				...person.artwork,
				city: "New Delhi"
			}
		});
</code>

Questo può sembrare un po' prolisso, ma funziona bene in moltissimi casi:

<code>
	export default function ObjFormNested() {
		const [person, setPerson] = useState({
			name: "Niki de Saint Phalle",
			artwork: {
				title: "Blue Nana",
				city: "Hamburg",
				image: "https://i.imgur.com/Sd1AgUOm.jpg"
			}
		});

    	function handleNameChange(event) {
    		setPerson({
    			...person,
    			name: event.target.value
    		});
    	}

    	function handleTitleChange(event) {
    		setPerson({
    			...person,
    			artwork: {
    				...person.artwork,
    				title: event.target.value
    			}
    		});
    	}

    	function handleCityChange(event) {
    		setPerson({
    			...person,
    			artwork: {
    				...person.artwork,
    				city: event.target.value
    			}
    		});
    	}

    	function handleImageChange(event) {
    		setPerson({
    			...person,
    			artwork: {
    				...person.artwork,
    				image: event.target.value
    			}
    		});
    	}

    	return (
    		<>
    			<label>
    				Name:
    				<input value={person.name} onChange={handleNameChange} />
    			</label>
    			<label>
    				Title:
    				<input value={person.artwork.title} onChange={handleTitleChange} />
    			</label>
    			<label>
    				City:
    				<input value={person.artwork.city} onChange={handleCityChange} />
    			</label>
    			<label>
    				Image:
    				<input value={person.artwork.image} onChange={handleImageChange} />
    			</label>
    			<p>
    				<i>{person.artwork.title}</i>
    				{" by "}
    				{person.name}
    				<br />
    				(located in {person.artwork.city})
    			</p>
    			<img src={person.artwork.image} alt={person.artwork.title} />
    		</>
    	);
    }

</code>

### 16.7. Objects are not really nested

Un object come questo appare annidato nel codice:

<code>
let obj = {
		name: "Niki de Saint Phalle",
		artwork: {
			title: "Blue Nana",
			city: "Hamburg",
			image: "https://i.imgur.com/Sd1AgUOm.jpg"
		}
	}
</code>

Comunque, pensare ad un annidamento é un modo inaccurato di pensare a come gli objects si comportano. Quando il codice viene eseguito, non vi é qualcosa come un object "annidato".
Si stanno osservando due diversi objects:

<code>
let obj1 = {
			title: "Blue Nana",
			city: "Hamburg",
			image: "https://i.imgur.com/Sd1AgUOm.jpg"
		}

let obj2 = {
name: 'Niki de Saint Phalle',
artwork: obj2
}
</code>

L'obj1 non é "all'interno" di obj2. Per esempio, anche obj3 può "puntare" ad obj1:

<code>
let obj1 = {
			title: "Blue Nana",
			city: "Hamburg",
			image: "https://i.imgur.com/Sd1AgUOm.jpg"
		}

let obj2 = {
name: 'Niki de Saint Phalle',
artwork: obj2
}

let obj3 = {
name: "Copycat",
artwork: obj1
}
</code>

Se si sta mutando obj.artwork.city, questo avrà effetto sia su obj2.artwork.city che su obj1.city. Questo perché obj3.artwork, obj2.artwork e obj sono lo stesso object, sono reference di uno stesso object. Questo é più difficile da vedere se si pensa agli objects come "innestati". Invece, sono objects separati che "puntano" gli uni agli altri con properties.

### 16.8. Write concise update logic with Immer

Se lo State é annidato in profondità, si dovrebbe considerare di flatterizzarlo. Ma se non si vuole cambiare la struttura dello State, si potrebbe preferire una scorciatoia per gli spreads annidati. Immer é una library popolare che permette di scrivere usando la sintassi conveniente ma mutevole e si preoccupa di produrre delle copie per lo sviluppatore.
Con Immer, il codice che si scrive sembrerà come se si stessero "rompendo le regole" e mutare un object:

<code>
updatePerson(draft => {
	draft.artwork.city = "Lagos";
})
</code>

Ma a differenza di una regolare mutazione non va a sovrascrivere lo State passato.

### 16.9. How does Immer work?

Il draft fornito da Immer é uno speciale type di object, chiamato un Proxy, che "registra" cosa si fa con questo. Questo é il motivo per cui si può mutare draft liberamente come si vuole. Al suo interno, Immer si raffigura quali parti di draft sono state cambiate e produce un nuovo object che contiene le proprie modifiche.

Per utilizzare Immer:

1. npm install use-immer
2. sostituire import {useState}... con import {useImmer} from "use-immer"

Ecco l'esempio mostrato in precedenza convertito ad Immer:

<code>
	export default function Form() {
		const [person, updatePerson] = useImmer({
			name: "Niki de Saint Phalle",
			artwork: {
				title: "Blue Nana",
				city: "Hamburg",
				image: "https://i.imgur.com/Sd1AgUOm.jpg"
			}
		});

    	function handleNameChange(event) {
    		updatePerson((draft) => {
    			draft.name = event.target.value;
    		});
    	}

    	function handleTitleChange() {
    		updatePerson((draft) => {
    			draft.artwork.title = event.target.value;
    		});
    	}

    	function handleImageChange() {
    		updatePerson((draft) => {
    			draft.artwork.image = event.target.value;
    		});
    	}

    	return (
    		<>
    			<label>
    				Name:
    				<input value={person.name} onChange={handleNameChange} />
    			</label>
    			<label>
    				Title:
    				<input value={person.artwork.title} onChange={handleTitleChange} />
    			</label>
    			<label>
    				City:
    				<input value={person.artwork.city} onChange={handleCityChange} />
    			</label>
    			<label>
    				Image:
    				<input value={person.artwork.image} onChange={handleImageChange} />
    			</label>
    			<p>
    				<i>{person.artwork.title}</i>
    				{" by "}
    				{person.name}
    				<br />
    				(located in {person.artwork.city})
    			</p>
    			<img src={person.artwork.image} alt={person.artwork.title} />
    		</>
    	);
    }

</code>

Si noti che gli event handlers diventano molto più concisi. Si possono mixare ed abbinare useState ed useImmer in un singolo Component come si vuole. Immer é un grande modo per mantenere gli handlers di aggiornamento più sintetici, specialmente se vi sono degli annidamenti nello State, e copiare gli objects porta a codice ripetitivo.

### 16.10. Why is mutating state not recommended in React?

Vi sono molte ragioni:

- Debugging: se si usa console.log e non si muta lo State, i log passati non verranno influenzati dai cambiamenti più recenti dello State. Quindi si potrà vedere chiaramente come lo State viene cambiato tra i render.

- Optimizations: Le più comuni strategie di ottimizzazione di React si basano sul saltare del lavoro se le precedenti props o State rimangono le stesse delle successive. Se non si muta mai lo State diventa molto veloce controllare se ci sono stati dei cambiamenti. Se prevObj === obj, si può essere sicuri che niente potrebbe essere cambiato dentro a questo.

- New Features: Le nuove features di React in costruzione si basano sul fatto che lo State sia trattato come un'istantanea. Se si mutano le versioni passate dello State, questo potrebbe prevenire l'uso delle nuove features.

- Requirement Changes: Alcune features delle App, come implementare l' Undo/Redo, mostrare una histoty dei cambiamenti o permettere ad un utente di resettare un form alle value precedenti sono più facili da fare quando nulla viene mutato. Questo perché si possono mantenere delle copie passate dello State in memoria, e riusarle quando é appropriato. Se si comincia con un approccio alla mutazione, features come queste possono essere molto difficili da implementare in seguito.

- Simpler Implementation: Visto che React non si basa sulle mutation, non ha bisogno di fare nulla di speciale con gli objects, non ha bisogno di dirottare o sovrascirvere properties, mantenerle sempre avvolte nei Proxy, o compiere ulteriore lavoro nell'inizializzazione come altre soluzioni "reactive" fanno. Questo é anche il motivo per il quale React permette di inserire qualsiasi object nello State, non importa quanto grande, senza performance addizionali o insidie di correttezza.

### 16.11. Exercises

1-
<code>
import { useState } from 'react';

    export default function Scoreboard() {
    	const [player, setPlayer] = useState({
    		firstName: 'Ranjani',
    		lastName: 'Shettar',
    		score: 10,
    	});

    	function handlePlusClick() {
    		setPlayer({
    			...player, score: player.score + 1
    		})
    	}

    	function handleFirstNameChange(e) {
    		setPlayer({
    			...player,
    			firstName: e.target.value,
    		});
    	}

    	function handleLastNameChange(e) {
    		setPlayer({
    			...player,
    			lastName: e.target.value
    		});
    	}

    	return (
    		<>
    			<label>
    				Score: <b>{player.score}</b>
    				{' '}
    				<button onClick={handlePlusClick}>
    					+1
    				</button>
    			</label>
    			<label>
    				First name:
    				<input
    					value={player.firstName}
    					onChange={handleFirstNameChange}
    				/>
    			</label>
    			<label>
    				Last name:
    				<input
    					value={player.lastName}
    					onChange={handleLastNameChange}
    				/>
    			</label>
    		</>
    	);
    }

</code>

In handlePlusClick vi era una mutation dell'object player.
Ok handleFirstNameChange, in handleLastNameChange l'object player veniva sovrascritto, con un object con solo un property lastname presente.

Perfetto :white_check_mark:

2-

<code>
	const initialPosition = {
  x: 0,
  y: 0
	};

    export default function Canvas() {
    	const [shape, setShape] = useState({
    		color: 'orange',
    		position: initialPosition
    	});

    	function handleMove(dx, dy) {
    		setShape({
    			...shape,
    			position: {
    				x: shape.position.x + dx,
    				y: shape.position.y + dy
    			}
    		})
    	}

    	function handleColorChange(e) {
    		setShape({
    			...shape,
    			color: e.target.value
    		});
    	}

    	return (
    		<>
    			<select
    				value={shape.color}
    				onChange={handleColorChange}
    			>
    				<option value="orange">orange</option>
    				<option value="lightpink">lightpink</option>
    				<option value="aliceblue">aliceblue</option>
    			</select>
    			<Background
    				position={initialPosition}
    			/>
    			<Box
    				color={shape.color}
    				position={shape.position}
    				onMove={handleMove}
    			>
    				Drag me!
    			</Box>
    		</>
    	);
    }

</code>

Corretto :white_check_mark:

Attenzione += é sempre una mutation, usare + semplice.

3-

<code>
	const initialPosition = {
		x: 0,
		y: 0
	};

    export default function Canvas() {
    	const [shape, updateShape] = useImmer({
    		color: 'orange',
    		position: initialPosition
    	});

    	function handleMove(dx, dy) {
    		updateShape(draft => {
    			draft.position.x += dx;
    			draft.position.y += dy;
    		})

    	}

    	function handleColorChange(e) {
    		updateShape( draft => {
    			draft.color = e.target.value
    		});
    	}

    	return (
    		<>
    			<select
    				value={shape.color}
    				onChange={handleColorChange}
    			>
    				<option value="orange">orange</option>
    				<option value="lightpink">lightpink</option>
    				<option value="aliceblue">aliceblue</option>
    			</select>
    			<Background
    				position={initialPosition}
    			/>
    			<Box
    				color={shape.color}
    				position={shape.position}
    				onMove={handleMove}
    			>
    				Drag me!
    			</Box>
    		</>
    	);
    }

</code>

Perfetto :white_check_mark:

## 17. Updating Arrays in State

Gli Array sono mutabili in JavaScript, ma dovrebbero essere trattati come fossero immutabili quando vengono archiviati nello State. Proprio come gli objects, quando si vuole aggiornare un Array archiviato nello State, si ha bisogno di crearne uno nuovo (o farne una copia di uno esistente), e poi impostare lo State per usare il nuovo Array.

### 17.1. Updating arrays without mutation

In JavaScript, gli Array sono come ogni altro tipo di object.
Come gli objects, si dovrebbero trattare gli Array nello State di React come read-only. Questo significa che non si dovrebbero riassegnare gli items all'interno dell'Array come arr[0] = "bird", e che non si dovrebbero usare motodi per mutare l'Array, come push() o pop().

Invece, ogni volta che si vuole aggiornare un'Array, si dovrà passare un nuovo Array alla setter function dello State. Per farlo, si può creare un nuovo Array dall'Array originale nello State chiamando un Higher Order Function / non-mutating method come filter() o map(). Poi si può impostare lo State al risultante nuovo Array.

Qui si propone una tabella con le più comuni operazioni sugli Array. Quando si ha a che fare con gli Array dentro allo State di React, si deve evitare di usare i metodi alla sinistra, ed invece preferire i metodi nella colonna di destra:

<code>
		avoid (mutates) 			|	prefer (new array)

    adding	push, unshift	| concat, [...arr] spread syntax

    	removing	pop, shift, splice | 	filter, slice

    	replacing	splice, arr[i] = ... assignment | 	map

    	sorting	reverse, sort |	copy the array first

</code>

Alternativamente si può usare Immer che permette di usare i metodi da entrambe le colonne.

Nota: attenzione come sempre differenza slice e splice. Usare il primo non il secondo, visto che restituisce un nuovo Array.

### 17.2. Adding to an array

Il metodo push() muterà un Array, che é ciò che non si vuole.

<code>
	let nextId = 0;

    export default function ListArray() {
    	const [name, setName] = useState("");
    	const [artists, setArtists] = useState([]);

    	return (
    		<>
    			<h1>Inspiring sculptors</h1>
    			<input value={name} onChange={(event) => event.target.value} />
    			<button
    				onClick={() => {
    					artists.push({ id: nextId++, name: name });
    				}}
    			>
    				Add
    			</button>
    			<ul>
    				{artists.map((artist) => (
    					<li key={artist.id}>{artist.name}</li>
    				))}
    			</ul>
    		</>
    	);
    }

</code>

Invece, creare un nuovo Array che contiene gli items esistenti E un nuovo item alla fine. Vi sono molteplici modi di farlo, ma il più facile é usare la spread syntax degli Array ... invece:

<code>

    	<button
    				onClick={() => setArtists([...artists, { id: nextId++, name: name }])}
    			>
    				Add
    </button>

</code>

Quindi:

<code>
	export default function ListArray() {
		const [name, setName] = useState("");
		const [artists, setArtists] = useState([]);

    	return (
    		<>
    			<h1>Inspiring sculptors</h1>
    			<input value={name} onChange={(event) => setName(event.target.value)} />
    			<button
    				onClick={() => setArtists([...artists, { id: nextId++, name: name }])}
    			>
    				Add
    			</button>
    			<ul>
    				{artists.map((artist) => (
    					<li key={artist.id}>{artist.name}</li>
    				))}
    			</ul>
    		</>
    	);
    }

</code>

Ora funziona correttamente.

La spread syntax degli Array permette inoltre di far precedere un item aggiungendolo prima dell'Array originale ...artists:

<code>
		<button
				onClick={() => setArtists([{ id: nextId++, name: name }, ...artists])}
			>
				Add
		</button>
</code>

In questo modo, lo spread può fare sia il lavoro del metodo push() aggiungendo alla fine di un Array, sia si unshift() aggiungendo all'inizio dell'Array.

### 17.3. Removing from an array

Il modo più facile per rimuovere un item da un Array é usare filter(). Con questo si produce un nuovo Array che non conterrà un item in base ad una condizione. Per usarlo:

<code>
	export function FilteredList() {
		const [artists, setArtists] = useState(initialArtists);

    	return (
    		<>
    			<h1>Inspiring sculptors:</h1>
    			<ul>
    				{artists.map((artist) => (
    					<li key={artist.id}>
    						{artist.name}
    						<button
    							onClick={() => {
    								setArtists(artists.filter((a) => a.id !== artist.id));
    							}}
    						>
    							Delete
    						</button>
    					</li>
    				))}
    			</ul>
    		</>
    	);
    }

</code>

Qui premendo il tasto Delete l'Array verrà filtrato in base a quegli artists il cui ID é differente da artist.id, e poi verrà richiesto un re-render con il risultante Array. filter() non modifica l'Array originale ma ne restituisce uno nuovo.

### 17.4. Trasforming an array

Se si vuole cambiare alcuni o tutti gli items di Array, si può usare map() per creare un nuovo array. La funzione che si passa a map indica cosa fare con ogni item, in base ai suoi dati, ai loro index o entrambi.

In quest'esempio un Array ospita le coordinate di due cerchi ed un quadrato. Quando si preme il button, muove solamente i cerchi giù di 50px. Fa questo producendo un nuovo Array di dati usando map():

<code>

    let initialShapes = [
    	{ id: 0, type: 'circle', x: 50, y: 100 },
    	{ id: 1, type: 'square', x: 150, y: 100 },
    	{ id: 2, type: 'circle', x: 250, y: 100 },
    ];

    export default function ShapeEditor() {
    	const [shapes, setShapes] = useState(initialShapes);

    	function handleClick() {
    		const nextShapes = shapes.map((shape) => {
    			if (shape.type === "square") {
    				return shape;
    			} else {
    				return {
    					...shape,
    					y: shape.y + 50
    				};
    			}
    		});
    		setShapes(nextShapes);
    	}

    	return (
    		<>
    			<button onClick={handleClick}>Move circles down!</button>
    			{shapes.map((shape) => (
    				<div
    					key={shape.id}
    					style={{
    						background: "purple",
    						position: "absolute",
    						left: shape.x,
    						top: shape.y,
    						borderRadius: shape.type === "circle" ? "50%" : "",
    						width: 100,
    						height: 100
    					}}
    				></div>
    			))}
    		</>
    	);
    }

</code>

### 17.5. Replacing items in an array

E' particolarmente comune voler rimpiazzare uno o più items in un Array. Assegnamenti come arr[0] = "bird" sono mutazioni dell'Array originale, quindi é meglio usare map anche per questo.

Per rimpiazzare un item, occorre creare un nuovo Array con map. Dentro alla chiamata di map, si riceverà l'argument index come secondo argument della callback. Lo si può usare per decidere se restituire l'item originale, il primo argument, o qualcos'altro:

<code>
	let initialCounters = [0, 0, 0];

    export default function CounterList() {
    	const [counters, setCounters] = useState(initialCounters);

    	function handleIncrementClick(index) {
    		const nextCounters = counters.map((counter, i) => {
    			if (i === index) {
    				return counter + 1;
    			} else {
    				return c;
    			}
    		});
    		setCounters(nextCounters);
    	}
    }

    return (
    	<ul>
    		{counters.map((counter, index) => (
    			<li key={index}>
    				{counter}
    				<button
    					onClick={() => {
    						handleIncrementClick(index);
    					}}
    				></button>
    			</li>
    		))}
    	</ul>
    );

</code>

### 17.6. Inserting into an array

A volte si vuole inserire un item in una particolare posizione che può non essere ne all'inizio ne alla fine. Per fare questo si può usare l'Array spread syntax assieme al metodo slice(). Il metodo slice() permette di tagliare una "fetta" (slice) dell'Array. Per inserire un item, si creerà un Array che diffonde (spread) la slice prima del punto di inserimento, poi il new item e poi il resto dell'Array originale.

In questo esempio, l'Insert Button inserisce sempre all'index 1:

<code>
	let nextId = 3;

    const initialArtists = [
    	{ id: 0, name: "Marta Colvin Andrade" },
    	{ id: 1, name: "Lamidi Olonade Fakeye" },
    	{ id: 2, name: "Louise Nevelson" }
    ];

    export default function ListSpreadSlice() {
    	const [name, setName] = useState("");
    	const [artists, setArtists] = useState(initialArtists);

    	function handleClick() {
    		const insertAt = 1;
    		// può essere ogni index
    		const nextArtists = [
    			// items prima del punto di inserimento
    			...artists.slice(0, insertAt),
    			// nuovo item
    			{ id: nextId++, name: name },
    			// Items dopo il punto di inserimento
    			...artists.slice(insertAt)
    		];
    		setArtists(nextArtists);
    		setName("");
    	}

    	return (
    		<>
    			<h1>Inspiring sculptors:</h1>
    			<input value={name} onChange={(event) => setName(event.target.value)} />
    			<button onClick={handleClick}>Insert</button>
    			<ul>
    				{artists.map((artist) => (
    					<li key={artist.id}>{artist.name}</li>
    				))}
    			</ul>
    		</>
    	);
    }

</code>

### 17.7. Making other changes to an array

Vi sono altre cose che non si possono fare con la spread syntax e i non mutating methods come map e filter da soli. Per esempio si potrebbe voler invertire o ordinare diversamente un Array. I metodi di JavaScript reverse() e sort() muterebbero l'Array originale, quindi non possiamo usarli direttamente.

Comunque, si può copiare l'Array prima, e poi eseguirvi dei cambiamenti.

Per esempio:

<code>
	const listToReverse = [
		{ id: 0, title: "Big Bellies" },
		{ id: 1, title: "Lunar Landscape" },
		{ id: 2, title: "Terracotta Army" }
	];

    export function reverseList() {
    	const [list, setList] = useState(listToReverse);

    	function handleClick() {
    		const nextList = [...list];
    		nextList.reverse();
    		setList(nextList);
    	}

    	return (
    		<>
    			<button onClick={handleClick}>Reverse</button>
    			<ul>
    				{list.map((artwork) => {
    					<li key={artwork.id}>{artwork.title}</li>;
    				})}
    			</ul>
    		</>
    	);
    }

</code>

Qui usiamo la spread syntax [...list] per creare una copia dell'Array originale prima di tutto. Ora che si ha una copia, si possono usare i mutating methods come nextList.reverse() o nextList.sort(), o persino assegnare individualmente gli items con nextList[0] = "something".

Comunque, persino se si copia un Array, non si possono mutare direttamente gli items dentro ad esso direttamente. Questo perché la copia é shallow (poco profonda) - il nuovo Array conterrà gli stessi items dell'originale. Quindi se si modifica un object dentro l'Array copiato, si andrà a mutare lo State esistente. Per esempio un codice come questo é un problema:

<code>
	const nextLIst = [...list];
	nextList[0].sees = true // problema - mutamento di list[0]
	setList(nextList);
</code>

Anche se nextList e list sono sue diversi Array, nextList[0] e list[0] puntano allo stesso object. Quindi cambiando
nextList[0].seen si sta cambiando anche list[0].seen. Questa é una mutazione dello State, che si deve evitare.
Si può risolvere questo problema in modo similare all'aggiornarmento degli objects JavaScript annidati - copiando individualmente gli items che si vogliono cambiare invece che mutarli. Ecco come.

### 17.8. Updating objects inside arrays

Gli Objects non sono realmente localizzati "dentro" gli Array. Può sembrare che siano "dentro" il codice, ma ogni object in un Array é una value separata, che l'Array "punta". Questo é il motivo si necessita di attenzione quando si sta cambiando i fields annidati come list[0]. Una list artwork di un'altra persona potrebbe puntare allo stesso element dell'Array.

Quando si aggiornano gli State annidati, si ha bisogno di creare delle copie dal punto in cui si vuole aggiornare, e fino in fondo al top level.

In quest'esempio, due list artwork separate hanno lo stesso initial State. Si suppone siano isolate, ma a causa di una mutation, il loro State viene accidentalmente condiviso, e cambiare una box in una list ha effetto anche sull'altra:

<code>
	let nextId = 3;
	const initialList = [
		{ id: 0, title: "Big Bellies", seen: false },
		{ id: 1, title: "Lunar Landscape", seen: false },
		{ id: 2, title: "Terracotta Army", seen: true }
	];

    export default function BucketList() {
    	const [myList, setMyList] = useState(initialList);
    	const [yourList, setYourList] = useState(initialList);

    	function handleToggleMyList(artworkId, nextSeen) {
    		const myNextList = [...myList];
    		const artwork = myNextList.find((a) => a.id === artworkId);
    		artworkId.seen = nextSeen;
    		setMyList(myNextList);
    	}

    	function handleToggleYourList(artworkId, nextSeen) {
    		const yourNextList = [...yourList];
    		const artwork = yourNextList.find((a) => a.id === artworkId);
    		artwork.seen = nextSeen;
    		setYourList(yourNextList);
    	}

    	return (
    		<>
    			<h1>Art Bucket List</h1>
    			<h2>My list of art to see:</h2>
    			<ItemList artworks={myList} onToggle={handleToggleMyList} />
    			<h2>Your list of art to see:</h2>
    			<ItemList artworks={yourList} onToggle={handleToggleYourList} />
    		</>
    	);
    }

    function ItemList({ artworks, onToggle }) {
    	return (
    		<ul>
    			{artworks.map((artwork) => (
    				<li key={artwork.id}>
    					<label>
    						<input
    							type="checkbox"
    							checked={artwork.seen}
    							onChange={(event) => {
    								onToggle(artwork.id, event.target.checked);
    							}}
    						/>
    						{artwork.title}
    					</label>
    				</li>
    			))}
    		</ul>
    	);
    }

</code>

Il problema qui risiede nel codice:

<code>
		const myNextList = [...myList];
    const artwork = myNextList.find((a) => a.id === artworkId);
    artworkId.seen = nextSeen; 
		// <--- Problema - mutazione item esistente
    setMyList(myNextList);
</code>

Anche se l'Array myNextList stesso é nuovo, gli items stessi sono gli stesso identici dell'Array originale myList. Quindi cambiare artwork.seen cambia l'item artwork originale. Tale item artwork risiede anche in yourList, che causa il bug. Pensare a bugs come questi può essere difficoltoso, ma spariscono se si evita di mutare lo State.

Si può usare map per sostituire un vecchio item con la sua versione aggiornata senza mutazioni.

<code>
	function handleToggleMyList(artworkId, nextSeen) {
			setMyList(
				myList.map((artwork) => {
					if (artwork.id === artworkId) {
						// Crea un *nuovo* object con i cambiamenti
						return { ...artwork, seen: nextSeen };
					} else {
						return artwork;
					}
				})
			);
		}
</code>

Qui viene usata la object spread syntax per creare una copia di un object. Con questo approccio, nessuno degli items esistenti nello State viene mutato, e il bug viene sistemato:

<code>
	let nextId = 3;
	const initialList = [
		{ id: 0, title: "Big Bellies", seen: false },
		{ id: 1, title: "Lunar Landscape", seen: false },
		{ id: 2, title: "Terracotta Army", seen: true }
	];

    export default function BucketList() {
    	const [myList, setMyList] = useState(initialList);
    	const [yourList, setYourList] = useState(initialList);

    	function handleToggleMyList(artworkId, nextSeen) {
    		setMyList(
    			myList.map((artwork) => {
    				if (artwork.id === artworkId) {
    					return { ...artwork, seen: nextSeen };
    				} else {
    					return artwork;
    				}
    			})
    		);
    	}

    	function handleToggleYourList(artworkId, nextSeen) {
    		setMyList(
    			yourList.map((artwork) => {
    				if (artwork.id === artworkId) {
    					// Crea un *nuovo* object con i cambiamenti
    					return { ...artwork, seen: nextSeen };
    				} else {
    					return artwork;
    				}
    			})
    		);
    	}

    	return (
    		<>
    			<h1>Art Bucket List</h1>
    			<h2>My list of art to see:</h2>
    			<ItemList artworks={myList} onToggle={handleToggleMyList} />
    			<h2>Your list of art to see:</h2>
    			<ItemList artworks={yourList} onToggle={handleToggleYourList} />
    		</>
    	);
    }

    function ItemList({ artworks, onToggle }) {
    	return (
    		<ul>
    			{artworks.map((artwork) => (
    				<li key={artwork.id}>
    					<label>
    						<input
    							type="checkbox"
    							checked={artwork.seen}
    							onChange={(event) => {
    								onToggle(artwork.id, event.target.checked);
    							}}
    						/>
    						{artwork.title}
    					</label>
    				</li>
    			))}
    		</ul>
    	);
    }

</code>

In generale, si dovrebbero mutare solamente gli objects che hai appena creato. Se si ha inserito un nuovo artwork, si può mutarlo, ma se si sta avendo a che fare con qualcosa che é già nello State, occorre eseguirne una copia.

### 17.9. Write concise update logic with Immer

Aggiornare gli Array annidati senza mutation può essere un po' ripetitivo. Proprio come con gli objects:

- Generalmente, non si dovrebbe aver bisogno di aggiornare gli object a più di un paio di livelli di profondità. Se gli State objects sono molto in profondità, si potrebbe voler ristrutturarli differentemente, in modo che appaiano più livellati.

- Se non si vuole cambiare la struttura dello State, si potrebbe preferire l'uso di Immer, che permette di scrivere usando la syntax conveniente ma mutevole e si premura di creare delle copie degli objects.

Ecco l'esempio precedente riscritto con Immer:

<code>
	let nextId = 3;
	const initialList = [
		{ id: 0, title: "Big Bellies", seen: false },
		{ id: 1, title: "Lunar Landscape", seen: false },
		{ id: 2, title: "Terracotta Army", seen: true }
	];

    export default function BucketList() {
    	const [myList, updateMyList] = useImmer(initialList);
    	const [yourList, updateYourList] = useImmer(initialList);

    	function handleToggleMyList(id, nextSeen) {
    		updateMyList((draft) => {
    			const artwork = draft.find((a) => a.id === id);
    			artwork.seen = nextSeen;
    		});
    	}

    	function handleToggleYourList(id, nextSeen) {
    		updateYourList((draft) => {
    			const artwork = draft.find((a) => a.id === id);
    			artwork.seen = nextSeen;
    		});
    	}

    	return (
    		<>
    			<h1>Art Bucket List</h1>
    			<h2>My list of art to see:</h2>
    			<ItemList artworks={myList} onToggle={handleToggleMyList} />
    			<h2>Your list of art to see:</h2>
    			<ItemList artworks={yourList} onToggle={handleToggleYourList} />
    		</>
    	);
    }

    function ItemList({ artworks, onToggle }) {
    	return (
    		<ul>
    			{artworks.map((artwork) => (
    				<li key={artwork.id}>
    					<label>
    						<input
    							type="checkbox"
    							checked={artwork.seen}
    							onChange={(event) => {
    								onToggle(artwork.id, event.target.checked);
    							}}
    						/>
    						{artwork.title}
    					</label>
    				</li>
    			))}
    		</ul>
    	);
    }

</code>

Si noti come con Immer, la mutation come artwork.seen = nextSeen é normale:

<code>
updateMyList((draft) => {
			const artwork = draft.find((a) => a.id === id);
			artwork.seen = nextSeen;
		});
</code>

Questo perché non stiamo effettivamente mutando lo State originale, ma invece un object draft fornito da Immer. Similarmente, possiamo applicare metodi di mutazione come push() e pop() al content di draft.

Dietro le quinte, Immer costruisce sempre lo State successivo da zero in base ai cambiamenti che abbiamo effettuato al draft. Questo mantiene gli event handlers concisi senza mai mutare lo State.

### 17.10. Exercises

1 -

<code>
	const initialProducts = [
		{
			id: 0,
			name: "Baklava",
			count: 1
		},
		{
			id: 1,
			name: "Cheese",
			count: 5
		},
		{
			id: 2,
			name: "Spaghetti",
			count: 2
		}
	];

    export function ShoppingCart() {
    	const [products, setProducts] = useState(initialProducts);

    	function handleIncreaseClick(productId) {
    		setProducts(
    			products.map((product) => {
    				if (product.id === productId) {
    					return { ...product, count: product.count + 1 };
    				} else {
    					return product;
    				}
    			})
    		);
    	}

    	return (
    		<ul>
    			{products.map((product) => (
    				<li key={product.id}>
    					{product.name} (<b>{product.count}</b>)
    					<button
    						onClick={() => {
    							handleIncreaseClick(product.id);
    						}}
    					>
    						+
    					</button>
    				</li>
    			))}
    		</ul>
    	);
    }

</code>

Perfetto :white_check_mark:

2-

<code>
	import { useState } from 'react';

    const initialProducts = [{
    	id: 0,
    	name: 'Baklava',
    	count: 1,
    }, {
    	id: 1,
    	name: 'Cheese',
    	count: 5,
    },{
    	id: 2,
    	name: 'Pepper',
    	count: 5,
    }, {
    	id: 3,
    	name: 'Spaghetti',
    	count: 2,
    }];

    export default function ShoppingCart() {
    	const [
    		products,
    		setProducts
    	] = useState(initialProducts)

    	function handleIncreaseClick(productId) {
    		setProducts(products.map(product => {
    			if (product.id === productId) {
    				return {
    					...product,
    					count: product.count + 1
    				};
    			} else {
    				return product;
    			}
    		}))
    	}

    	function handleDecreaseClick(productId){
    		setProducts(products.map(product => {
    			if(product.id === productId && product.count > 0){
    				return {
    					...product, count: product.count - 1
    				}
    			} else  {
    				return product;
    			}
    		}).filter(product => {
    			return product.count > 0;
    		}))
    	}

    	return (
    		<ul>
    			{products.map(product => (
    				<li key={product.id}>
    					{product.name}
    					{' '}
    					(<b>{product.count}</b>)
    					<button onClick={() => {
    						handleIncreaseClick(product.id);
    					}}>
    						+
    					</button>
    					<button onClick={()=> {
    					handleDecreaseClick(product.id);
    					}}>
    						–
    					</button>
    				</li>
    			))}
    		</ul>
    	);
    }

</code>

Perfetto :white_check_mark:

3-

<code>
import { useState } from 'react';
import AddTodo from './AddTodo.js';
import TaskList from './TaskList.js';

    let nextId = 3;
    const initialTodos = [
    	{ id: 0, title: 'Buy milk', done: true },
    	{ id: 1, title: 'Eat tacos', done: false },
    	{ id: 2, title: 'Brew tea', done: false },
    ];

    export default function TaskApp() {
    	const [todos, setTodos] = useState(
    		initialTodos
    	);

    	function handleAddTodo(title) {
    		setTodos([...todos, {
    			id: nextId + 1,
    			title: title,
    			done: false
    		}])
    		nextId++;
    	}

    	function handleChangeTodo(nextTodo) {
    		setTodos(todos.map(t => {
    			if(t.id === nextTodo.id){
    				return {...t, title: nextTodo.title, done: nextTodo.done}
    			} else {
    				return t;
    			}
    		}))
    	}

    	function handleDeleteTodo(todoId) {
    		setTodos(todos.filter(t => {
    			return t.id !== todoId
    		}))
    	}

    	return (
    		<>
    			<AddTodo
    				onAddTodo={handleAddTodo}
    			/>
    			<TaskList
    				todos={todos}
    				onChangeTodo={handleChangeTodo}
    				onDeleteTodo={handleDeleteTodo}
    			/>
    		</>
    	);
    }

</code>

Perfetto :white_check_mark:

4-

<code>
	import { useImmer } from 'use-immer';
	import AddTodo from './AddTodo.js';
	import TaskList from './TaskList.js';

    let nextId = 3;
    const initialTodos = [
    	{ id: 0, title: 'Buy milk', done: true },
    	{ id: 1, title: 'Eat tacos', done: false },
    	{ id: 2, title: 'Brew tea', done: false },
    ];

    export default function TaskApp() {
    	const [todos, updateTodos] = useImmer(initialTodos);

    	function handleAddTodo(title) {
    		updateTodos(draft => {
    			draft.push({
    			id: nextId++,
    			title: title,
    			done: false
    		})
    		})
    	}

    	function handleChangeTodo(nextTodo) {
    		updateTodos(draft => {
    			const todo = draft.find(t =>
    			t.id === nextTodo.id
    		);
    		todo.title = nextTodo.title;
    		todo.done = nextTodo.done;
    		})

    	}

    	function handleDeleteTodo(todoId) {
    		updateTodos(draft => {
    			const index = draft.findIndex(t =>
    			t.id === todoId
    		);
    		draft.splice(index, 1);
    		})

    	}

    	return (
    		<>
    			<AddTodo
    				onAddTodo={handleAddTodo}
    			/>
    			<TaskList
    				todos={todos}
    				onChangeTodo={handleChangeTodo}
    				onDeleteTodo={handleDeleteTodo}
    			/>
    		</>
    	);
    }

</code>

Perfetto :white_check_mark:

## 18. Managing State

Mano a mano che l'applicazione cresce, viene d'aiuto essere più intenzionali riguardo a come lo state viene organizzato e come i dati scorrono tra i Components. Lo State ridondante o duplicato é una fonte comune di bug. In questo capitolo impareremo come strutturare i dati al meglio, come mantenere la logica dello State mantenibile e come condividere lo State tra Components distanti tra loro.

### 18.1 Reacting to input with state

Con React non si modificherà la UI dal codice direttamente. Per esempio, non si scriveranno comandi come "disabilita il button", "abilita il button" "mostra un message di successo" ecc. Invece si descriverà la UI che si desidera vedere per differenti visual States di un Component ("initial state", "typing state", "success state"), e poi attivare i cambiamenti dello State in risposta all'input di un utente. Questo é similare a come i designers pensano alla UI.

Ecco un quiz form creato usando React. Si noti come viene usata la variabile State "status" per determinare se abilitare o disabilitare il button submit, e se mostrare invece un message di successo.

<code>
	import React, { useState } from "react";

    export default function QuizForm() {
    	const [answer, setAnswer] = useState("");
    	const [error, setError] = useState(null);
    	const [status, setStatus] = useState("typing");

    	if (status === "success") {
    		return <h1>That's Right</h1>;
    	}

    	async function handleSubmit(event) {
    		event.preventDefault();
    		setStatus("submitting");
    		try {
    			await submitForm(answer);
    			setStatus("success");
    		} catch (err) {
    			setStatus("typing");
    			setError(err);
    		}
    	}

    	function handleTextareaChange(event) {
    		setAnswer(event.target.value);
    	}

    	return (
    		<>
    			<h2>City quiz</h2>
    			<p>
    				In which city is there a billboard that turns air into drinkable water?
    			</p>
    			<form onSubmit={handleSubmit}>
    				<textarea
    					value={answer}
    					onChange={handleTextareaChange}
    					disabled={status === "submitting"}
    				/>
    				<br />
    				<button disabled={answer.length === 0 || status === "submitting"}>
    					Submit
    				</button>
    				{error !== null && <p className="Error">{error.message}</p>}
    			</form>
    		</>
    	);
    }

    function submitForm(answer) {
    	// Pretend it's hitting the network.

    	return new Promise((resolve, reject) => {
    		setTimeout(() => {
    			let shouldError = answer.toLowerCase() !== "lima";
    			if (shouldError) {
    				reject(new Error("Good guess but a wrong answer. Try again!"));
    			} else {
    				resolve();
    			}
    		}, 1500);
    	});
    }

</code>

### 18.2. Choosing the state structure

Strutturare lo State al meglio può fare la differenza tra un Component che é favorevole alla modifica ed al debug e uno che é una costante fonte di bug.
Il principio più importante é che lo State non dovrebbe contenere informazioni ridondanti o duplicate.
Se vi é dello State non necessario, é facile dimenticare di aggiornarlo e questo potrebbe portare a dei bug.

Per esempio, questo form ha una State variable fullName ridondante:

<code>
	export default function FormStateStructureIntro() {
		const [firstName, setFirstName] = useState("");
		const [lastName, setLastName] = useState("");
		const [fullName, setFullName] = useState("");

    	function handleFirstNameChange(event) {
    		setFirstName(event.target.value);
    		setFullName(event.target.value + " " + lastName);
    	}

    	function handleLastNameChange(event) {
    		setLastName(event.target.value);
    		setFullName(firstName + " " + event.target.value);
    	}

    	return (
    		<>
    			<h2>Let's check you in</h2>
    			<label>
    				First name:
    				<input value={firstName} onChange={handleFirstNameChange} />
    			</label>
    			<label>
    				Last name:
    				<input value={lastName} onChange={handleLastNameChange} />
    			</label>
    			<p>
    				Last ticket will issued to: <b>{fullName}</b>
    			</p>
    		</>
    	);
    }

</code>

Si può semplicemente rimuoverlo e semplificare il codice calcolando fullName mentre il Component viene renderizzato:

<code>
	export default function FormStateStructureIntro() {
		const [firstName, setFirstName] = useState("");
		const [lastName, setLastName] = useState("");

    	const fullName = firstName + " " + lastName;

    	function handleFirstNameChange(event) {
    		setFirstName(event.target.value);
    	}

    	function handleLastNameChange(event) {
    		setLastName(event.target.value);
    	}

    	return (
    		<>
    			<h2>Let's check you in</h2>
    			<label>
    				First name:
    				<input value={firstName} onChange={handleFirstNameChange} />
    			</label>
    			<label>
    				Last name:
    				<input value={lastName} onChange={handleLastNameChange} />
    			</label>
    			<p>
    				Last ticket will issued to: <b>{fullName}</b>
    			</p>
    		</>
    	);
    }

</code>

Questo potrebbe sembrare un piccolo cambiamento, ma molti bug nelle React app vengono sistemati in questo modo.

### 18.3. Sharing state between components

A volte, si vuole che gli State di due Components cambino sempre insieme. Per farlo si può rimuovere lo State da entrambi, muoverlo in su nel loro parent comune più vicino e poi passarlo in giù a entrambi attraverso le prop. Questo viene definito "lifting state up", ed é una delle cose più comuni che si farà nel codice React.

In quest'esempio, solo un panel alla volta dovrebbe essere attivo. Per attivarlo, invece di mantenere un State active dentro ogni panel individualmente, il parent Component ospita lo State e specifica le props per i suoi children:

<code>
	export default function Accordion() {
		const [activeIndex, setActiveIndex] = useState(0);

    	return (
    		<>
    			<h2>Almaty, Kazakhstan</h2>
    			<Panel
    				title="About"
    				isActive={activeIndex === 0}
    				onShow={() => setActiveIndex(0)}
    			>
    				With a population of about 2 million, Almaty is Kazakhstan's largest
    				city. From 1929 to 1997, it was its capital city.
    			</Panel>
    			<Panel
    				title="Etymology"
    				isActive={activeIndex === 1}
    				onShow={activeIndex(1)}
    			>
    				The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for
    				"apple" and is often translated as "full of apples". In fact, the region
    				surrounding Almaty is thought to be the ancestral home of the apple, and
    				the wild <i lang="la">Malus sieversii</i> is considered a likely
    				candidate for the ancestor of the modern domestic apple.
    			</Panel>
    		</>
    	);
    }

    function Panel({ title, children, isActive, onShow }) {
    	return (
    		<section className="panel">
    			<h3>{title}</h3>
    			{isActive ? <p>{children}</p> : <button onClick={onShow}>Show</button>}
    		</section>
    	);
    }

</code>

### 18.4. Preserving and resetting state

Quando si re-renderizza un Component, React ha bisogno di decidere quali parti del tree tenere (e aggiornare) e quali parti scartare o ricreare da zero. In molti casi, il comportamento automatico di React funziona abbastanza bene. Di default, React preserva le parti del tree che "corrispondono" con il Component tree che é stato renderizzato precedentemente.

Comunque a volte questo non é ciò che si vuole. In questa Chat App, digitare un message e poi cambiare il destinatario non fa resettare l'input. Questo può far inviare un messaggio sbagliato all'utente:

<code>
	export default function Messanger() {
		const [to, setTo] = useState(contacts[0]);
		return (
			<div>
				<ContactList
					contacts={contacts}
					selectedContact={to}
					onSelect={(contact) => setTo(contact)}
				/>
				<Chat contact={to} />
			</div>
		);
	}

    const contacts = [
    	{ name: "Taylor", email: "taylor@mail.com" },
    	{ name: "Alice", email: "alice@mail.com" },
    	{ name: "Bob", email: "bob@mail.com" }
    ];

    function ContactList({ selectedContact, contacts, onSelect }) {
    	return (
    		<section className="contact-list">
    			<ul>
    				{contacts.map((contact) => (
    					<li key={contact.email}>
    						<button
    							onClick={() => {
    								onSelect(contact);
    							}}
    						>
    							{contact.name}
    						</button>
    					</li>
    				))}
    			</ul>
    		</section>
    	);
    }

    function Chat({ contact }) {
    	const [text, settext] = useState("");
    	return (
    		<section className="chat">
    			<textarea
    				value={text}
    				placeholder={"Chat to " + contact.name}
    				onChange={(event) => settext(event.target.value)}
    			/>
    			<br />
    			<button>Send to {contact.email}</button>
    		</section>
    	);
    }

</code>

React permette di sovrascrivere il comportamento di default, e forzare un Component a resettare il suo State passando a questo una key differente, come <Chat key={email} />.
Questo dice a React che se il destinatario é differente, dovrebbe essere considerato un Component Chat differente che necessita di essere ricreato da zero con nuovi dati (e UI come gli input). Ora passare tra i destinatari resetterà gli input fields, persino se si renderizza lo stesso Component:

<code>
	export default function Messanger() {
		const [to, setTo] = useState(contacts[0]);
		return (
			<div>
				<ContactList
					contacts={contacts}
					selectedContact={to}
					onSelect={(contact) => setTo(contact)}
				/>
				{/* <Chat contact={to} /> */}
				<Chat key={to.email} contact={to} />
			</div>
		);
	}
</code>

### 18.5. Extracting state logic into a reducer

I Components con molti aggiornamenti dello State attraverso molti event handlers possono essere opprimenti. Per questi casi, si può consolidare tutta la logica di aggiornamento dello State fuori dal Component in una singola funzione, chiamata "reducer".
Gli event handlers diventerrano più concisi perché specificheranno solo le "azioni" degli users. Alla fine del file, la reducer function specifica come lo State dovrebbe aggiornarsi in risposta ad ogni azione:

<code>
	import React, { useReducer } from "react";
	// import AddTask from "./AddTask.js";
	// import TaskList from "./TaskList.js";

    export default function TaskApp() {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	function handleAddTask(text) {
    		dispatch({
    			type: "added",
    			id: nextId++,
    			text: text
    		});
    	}

    	function handleChangeTask(taskId) {
    		dispatch({
    			type: "changed",
    			id: taskId
    		});
    	}

    	function handleDeleteTask(taskId) {
    		dispatch({
    			type: "deleted",
    			id: taskId
    		});
    	}

    	return (
    		<>
    			<h1>Prague Itinerary</h1>
    			<AddTask onAddTask={handleAddTask} />
    			<TaskList
    				tasks={tasks}
    				onChangeTask={handleChangeTask}
    				onDeleteTask={handleDeleteTask}
    			/>
    		</>
    	);
    }

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}

    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}

    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}

    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    let nextId = 3;
    const initialTasks = [
    	{ id: 0, text: "Visit Kafka Museum", done: true },
    	{ id: 1, text: "Watch a puppet show", done: false },
    	{ id: 2, text: "Lennon Wall pic", done: false }
    ];

</code>

### 18.6. Passing data deeply with context

Solitamente, si passano le informazioni da un parent Component ad un child Component attraverso le props. Ma passare le props può diventare sconveniente se vi é la necessità di passarle attraveso molti Components, o se diversi Components necessitano della stessa informazione. Il Context permette al parent Component di rendere alcune informazioni disponibili ad ogni Component nel tree al di sotto di esso, non importa quanto in profondità, senza passarle direttamente attraverso le props.

Qui, il Component Heading determina il suo livello di intestazione "chiedendo" alla più vicina Section per il suo livello. Ogni Section traccia il proprio livello chiedendo alla parent Section a aggiungendo 1 a questo. Ogni Section fornisce informazioni a tutti i Components al di sotto di essa senza passare props, lo fa attraverso il "context":

<code>

    LevelContext:

    import { createContext } from "react";

    export const LevelContext = createContext(0);

    Heading:

    export default function Heading({ children }) {
    	const level = useContext(LevelContext);

    	switch (level) {
    		case 0:
    			throw Error("Heading must be inside a Section!");
    		case 1:
    			return <h1>{children}</h1>;
    		case 2:
    			return <h2>{children}</h2>;
    		case 3:
    			return <h3>{children}</h3>;
    		case 4:
    			return <h4>{children}</h4>;
    		case 5:
    			return <h5>{children}</h5>;
    		case 6:
    			return <h6>{children}</h6>;
    		default:
    			throw Error("Unknown level: " + level);
    	}
    }


    Section:

    export default function Section({ children }) {
    	const level = useContext(LevelContext);
    	return (
    		<section className="section">
    			<LevelContext.Provider value={level + 1}>
    				{children}
    			</LevelContext.Provider>
    		</section>
    	);
    }

</code>

### 18.7. Scaling up with reducer and context

I reduceres permettono di consolidare la logica di aggiornamento dello State di un Component. Il Context permette di passare informazioni in profondità ad altri Components. Si possono combinare reducer e context insieme per gestire lo State di uno screen complesso.

Con questo approccio, un parent Component con uno State completo lo gestisce con un reducer. Gli altri Components messi ovunque in profondità nel tree possono leggere il suo State attraverso il context. Possono inoltre inviare (dispatch) azioni per aggiornare tale State:

<code>

    tasksList.jsx

    import React, { useState, useContext } from "react";
    import { useTasks, useTasksDispatch } from "./IntroTaskContextContext";

    export default function TaskList() {
    	const tasks = useTasks();
    	return (
    		<ul>
    			{tasks.map((task) => (
    				<li key={task.id}>
    					<Task task={task} />
    				</li>
    			))}
    		</ul>
    	);
    }

    function Task({ task }) {
    	const [isEditing, setIsEditing] = useState(false);
    	const dispatch = useTasksDispatch();
    	let taskContent;
    	if (isEditing) {
    		taskContent = (
    			<>
    				<input
    					value={task.text}
    					onChange={(event) => {
    						dispatch({
    							type: "changed",
    							task: {
    								...task,
    								text: event.target.value
    							}
    						});
    					}}
    				/>
    				<button onClick={() => setIsEditing(false)}>Save</button>
    			</>
    		);
    	} else {
    		taskContent = (
    			<>
    				{task.text}
    				<button onClick={() => setIsEditing(true)}>Edit</button>
    			</>
    		);
    	}
    	return (
    		<label>
    			<input
    				type="checkbox"
    				checked={task.done}
    				onChange={(event) => {
    					dispatch({
    						type: "changed",
    						task: {
    							...task,
    							done: event.target.ariaChecked
    						}
    					});
    				}}
    			/>
    			{taskContent}
    			<button
    				onClick={() => {
    					dispatch({ type: "deleted", id: task.id });
    				}}
    			>
    				Delete
    			</button>
    		</label>
    	);
    }


    --------------------


    addTask

    import React, { useState, useContext } from "react";
    import { useTasksDispatch } from "./IntroTaskContextContext";

    export default function AddTask({ onAddTask }) {
    	const [text, setText] = useState("");
    	const dispatch = useTasksDispatch();
    	return (
    		<>
    			<input
    				placeholder="Add task"
    				value={text}
    				onChange={(event) => setText(event.target.value)}
    			/>
    			<button
    				onClick={() => {
    					setText("");
    					dispatch({
    						type: "added",
    						id: nextId++,
    						text: text
    					});
    				}}
    			>
    				Add
    			</button>
    		</>
    	);
    }

    let nextId = 3;


    --------------------


    taskContext.jsx

    import React, { createContext, useContext, useReducer } from "react";

    const TaskContext = createContext(null);
    const TaskDispatchContext = createContext(null);

    export function TaskProvider({ children }) {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	return (
    		<TaskContext.Provider value={tasks}>
    			<TaskDispatchContext.Provider value={dispatch}>
    				{children}
    			</TaskDispatchContext.Provider>
    		</TaskContext.Provider>
    	);
    }

    export function useTasks() {
    	return useContext(TaskContext);
    }

    export function useTasksDispatch() {
    	return useContext(TaskDispatchContext);
    }

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    const initialTasks = [
    	{ id: 0, text: "Philosopher’s Path", done: true },
    	{ id: 1, text: "Visit the temple", done: false },
    	{ id: 2, text: "Drink matcha", done: false }
    ];

    --------------------

    App.jsx

    import IntroAddTaskContext from "./IntroAddTaskContext";
    import IntroTaskListContext from "./IntroTaskListContext";
    import { TasksProvider } from "./IntroTaskContextContext";

    export default function TaskApp() {
    	return (
    		<TasksProvider>
    			<h1>Day off in Kyoto</h1>
    			<IntroAddTaskContext />
    			<IntroTaskListContext />
    		</TasksProvider>
    	);
    }

</code>

## 19. Reacting to Input with State

React fornisce un modo dichiarativo (declarative) per manipolare la UI, al contrario del puro JavaScript che é imperativo. Invece di manipolare pezzi individuali della UI direttamente, si può descrivere i differti State in cui il Component può trovarsi, e passare tra questi in risposta all'input di uno user. Questo é similare a come i designers pensano alla UI.

### 19.1. How declarative UI compares to imperative

Quando si disegnano le interazioni della UI, probabilmente si penserà a come la UI cambia in risposta alle azioni dello user. Si consideri un Form che permette allo user di submit un risposta:

- Quando si digita qualcosa nel form, il "Submit" button si abilita.
- Quando si preme "Submit", sia il form che il button vengono disabilitati, e appare uno spinner.
- Se la network request ha successo, il form viene nascosto e il message "Thank you" appare.
- Se la network request fallisce, un message di errore appare, e il form viene abilitato nuovamente.

Nell' Imperative Programming, il contenuto sopra elencato corrisponde direttamente a come si implementa l'interzione. Occorre scrivere le istruzioni esatte per manipolare la UI in base a cosa é appena accaduto. Ecco un altro modo di pensare a questo: immaginiamo di andare in auto con qualcuno e dirgli passo per passo dove andare.
Chi guida non sa dove stiamo andando, segue solo le istruzioni, e se si dice una direzione sbagliata, si finisce nel posto sbagliato.
Viene definito "Imperative" perché bisigna "comandare" ogni element, dallo spinner al button, dicendo al computer COME aggiornare la UI.

In quest'esempio di Imperative programming, il form viene costruito senza React.js. Osa solamente il DOM del browser:

<code>
	async function handleFormSubmit(event) {
		event.preventDefault();
		disable(textarea);
		disable(button);
		show(loadingMessage);
		hide(errorMessage);
		try {
			await submitForm(textarea.value);
			show(successMessage);
			hide(form);
		} catch (error) {
			show(errorMessage);
			errorMessage.textContent = error.message;
		} finally {
			hide(loadingMessage);
			enable(textarea);
			enable(button);
		}
	}

    // ...

</code>

Manipolare in modo Imperative la UI funziona bene per esempi isolati, ma diviene esponenzialmente più difficile gestire sistemi più complessi. Immaginiamo di aggiornare una pagina piena di diversi form come questo appena visto. Aggiungere un nuovo element della UI o una nuova interazione richiederebbe un controllo meticoloso di tutto il codice esistente per essere sicuri che non siano stati introdotti dei bug, per esempio dimenticando di mostrare o nascondere qualcosa.

React.js é stato costruito per risolvere questo problema.

In React, non si deve manipolare direttamente la UI, significa che non si andrà ad abilitare, disabilitare o nascondere Components direttamente. Invece, si dichiara cosa si vuole mostrare, e React capisce come aggiornare la UI.
Immaginiamo di prendere un Taxi e dire all'autista dove si vuole andare invece di dirgli dove girare passo per passo. E' il lavoro dell'autista portarti a destinazione, e magari conosce anche una scorciatoia che tu non avresti considerato.

### 19.2. Thinking about UI declaratively

Sopra abbiamo visto come implementare un form in modo imperativo. Per capire meglio come pensare in React, percorreremo la reimplementazione di questa UI in React:

1. **Identifica** i differenti State visuali del Component
2. **Determina** cosa attiva questi cambi di State
3. **Rappresenta** lo State in memoria usando useState
4. **Rimuovi** tutte le State variables non necessarie
5. **Connetti** gli event handlers per impostare lo State

### 19.3. Step 1: Indentitfy your component's different visual states

In computer science il concetto di "state machine" è uno dei vari "states". Se si lavora con un designer, esistono i mockup per differenti "visual states". React si piazza nell'intersezione di design e computer science, quindi entrambe queste idee sono fonti di ispirazione.

Primo, occorre visualizzare i differenti "states" della UI che lo user potrebbe vedere:

- Empty: il Form ha un button "Submit" disabilitato
- Typing: il Form ha un button "Submit" abilitato
- Submitting: il Form é completamente disabilitato. Lo Spinner si mostra.
- Success: il message "Thank You" viene mostrato invece del Form
- Error: come lo state Typing, ma con un message di Error extra

Come un designer, si vorrà "mock up" o creare dei "mocks" per i differenti State prima di introdurre la logica. Per esempio, questo é un mock per la sola visual part del Form. Questo mock viene controllato da una prop chiamata "status" con una value di dafault "empty":

<code>

    export default function Form({ status = "empty" }) {
    	if (status === "success") {
    		return <h1>That's Right</h1>;
    	}
    	return (
    		<>
    			<h2>City quiz</h2>
    			<p>
    				In which city is there a billboard that turns air into drinkable water?
    			</p>
    			<form>
    				<textarea />
    				<br />
    				<button>Submit</button>
    			</form>
    		</>
    	);
    }

</code>

Si può chiamare tale prop come si vuole, il naming non é importante. Si provi a cambiare la default value in "success" per veder apparire il message. Il mocking permette di interagire con la UI prima di inserire qualsiasi logica.
Ecco un prototype più arricchito dello stesso Component, ancora controllato dalla prop status:

<code>
	export default function Form({ status = "empty" }) {
		// Try 'submitting', 'error', 'success':
		if (status === "success") {
			return <h1>That's Right</h1>;
		}
		return (
			<>
				<h2>City quiz</h2>
				<p>
					In which city is there a billboard that turns air into drinkable water?
				</p>
				<form>
					<textarea disabled={status === "submitting"} />
					<br />
					<button disabled={status === "empty" || status == "submitting"}>
						Submit
					</button>
					{status === "error" && (
						<p className="Error">Good guess but a wrong answer. Try again!</p>
					)}
				</form>
			</>
		);
	}
</code>

### 19.4. Displaying many visual states at once

Se un Component ha diversi visual States, potrebbe essere conveniente mostrarli tutti in una page:

<code>

    Importando il Form precendete:

    let statuses = ["empty", "typing", "submitting", "success", "error"];

    export default function Main() {
    	return (
    		<>
    			{statuses.map((status) => (
    				<section key={status}>
    					<h4>Form ({status}):</h4>
    					<Form status={status} />
    				</section>
    			))}
    		</>
    	);
    }

</code>

Pages come queste vengono di solito definite "living styleguides" o "storybooks".

### 19.5. Step 2: Determine what triggers those state changes

Si può attivare l'aggiornamento dello State in risposta a due tipi di input:

• Human inputs, come il click di un button, riempire un field navigare su un link

• Computer inputs, come una network response che arriva, un timeout completato, il caricamento di un'immagine.

In entrambi i casi bisogna impostare (set) le State variables per aggiornare la UI. Per il Form che stiamo sviluppando, abbiamo bisogno di cambiare lo State in response a diversi input:

• Il cambiamento del text input (human) dovrebbe far passare da un Empty State ad un Typing State e viceversa, in base la fatto se la text box é vuota o meno.

• Il click sul Submit button (human) dovrebbe far passare al Success State

• La network response Successful (computer) dovrebbe far passare al Success State

• La network response Failed (computer) dovrebbe far passare all'Error State con il corrispondente error message.

Nota: si noti che gli human inputs hanno spesso bisogno degli event handlers.

Per aiutare a visualizzare il flow, si provi a disegnare (vedi) ogni State su carta come un cerchio con label, e ogni cambiamento tra due States con una freccia. Si possono sempre disegnare dei flow in questo modo per aiutarci a scremare i bug prima dell'implementazione.

### 19.6. Step 3: Represent the state in memory with useState

In seguito si ha bisogno di rappresentare i visual States del Component in memoria con useState. La semplicità é la chiave: ogni pezzo dello State é un "pezzo mobile" e si vuole il minor numero possibile di pezzi mobili. Maggior complessità porta ad un maggior numero di bug.

Si cominci con lo State che assolutamente deve esserci. Per esempio, si ha bisogno di archiviare lo State "answer" per l'input e quello "error" per archiviare l'ultimo error:

<code>
	const [answer, setAnswer] = useState("");
	const [error, setError] = useState(null);
</code>

Poi si avrà bisogno di una State Variable che rappresenti quale degli visual state si vuole visualizzare. Di solito vi é più di un singolo modo per rappresentarlo nella memoria, quindi avremo bisogno di sperimentare con questo.

Se si é combattuti nel pensare al modo migliore nell'immediatezza, si cominci aggiungendo abbastanza State da essere certamente sicuri che tutti i possibili visual state siano coperti:

<code>
	const [isEmpty, setIsEmpty] = useState(true);
	const [isTyping, setIsTyping] = useState(false);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [isSuccess, setIsSuccess] = useState(false);
	const [isError, setIsError] = useState(false);
</code>

La prima idea potrebbe non essere stata la migliore, ma si provvederà in seguito con il refactoring.

### 19.7. Step 4: Remove any non-essetial state variables

Si vogliono evitare duplicati nel content dello State in modo da tenere traccia solo dell'essenziale. Passare un po' di tempo sul refactoring della struttura dello State renderà i Components facili da capire, ridurrà la duplicazione ed eviterà significati non previsti.
L'obiettivo é prevenire i casi nei quali lo State in memoria non rappresenti nessuna valida UI che non si voglia che lo user veda. Per esempio, non si vorrà mai mostrare un message d'errore e disabilitare l'input allo stesso tempo, o l'utente non sarà mai in grado di correggere l'errore.

Ecco alcune domande da porsi riguardo le proprie State Variables:

• Causerà un paradosso? Per esempio, isTyping e isSubmitting non possono essere entrambe true. Un paradosso di solito significa che lo State non é abbastanza vincolato. Vi sono quattro possibili combinazioni di due boolean, ma solo tre corrispondono a State validi. Per rimuovere lo State "impossibile", si può combianare questi in uno "status" che dovrà essere uno di queste tre values: "typing", "submitting" o "success".

• La stessa informazione é già disponibile in un'altra State Variable? Un altro paradosso: isEmpty e isTyping non possono essere true allo stesso momento. Rendendole delle State Variables separate, il rischio é che vadano fuori sincronia e causino bugs. Fortunatamente, si può rimuovere isEmpty ed al suo posto controllare anser.length === 0.

• Si può ottenere la stessa informazione dall'inverso di un'altra State Variable? isError non é necessaria perché si può controllare error !== null al suo posto.

Dopo questa pulizia, ne rimangono quindi solo 3. Le State Variables essenziali.

<code>
	const [answer, setAnswer] = useState("");
	const [error, setError] = useState(null);
	
	const [status, setStatus] = useState("typing");
	// <--- "typing, "submitting" oppure "success"

</code>

### 19.8. Eliminating "impossible" states with a reducer

Queste tre variabili sono una rappresentazione abbastanza buona dello State di questo Form.
Comunque vi sono ancora degli States intermedi che non hanno comletamente senso. Per esempio, un non-null error non ha senso quando status é "success". Per modellare lo State in modo più preciso, si può estrarlo in un reducer. I Reducers permettono di unificare molteplici State variables in un singolo object e consolidare tutta la logica relativa.

### 19.9. Step 5: Connect the event handlers to set state

Come ultima cosa, occorre creare gli event handlers che aggiornano lo State. Qui sotto vi é la forma finale, con tutti gli event handlers cablati:

<code>
	export default function Form({ status = "empty" }) {
		const [answer, setAnswer] = useState("");
		const [error, setError] = useState(null);
		const [status, setStatus] = useState("typing");

    	if (status === "success") {
    		return <h1>That's Right</h1>;
    	}

    	async function handleSubmit(event) {
    		event.preventDefault();
    		setStatus("submitting");
    		try {
    			await submitForm(answer);
    			setStatus("success");
    		} catch (err) {
    			setStatus("typing");
    			setError(err);
    		}
    	}

    	function handleTextareaChange(event) {
    		setAnswer(event.target.value);
    	}

    	return (
    		<>
    			<h2>City quiz</h2>
    			<p>
    				In which city is there a billboard that turns air into drinkable water?
    			</p>
    			<form onSubmit={handleSubmit}>
    				<textarea
    					value={answer}
    					onChange={handleTextareaChange}
    					disabled={status === "submitting"}
    				/>
    				<br />
    				<button disabled={status === "empty" || status === "submitting"}>
    					Submit
    				</button>
    				{error !== null && (
    					<p className="Error">Good guess but a wrong answer. Try again!</p>
    				)}
    			</form>
    		</>
    	);
    }

    function submitForm(answer) {
    	// pretend it's hitting the network
    	return new Promise((resolve, reject) => {
    		setTimeout(() => {
    			let shouldError = answer.toLowerCase() !== "lima";
    			if (shouldError) {
    				reject(new Error("Good guess but a wrong answer. Try again!"));
    			} else {
    				resolve();
    			}
    		}, 1500);
    	});
    }

</code>

Sebbene questo codice sia un po' più lungo dell'originale esempio Imperative, é molto meno fragile. Esprimere tutte le interazioni come cambiamenti dello State permette di introdurre in seguito dei nuovi visual states rompendo quelli esistenti. Permette inoltre di cambiare cosa dovrebbe essere visualizzato in ogni State senza cambiare la logica di interazione stessa.

### 19.10. Exercises

1-
Migliore soluzione uso event delegation

<code>
	export default function Picture() {

    	const [activeStatus, setActiveStatus] = useState(true);

    	function handleClick(event){
    		if(event.target.tagName === "DIV"){
    			setActiveStatus(true);
    		} else if(event.target.tagName === "IMG"){
    			setActiveStatus(false);
    		}
    	}

    	return (
    		<div onClick={handleClick} className={activeStatus ? "background background--active" : "background"}>
    			<img
    				className={activeStatus ? "picture" : "picture--active"}
    				alt="Rainbow houses in Kampung Pelangi, Indonesia"
    				src="https://i.imgur.com/5qwVYb1.jpeg"
    			/>
    		</div>
    	);
    }

</code>

Corretto :white_check_mark:

Soluzione tutorial usare event.stopPropagation su image, con event handlers inline.

Alternativa fornire JSX diverso in base alla value dello State.

2-

<code>
	import {useState} from "react";

    export default function EditProfile() {

    	const [isEdit, setIsEdit] = useState(false);
    	const [firstName, setFirstName] = useState("Jane");
    	const [lastName, setLastName] = useState("Jacobs")

    	function handleClick(event){
    		setIsEdit((prevEdit) => !prevEdit);
    	}
    	return (
    		<form onSubmit={(event) => event.preventDefault()}>
    			<label>
    				First name:{' '}
    				{isEdit ? <input onChange={(event) => setFirstName(event.target.value)} value={firstName}/> : <b>{firstName}</b>}
    			</label>
    			<label>
    				Last name:{' '}
    				{isEdit ? <input onChange={(event) => setLastName(event.target.value)} value={lastName}/> : <b>{lastName}</b>}
    			</label>
    			<button onClick={handleClick} type="submit">
    				{isEdit ? "Save Profile" : "Edit Profile"}
    			</button>
    			<p><i>Hello, {firstName} {lastName}!</i></p>
    		</form>
    	);
    }

</code>

Quasi Perfetto :white_check_mark:

3-

<code>
	let firstName = 'Jane';
	let lastName = 'Jacobs';
	let isEditing = false;

    function handleFormSubmit(e) {
    	e.preventDefault();
    	setIsEditing(!isEditing);
    }

    function handleFirstNameChange(e) {
    	setFirstName(e.target.value);
    }

    function handleLastNameChange(e) {
    	setLastName(e.target.value);
    }

    function setFirstName(value) {
    	firstName = value;
    	updateDOM();
    }

    function setLastName(value) {
    	lastName = value;
    	updateDOM();
    }

    function setIsEditing(value) {
    	isEditing = value;
    	updateDOM();
    }

    function updateDOM() {
    	if (isEditing) {
    		editButton.textContent = 'Save Profile';

    		show(firstNameInput);
    		show(lastNameInput);
    		hide(firstNameText);
    		hide(lastNameText);
    		// TODO: show inputs, hide content


    	} else {
    		editButton.textContent = 'Edit Profile';
    		hide(firstNameInput);
    		hide(lastNameInput);
    		show(firstNameText);
    		show(lastNameText);
    		// TODO: hide inputs, show content
    	}
    	// TODO: update text labels
    	firstNameText.textContent = firstNameInput.value;
    	lastNameText.textContent = lastNameInput.value;
    	helloText.textContent = " Hello " + firstName + " " + lastName;
    }

    function hide(el) {
    	el.style.display = 'none';
    }

    function show(el) {
    	el.style.display = '';
    }

    let form = document.getElementById('form');
    let editButton = document.getElementById('editButton');
    let firstNameInput = document.getElementById('firstNameInput');
    let firstNameText = document.getElementById('firstNameText');
    let lastNameInput = document.getElementById('lastNameInput');
    let lastNameText = document.getElementById('lastNameText');
    let helloText = document.getElementById('helloText');
    form.onsubmit = handleFormSubmit;
    firstNameInput.oninput = handleFirstNameChange;
    lastNameInput.oninput = handleLastNameChange;

</code>

Quasi Perfetto :white_check_mark:

## 20. Choosing the State Structure

Strutturare al meglio lo State può fare la differnza tra un Component nel quale é facile effettuare modifiche ed eliminare bug, e uno che diventerà una costnate fonte di bug. Ecco alcuni suggerimenti che si dovrebbero considerare quando si struttura lo State.

### 20.1. Priciples for structuring state

Quando si scrive un Component che ospita lo State, occorrerà effettuare delle scelte riguardo a quante State variables usare e quale forma dare ai loro dati. Anche se é possibile scrivere programmi corretti anche con una struttura dello State subottimale, vi sono alcuni principi che possono guidarci per effettuare scelte migliori:

1. **Raggruppare lo State relazionato**. Se si aggionano sempre due o più State Variables allo stesso tempo, si consideri l'idea di fonderle insieme in una singola State Variable.

2. **Evitare contraddizioni nello State**. Quando lo State é strutturato in modo che vari pezzi di State possano contraddirsi ed "essere in disaccordo" tra loro, si lascia spazio agli errori. Meglio evitare

3. **Evitare State ridondante**. Se si possono calcolare delle informazioni dalle prop del Component o dalle sue State Variables esistenti durante il rendering, non si dovrebbero inserire tali infomazioni hard coded nello State del Component.

4. **Evitare duplicazioni nello State**. Quando gli stessi dati sono duplicati tra molteplici State Variables, o tra objects annidati, é molto più difficile tenerli in sincronia. Ridurre la duplicazione dove si può.

5. **Evitare State annidato in profondità**. Le gerarchie in profondità nello State non sono convenienti da aggiornare. Quando possibile meglio preferire una struttura Flat dello State.

L'obiettivo dietro questi principi é rendere lo State facile da aggiornare senza introdurre errori. Rimuovere i dati ridondanti e duplicati dallo State aiuta ad assicurare che tutti i suoi pezzi restino sincronizzati. Questo é similare a come quando in un database si vuole "normalizzare" la struttura di un database per ridurre le possibilità di bug. Per parafrasare Einstein:
"Occorre rendere lo State il più semplice possibile, ma non più semplice".

Ora vediamo questi principi in azione.

### 20.2. Group related state

A volte si potrebbe essere indecisi tra l'usare una singola o multiple State Variables.

Si dovrebbe fare questo?

<code>
	const [x, setX] = useState(0);
	const [y, setY] = useState(0);
</code>

O questo?

<code>
	const [position, setPosition] = useState({ x: 0, y: 0 });
</code>

Tecnicamente si possono usare entrambi questi approcci. Ma se due State Variables cambiano sempre insieme, potrebbe essere una buona idea riunirle in una singola State Variable. Così non si dimenticherà di tenerle in sincronia, come in quest'esempio dove muovendo il cursore di aggiornano entrambe le coordinate del punto rosso:

<code>
	export default function MovingDot() {
		const [position, setPosition] = useState({
			x: 0,
			y: 0
		});
		return (
			<div
				onPointerMove={(event) => {
					setPosition({
						x: event.clientX,
						y: event.clientY
					});
				}}
				style={{ position: "relative", width: "100vw", height: "100vh" }}
			>
				<div
					style={{
						position: "absolute",
						backgroundColor: "red",
						borderRadius: "50%",
						transform: `translate(${position.x}px, ${position.y}px)`,
						left: -10,
						top: -10,
						width: 20,
						height: 20
					}}
				></div>
			</div>
		);
</code>

Un altro caso in cui conviene raggruppare i dati in un object o in un array é quando non si sa quanti pezzi di State si necessiteranno. Per esempio, torna utile quando si ha un form dove l'utente può aggiungere dei field personalizzati.

Nota: Se lo State é un object, si ricordi che non si può aggionare solamente un field in questo senza copiare esplicitamente gli altri field. Per esempio, non possiamo usare setPosition({x: 100}) nell'esempio sopra riportato, perché non avrà affatto la property y. Invece se si volesse impostare la solamente la x, si dovrebbe fare come setPosition({...position, x: 100}), o dividere in due State variables.

### 20.3. Avoid contradictions in state

Ecco un form per il feedback di un hotel con le State variables isSending e isSent:

<code>
	export default function FeedbackForm() {
		const [text, setText] = useState("");
		const [isSending, setIsSending] = useState(false);
		const [isSent, setIsSent] = useState(false);

    	async function handleSubmit(event) {
    		event.preventDefault();
    		setIsSending(true);
    		await sendMessage(text);
    		setIsSending(false);
    		setIsSent(true);
    	}

    	if (isSent) {
    		return <h1>Thanks for feedback!</h1>;
    	}

    	return (
    		<form onSubmit={handleSubmit}>
    			<p>How was your stay at The Prancing Pony?</p>
    			<textarea
    				disabled={isSending}
    				value={text}
    				onChange={(event) => setText(event.target.value)}
    			/>
    			<br />
    			<button disabled={isSending} type="submit">
    				Send
    			</button>
    			{isSending && <p>Sending...</p>}
    		</form>
    	);
    }

    function sendMessage(text) {
    	return new Promise((resolve) => {
    		setTimeout(resolve, 2000);
    	});
    }

</code>

Mentre questo codice lavora, lascia la porta aperta a degli "impossible" states. Per esempio, se si dimentica di chiamare setIsSent e setIsSending insieme, si potrebbe inccappare nella situazione dove sia isSending che isSent sono true allo stesso momento. Più complesso é un Component, più difficile é capire cosa accade.

Visto che isSending e isSent non dovrebbero mai essere true allo stesso momento, é meglio sostituirli con una State Variable "status" che può avere uno di questi tre State validi: "typing", quello iniziale, "sending" e "sent".

<code>
	export default function FeedbackForm() {
		const [text, setText] = useState("");
		const [status, setStatus] = useState("typing");

    	async function handleSubmit(event) {
    		event.preventDefault();
    		setStatus("sending");
    		await sendMessage(text);
    		setStatus("sent");
    	}

    	// per leggibilità
    	const isSending = status === "sending";
    	const isSent = status === "sent";
    	// per leggibilità

    	if (isSent) {
    		return <h1>Thanks fro feedback!</h1>;
    	}

    	return (
    		<form onSubmit={handleSubmit}>
    			<p>How was your stay at The Prancing Pony?</p>
    			<textarea
    				disabled={isSending}
    				value={text}
    				onChange={(event) => setText(event.target.value)}
    			/>
    			<br />
    			<button disabled={isSending} type="submit">
    				Send
    			</button>
    			{isSending && <p>Sending...</p>}
    		</form>
    	);
    }

    function sendMessage(text) {
    	return new Promise((resolve) => {
    		setTimeout(resolve, 2000);
    	});
    }

</code>

Si possono anche dichiarare delle costanti per migliorare la leggibilità:

<code>
		const isSending = status === "sending";
		const isSent = status === "sent";
</code>

Ma queste non sono State Variables, non vi é necessità di preoccuoparsi riguardo al fatto che restino sincronizzate l'una con l'altra.

### 20.4. Avoid redundant state

Se si possono calcolare delle infomazioni dalle prop del Component o dalla sue State Variables esistenti durante il rendering, non si dovrebbero inserire tali informazioni dentro lo State di tale Component.

Per esempio questo Form funziona, ma si può osservare dello State ridondante:

<code>
	export default function Form() {
		const [firstName, setFirstName] = useState('');
		const [lastName, setLastName] = useState('');
		const [fullName, setFullName] = useState('');

    	function handleFirstNameChange(e) {
    		setFirstName(e.target.value);
    		setFullName(e.target.value + ' ' + lastName);
    	}

    	function handleLastNameChange(e) {
    		setLastName(e.target.value);
    		setFullName(firstName + ' ' + e.target.value);
    	}

    	return (
    		<>
    			<h2>Let’s check you in</h2>
    			<label>
    				First name:{' '}
    				<input
    					value={firstName}
    					onChange={handleFirstNameChange}
    				/>
    			</label>
    			<label>
    				Last name:{' '}
    				<input
    					value={lastName}
    					onChange={handleLastNameChange}
    				/>
    			</label>
    			<p>
    				Your ticket will be issued to: <b>{fullName}</b>
    			</p>
    		</>
    	);
    }

</code>

Questo Form ha tre State Variables: firstName, lastName e fullName. Comunque, fullName é ridondante. Si può sempre calcolare fullName da firstName e lastName durante il render, quindi conviene rimuoverlo dallo State, per esempio sommando firstName e lastName in una costante fullName che viene calcolata durante il rendering:

<code>
	const fullName = firstName + ' ' + lastName;
</code>

Come risultato, i change handlers non hanno bisogno di fare niente di speciale per aggiornarlo. Quando si chiama setFirstName o setLastName, si attiva un re-render, e poi il prossimo fullName sarà calcolato da i dati freschi.

### 20.5. Don't mirror props in state

Un comune esempio di State ridondante potrebbe essere:

<code>
	function Message({ messageColor }) {
		const [color, setColor] = useState(messageColor);
</code>

Qui, una State Variable "color" viene inizializzato con la prop messageColor. Il problema é che se il parent Component passa una una differente value di messageColor più tardi, la State Variable "color" non sarà aggiornata. Lo State viene inizializzato solamente durante il primo render.

Per questo il "mirroring" delle prop in una State variable può portare confusione. Invece conviene usare la prop messageColor direttamente nel codice. Se si vuole per esempio accorciare il name, si usi una costante:

<code>
	function Message({messageColor}){
		const color = messageColor;
	}
</code>

In questo modo non sarà desincronizzato dalla prop passata dal parent Component.

Il "mirroring" delle prop nello State prende senso quando si vuole ignorare ogni aggiornamento di una sepcifica prop. Per convenzione, conviene iniziare il name della prop con initial o default per chiarire che le nuove value verranno ignorate:

<code>
	function Message({initialColor}){
		const [color, setColor] = useState(initialColor);
	}
</code>

La State Variable color ospita la prima value di initialColor, gli ulteriori cambiamenti alla prop initialColor verranno ignorati.

### 20.6. Avoid duplication in state

Questo Component menu list permette di scegliere uno snack da viaggio tra tanti:

<code>
	const initialItems = [
		{ title: "pretzels", id: 0 },
		{ title: "crispy seaweed", id: 1 },
		{ title: "granola bar", id: 2 }
	];

    export default function Menu() {
    	const [items, setItems] = useState(initialItems);
    	const [selectedItem, setSelectedItem] = useState(items[0]);

    	return (
    		<>
    			<h2>What's your travel snack?</h2>
    			<ul>
    				{items.map((item) => (
    					<li key={item.id}>
    						{item.title}
    						<br />
    						<button onClick={() => setSelectedItem(item)}>Choose</button>
    					</li>
    				))}
    			</ul>
    			<p>You picked {selectedItem.title}</p>
    		</>
    	);
    }

</code>

Ora, questo archivia l'item selezionato come un object nella State Variable selectedItem. In ogni caso, non é una gran cosa: il content di selectedItem é un object tra quelli dentro alla lista items. Questo significa che le informazioni sull'item stesso sono duplicate in due posti.

Perché questo é un problema? Rendiamo ogni item editabile per capirlo:

<code>
	const initialItems = [
		{ title: "pretzels", id: 0 },
		{ title: "crispy seaweed", id: 1 },
		{ title: "granola bar", id: 2 }
	];

    export default function Menu() {
    	const [items, setItems] = useState(initialItems);
    	const [selectedItem, setSelectedItem] = useState(items[0]);

    	function handleItemChange(id, event) {
    		setItems(
    			items.map((item) => {
    				if (item.id === id) {
    					return {
    						...item,
    						title: event.target.value
    					};
    				}
    			})
    		);
    	}

    	return (
    		<>
    			<h2>What's your travel snack?</h2>
    			<ul>
    				{items.map((item) => (
    					<li key={item.id}>
    						<input
    							value={item.title}
    							onChange={(event) => {
    								handleItemChange(item.id, event);
    							}}
    						/>
    						<br />
    						<button onClick={() => setSelectedItem(item)}>Choose</button>
    					</li>
    				))}
    			</ul>
    			<p>You picked {selectedItem.title}</p>
    		</>
    	);
    }

</code>

Si noti come se prima si clicka "Choose" su un item e poi lo si edita, l'input si aggiorna ma la label nella parte inferiore non riflette i cambiamenti apportati. Questo perché si ha duplicato lo State ma non aggiornato selectedItem.

Anche se si può aggiornare selectedItem, una più facile soluzione é rimuovere la duplicazione. In quest'esempio, invece di un object selectedItem (che crea una duplicazione con objects dentro ad items), si ospita selectedId nello State, e solo poi otteniamo la selectedItem cercando nell'Array items un item con tale ID:

<code>
	const initialItems = [
		{ title: "pretzels", id: 0 },
		{ title: "crispy seaweed", id: 1 },
		{ title: "granola bar", id: 2 }
	];

    export default function Menu() {
    	const [items, setItems] = useState(initialItems);
    	// const [selectedItem, setSelectedItem] = useState(items[0]);
    	const [selectedId, setSelectedId] = useState(0);

    	const selectedItem = items.find((item) => item.id === selectedId);

    	function handleItemChange(id, event) {
    		setItems(
    			items.map((item) => {
    				if (item.id === id) {
    					return {
    						...item,
    						title: event.target.value
    					};
    				} else {
    					return item;
    				}
    			})
    		);
    	}

    	return (
    		<>
    			<h2>What's your travel snack?</h2>
    			<ul>
    				{items.map((item) => (
    					<li key={item.id}>
    						<input
    							value={item.title}
    							onChange={(event) => {
    								handleItemChange(item.id, event);
    							}}
    						/>
    						<br />
    						<button onClick={() => setSelectedId(item.id)}>Choose</button>
    					</li>
    				))}
    			</ul>
    			<p>You picked {selectedItem.title}</p>
    		</>
    	);

</code>

Alternativamente si può ospitare l'index selezionato nello State.

Lo State viene di solito duplicato come questo:

• items = [{id: 0, title: "pretzels"},...]
• selectedItem = {id: 0, title: "pretezels}

Ma dopo il cambiamento é come questo:

• items = [{id: 0, title: "pretzels"},...]
• selectedId = 0

La duplicazione é andata, e si mantiente solo lo State essenziale.

Ora si può editare l'item selezionato, il message sottostante si aggionerà immediatamente. Questo perché setItems attiva un re-render, e items.find(...) troverà l'item con il title aggiornato. Non vi é un bisogno effettivo di ospitare il selected item nello State, questo perché solo il selected ID é essenziale. Il resto può essere calcolato durante il render.

### 20.7. Avoid deeply nested state

Immaginiamo di avere un piano di viaggio che consiste in pianeti, continenti e paesi. Si potrebbe essere tentati di strutturare lo State usando gli objects annidati e gli Array, come in questo esempio:

<code>

    import { useState } from "react";
    import { initialTravelPlan } from "../places";

    function PlaceTree({ place }) {
    	const childPlaces = place.childPlaces;
    	return (
    		<li>
    			{place.title}
    			{childPlaces.length > 0 && (
    				<ol>
    					{childPlaces.map((place) => (
    						<PlaceTree key={place.id} place={place} />
    					))}
    				</ol>
    			)}
    		</li>
    	);
    }

    export default function TravelPlan() {
    	const [plan, setPlan] = useState(initialTravelPlan);
    	const planets = plan.childPlaces;
    	return (
    		<>
    			<h2>Places to visit</h2>
    			<ol>
    				{planets.map((place) => (
    					<PlaceTree key={place.id} place={place} />
    				))}
    			</ol>
    		</>
    	);
    }

</code>
 
Ora diciamo di voler aggiungere un button per cancellare un place già visitato. Come potremmo fare? Aggiornare lo State nested implica creare copie degli objects per tutti i piani superiori alla parte che deve essere cambiata. Cancellare un place annidato in profondità implica copiare parti intere della parent chain. Tale codice può essere molto prolisso.

Se lo State é troppo annidato per aggiornarlo facilmente, occorre considerare di renderlo "flat". Ecco un modo nel quale si possono ristrutturare questi dati. Invece di una struttura tree-like dove ogni place ha un Array di child places, si può avere ogni place ospitato in un Array, con ogni place che ospita un Array di ID relativi ai suoi child places. Poi archiviare un mapping per ogni place ID al corrispondente place.

Questi dati ristrutturati possono ricordare alla vista una database table:

<code>
	export const initialTravelPlan = {
		0: {
			id: 0,
			title: '(Root)',
			childIds: [1, 43, 47],
		},
		1: {
			id: 1,
			title: 'Earth',
			childIds: [2, 10, 19, 27, 35]
		},
		2: {
			id: 2,
			title: 'Africa',
			childIds: [3, 4, 5, 6 , 7, 8, 9]
		}, 
		3: {
			id: 3,
			title: 'Botswana',
			childIds: []
		},
		4: {
			id: 4,
			title: 'Egypt',
			childIds: []
		},
		5: {
			id: 5,
			title: 'Kenya',
			childIds: []
		},
		6: {
			id: 6,
			title: 'Madagascar',
			childIds: []
		}, 
		7: {
			id: 7,
			title: 'Morocco',
			childIds: []
		},
		8: {
			id: 8,
			title: 'Nigeria',
			childIds: []
		},
		9: {
			id: 9,
			title: 'South Africa',
			childIds: []
		},
		10: {
			id: 10,
			title: 'Americas',
			childIds: [11, 12, 13, 14, 15, 16, 17, 18],   
		},
		11: {
			id: 11,
			title: 'Argentina',
			childIds: []
		},
		12: {
			id: 12,
			title: 'Brazil',
			childIds: []
		},
		13: {
			id: 13,
			title: 'Barbados',
			childIds: []
		}, 
		14: {
			id: 14,
			title: 'Canada',
			childIds: []
		},
		15: {
			id: 15,
			title: 'Jamaica',
			childIds: []
		},
		16: {
			id: 16,
			title: 'Mexico',
			childIds: []
		},
		17: {
			id: 17,
			title: 'Trinidad and Tobago',
			childIds: []
		},
		18: {
			id: 18,
			title: 'Venezuela',
			childIds: []
		},
		19: {
			id: 19,
			title: 'Asia',
			childIds: [20, 21, 22, 23, 24, 25, 26],   
		},
		20: {
			id: 20,
			title: 'China',
			childIds: []
		},
		21: {
			id: 21,
			title: 'Hong Kong',
			childIds: []
		},
		22: {
			id: 22,
			title: 'India',
			childIds: []
		},
		23: {
			id: 23,
			title: 'Singapore',
			childIds: []
		},
		24: {
			id: 24,
			title: 'South Korea',
			childIds: []
		},
		25: {
			id: 25,
			title: 'Thailand',
			childIds: []
		},
		26: {
			id: 26,
			title: 'Vietnam',
			childIds: []
		},
		27: {
			id: 27,
			title: 'Europe',
			childIds: [28, 29, 30, 31, 32, 33, 34],   
		},
		28: {
			id: 28,
			title: 'Croatia',
			childIds: []
		},
		29: {
			id: 29,
			title: 'France',
			childIds: []
		},
		30: {
			id: 30,
			title: 'Germany',
			childIds: []
		},
		31: {
			id: 31,
			title: 'Italy',
			childIds: []
		},
		32: {
			id: 32,
			title: 'Portugal',
			childIds: []
		},
		33: {
			id: 33,
			title: 'Spain',
			childIds: []
		},
		34: {
			id: 34,
			title: 'Turkey',
			childIds: []
		},
		35: {
			id: 35,
			title: 'Oceania',
			childIds: [36, 37, 38, 39, 40, 41, 42],   
		},
		36: {
			id: 36,
			title: 'Australia',
			childIds: []
		},
		37: {
			id: 37,
			title: 'Bora Bora (French Polynesia)',
			childIds: []
		},
		38: {
			id: 38,
			title: 'Easter Island (Chile)',
			childIds: []
		},
		39: {
			id: 39,
			title: 'Fiji',
			childIds: []
		},
		40: {
			id: 40,
			title: 'Hawaii (the USA)',
			childIds: []
		},
		41: {
			id: 41,
			title: 'New Zealand',
			childIds: []
		},
		42: {
			id: 42,
			title: 'Vanuatu',
			childIds: []
		},
		43: {
			id: 43,
			title: 'Moon',
			childIds: [44, 45, 46]
		},
		44: {
			id: 44,
			title: 'Rheita',
			childIds: []
		},
		45: {
			id: 45,
			title: 'Piccolomini',
			childIds: []
		},
		46: {
			id: 46,
			title: 'Tycho',
			childIds: []
		},
		47: {
			id: 47,
			title: 'Mars',
			childIds: [48, 49]
		},
		48: {
			id: 48,
			title: 'Corn Town',
			childIds: []
		},
		49: {
			id: 49,
			title: 'Green Hill',
			childIds: []
		}
	};
</code>

Ora che lo State é Flat (conosciuto anche come "normalizzato"), aggiornare gli items annidati diviene più facile.

Per rimuovere un place ora, occorrerà aggiornare solamente due livelli di State:

• La versione aggionata del suo parent place dovrebbe escludere l'ID rimosso dall'Array childIds.

• La versione aggiornata del root object "table" dovrebbe includere la versione aggiornata del parent place.

Ecco un esempio di come ci si può muovere:

<code>
	import React, { useState } from "react";
	import { initialTravelPlan } from "../places";

    export default function TravelPlan() {
    	const [plan, setPlan] = useState(initialTravelPlan);

    	function handleComplete(parentId, childId) {
    		const parent = plan[parentId];
    		// Crea una nuova versione del place parent che non
    		// includa questo child ID
    		const nextParent = {
    			...parent,
    			childIds: parent.childIds.filter((id) => id !== childId)
    		};
    		// Aggiorna il root state object...
    		setPlan({
    			...plan,
    			// ...così che abbia il parent aggiornato
    			[parentId]: nextParent
    		});
    	}

    	const root = plan[0];
    	const planetIds = root.childIds;
    	return (
    		<>
    			<h2>Places to visit</h2>
    			<ol>
    				{planetIds.map((id) => (
    					<PlaceTree
    						key={id}
    						id={id}
    						parentId={0}
    						placesById={plan}
    						onComplete={handleComplete}
    					/>
    				))}
    			</ol>
    		</>
    	);
    }

    function PlaceTree({ id, parentId, placesById, onComplete }) {
    	const place = placesById[id];
    	const childIds = place.childIds;
    	return (
    		<li>
    			{place.title}
    			<button
    				onClick={() => {
    					onComplete(parentId, id);
    				}}
    			>
    				Complete
    			</button>
    			{childIds.length > 0 && (
    				<ol>
    					{childIds.map((childId) => {
    						<PlaceTree
    							key={childId}
    							id={childId}
    							parentId={id}
    							placesbyId={placesById}
    							onComplete={onComplete}
    						/>;
    					})}
    				</ol>
    			)}
    		</li>
    	);
    }

</code>

Si può annidare lo State quanto si vuole, ma renderlo "flat" può risolvere numerosi problemi. Rende lo State più facile da aggiornare e aiuta ad assicurarsi di non avere duplicazioni in diverse parti di un object annidato.

### 20.8. Improving memory usage

Idealmente, si vorrebbero rimuovere gli items cancellati, ed i loro children, dall'object "table" per migliorare l'uso della memoria. Questa versione lo fa, usando anche Immer per rendere la logica di aggionamento più concisa:

<code>
	import { useImmer } from 'use-immer';
	import { initialTravelPlan } from './places.js';

    export default function TravelPlan() {
    	const [plan, updatePlan] = useImmer(initialTravelPlan);

    	function handleComplete(parentId, childId) {
    		updatePlan(draft => {
    			// Remove from the parent place's child IDs.
    			const parent = draft[parentId];
    			parent.childIds = parent.childIds
    				.filter(id => id !== childId);

    			// Forget this place and all its subtree.
    			deleteAllChildren(childId);
    			function deleteAllChildren(id) {
    				const place = draft[id];
    				place.childIds.forEach(deleteAllChildren);
    				delete draft[id];
    			}
    		});
    	}

    	const root = plan[0];
    	const planetIds = root.childIds;
    	return (
    		<>
    			<h2>Places to visit</h2>
    			<ol>
    				{planetIds.map(id => (
    					<PlaceTree
    						key={id}
    						id={id}
    						parentId={0}
    						placesById={plan}
    						onComplete={handleComplete}
    					/>
    				))}
    			</ol>
    		</>
    	);
    }

    function PlaceTree({ id, parentId, placesById, onComplete }) {
    	const place = placesById[id];
    	const childIds = place.childIds;
    	return (
    		<li>
    			{place.title}
    			<button onClick={() => {
    				onComplete(parentId, id);
    			}}>
    				Complete
    			</button>
    			{childIds.length > 0 &&
    				<ol>
    					{childIds.map(childId => (
    						<PlaceTree
    							key={childId}
    							id={childId}
    							parentId={id}
    							placesById={placesById}
    							onComplete={onComplete}
    						/>
    					))}
    				</ol>
    			}
    		</li>
    	);
    }

</code>

A volte si può anche ridurre l'annidamento dello State muovendo parte dello State annidato nei child Components. Questo funziona bene per lo State della UI effimera che non necessita di essere archivata, come se un item venisse sorvolato dal cursore (hover).

### 20.9. Exercises

1-
<code>
export default function Clock(props) {
let color = props.color;
return (

<h1 style={{ color: color }}>
{props.time}
</h1>
);
}
</code>

Perché non aggiorna la prop alla sua variazione quando si salva nello State. Occorre salvare la prop in una variabile.

Soluzione fattibile ma errato.

<code>
	export default function Clock({ color, time }) {
		return (
			<h1 style={{ color: color }}>
				{time}
			</h1>
		);
	}
</code>

2-

<code>
	import { useState } from 'react';
	import AddItem from './AddItem.js';
	import PackingList from './PackingList.js';

    let nextId = 3;
    const initialItems = [
    	{ id: 0, title: 'Warm socks', packed: true },
    	{ id: 1, title: 'Travel journal', packed: false },
    	{ id: 2, title: 'Watercolors', packed: false },
    ];

    export default function TravelPlan() {
    	const [items, setItems] = useState(initialItems);

    	function handleAddItem(title) {
    		setItems([
    			...items,
    			{
    				id: nextId++,
    				title: title,
    				packed: false
    			}
    		]);
    	}

    	function handleChangeItem(nextItem) {

    		setItems(items.map(item => {
    			if (item.id === nextItem.id) {
    				return nextItem;
    			} else {
    				return item;
    			}
    		}));
    	}

    	function handleDeleteItem(itemId) {
    		setItems(
    			items.filter(item => item.id !== itemId)
    		);
    	}

    	return (
    		<>
    			<AddItem
    				onAddItem={handleAddItem}
    			/>
    			<PackingList
    				items={items}
    				onChangeItem={handleChangeItem}
    				onDeleteItem={handleDeleteItem}
    			/>
    			<hr />
    			<b>{(items.filter((item) => item.packed)).length} out of {items.length} packed!</b>
    		</>
    	);
    }

</code>

Ridondanti sia total che packed, levati entrambi e usato solo items.

Perfetto :white_check_mark:

Soluzione migliore e più concisa del tutorial.

3-

Avviene perché nel momento del click, viene creato un nuovo object letter, quindi viene persa l'evidenziatura perché riferita alla letter precedente.

Soluzione: nella prop di Letter nella ul del JSX confrontare letter.id con highlightedLetter.id invece che letter con highlightedLetter.
Gli id si basano sui dati non sull'object renderizzato.

Quasi Perfetto :white_check_mark:

<code>
	import { useState } from 'react';
	import { initialLetters } from './data.js';
	import Letter from './Letter.js';

    export default function MailClient() {
    	const [letters, setLetters] = useState(initialLetters);
    	const [highlightedLetter, setHighlightedLetter] = useState(null);

    	function handleHover(letter) {
    		setHighlightedLetter(letter);
    	}

    	function handleStar(starred) {
    		setLetters(letters.map(letter => {
    			if (letter.id === starred.id) {
    				return {
    					...letter,
    					isStarred: !letter.isStarred
    				};
    			} else {
    				return letter;
    			}
    		}));
    	}

    	return (
    		<>
    			<h2>Inbox</h2>
    			<ul>
    				{letters.map(letter => (
    					<Letter
    						key={letter.id}
    						letter={letter}
    						isHighlighted={
    							letter.id === highlightedLetter.id
    						}
    						onHover={handleHover}
    						onToggleStar={handleStar}
    					/>
    				))}
    			</ul>
    		</>
    	);
    }

</code>

Nella soluzione del tutorial salvato come State l'id di highlightedLetter e poi stesso raffronto.

4-

<code>
	export default function MailClient() {
		const [selectedIds, setSelectedIds] = useState([]);

    	// TODO: allow multiple selection
    		console.log(selectedIds);

    	const selectedCount = 1;



    	function handleToggle(toggledId) {
    		// TODO: allow multiple selection
    		const arr = selectedIds.filter(l => l === toggledId)

    		if(arr.length > 0){
    			setSelectedIds(selectedIds.filter(l => l !== toggledId))
    		} else {
    			setSelectedIds([...selectedIds, toggledId]);
    		}
    	}

    	return (
    		<>
    			<h2>Inbox</h2>
    			<ul>
    				{letters.map(letter => (
    					<Letter
    						key={letter.id}
    						letter={letter}
    						isSelected={
    							selectedIds.find(l => l === letter.id)
    						}
    						onToggle={handleToggle}
    					/>
    				))}
    				<hr />
    				<p>
    					<b>
    						You selected {selectedIds.length} letters
    					</b>
    				</p>
    			</ul>
    		</>
    	);
    }

</code>

Quasi corretto, bastava usare includes

Soluzione:

<code>
	export default function MailClient() {
		const [selectedIds, setSelectedIds] = useState([]);

    	const selectedCount = selectedIds.length;

    	function handleToggle(toggledId) {
    		// Was it previously selected?
    		if (selectedIds.includes(toggledId)) {
    			// Then remove this ID from the array.
    			setSelectedIds(selectedIds.filter(id =>
    				id !== toggledId
    			));
    		} else {
    			// Otherwise, add this ID to the array.
    			setSelectedIds([
    				...selectedIds,
    				toggledId
    			]);
    		}
    	}

    	return (
    		<>
    			<h2>Inbox</h2>
    			<ul>
    				{letters.map(letter => (
    					<Letter
    						key={letter.id}
    						letter={letter}
    						isSelected={
    							selectedIds.includes(letter.id)
    						}
    						onToggle={handleToggle}
    					/>
    				))}
    				<hr />
    				<p>
    					<b>
    						You selected {selectedCount} letters
    					</b>
    				</p>
    			</ul>
    		</>
    	);
    }

</code>

## 21. Sharing State Between Components

A volte, si vuole che lo State di due Components cambi sempre insieme. Per farlo, possiamo rimuovere lo State da entrambi, muoverlo al parent comune più vicino, e poi passare tale State ai Components attraverso le prop.
Questa tecnica é conosciuta come "lifting state up", ed é una delle cose più comuni che si faranno nel codice React.js.

### 21.1. Lifting state up by example

In quest'esempio, un parent "Accordition" Component renderizza due Panel Components separati:

• Accordition
•• Panel
•• Panel

Ogni Panel Component ha uno State boolean isActive che determina se il content é visibile o meno:

<code>
	function Panel({ title, children }) {
		const [isActive, setIsActive] = useState(false);
		return (
			<section className="panel">
				<h3>{title}</h3>
				{isActive ? (
					<p>{children}</p>
				) : (
					<button onClick={() => setIsActive(true)}>Show</button>
				)}
			</section>
		);
	}

    export default function Accordion() {
    	return (
    		<>
    			<h2>Almaty, Kazakhstan </h2>
    			<Panel title="About">
    				With a population of about 2 million, Almaty is Kazakhstan's largest
    				city. From 1929 to 1997, it was its capital city.
    			</Panel>
    			<Panel title="Etymology">
    				The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for
    				"apple" and is often translated as "full of apples". In fact, the region
    				surrounding Almaty is thought to be the ancestral home of the apple, and
    				the wild <i lang="la">Malus sieversii</i> is considered a likely
    				candidate for the ancestor of the modern domestic apple.
    			</Panel>
    		</>
    	);
    }

</code>

Si noti come premere un button di un Panel non abbia effetto sull'altro, sono indipendenti.

Ma supponiamo ora di voler cambiare quest'esempio in modo che solo un Panel sia espanso in un dato momento. Con tale design, espandendo il secondo Panel dovrebbe far ritrarre (collapse) il secondo. Come si può farlo?

Per coordinare questi due Panel Components, si ha bisogno di "lift their state up" (sollevare il loro State) ad un parent Component in tre step:

1. Rimuovere lo State dai child Components.
2. Passare i dati hardcoded dal parent comune.
3. Aggiungere lo State al parent comune e passarlo in giù assieme con gli event handlers.

Questo permette al Component Accordition di coordinare entrambi i Panel Components ed espanderne solo uno alla volta.

### 21.2. Step 1: Remove state from the child components

Qui si darà il controllo dello State isActive del Component Panel al suo parent Component. Questo significa che il parent Component passerà isActive ai Components Panel come una prop invece. Cominciamo rimuovendo questa linea dal Panel Component:

<code>
	const [isActive, setIsActive] = useState(false);
</code>

E invece aggiungiamo isActive alla lista delle prop del Panel Component:

<code>
	function Panel({ title, children, isActive }) {...
</code>

Ora il parent Component del Panel può controllare isActive passandolo in giù come una prop. Al contrario, il Component Panel ora non ha nessun controllo sulla value di isActive, ora é tutto in mano al parent Component.

### 21.3. Step 2: Pass hardcoded data from the common parent

Per sollevare lo State (lift state up), occorre localizzare il parent Component comune più vicino di entrambi i child Components che si vuole coordinare:

• Accordition (parent comune più vicino)
•• Panel
•• Panel

In quest'esempio, si tratta del Component Accordition. Visto che si trova sopra ad entrambi i Panel Components e può controllare le loro prop, diverrà la "source of truth" per quale Panel é attivo correntemente. Facciamo passare all'Accordition Component una value hardcoded di isActive (per esempio true) a entrambi i Panel Components:

<code>
	export default function Accordion() {
		return (
			<>
				<h2>Almaty, Kazakhstan </h2>
				<Panel title="About" isActive={true}>
					With a population of about 2 million, Almaty is Kazakhstan's largest
					city. From 1929 to 1997, it was its capital city.
				</Panel>
				<Panel title="Etymology" isActive={true}>
					The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for...apple.
				</Panel>
			</>
		);
	}
</code>

Editando le values hardcoded di isActive nel Component Accordition si vedrà il risultato sull schermo.

### 21.4. Step 3: Add state to the common parent

Sollevare lo State in alto a volte cambia la natura di cosa si sta archiviando come State.

In questo caso, solo un Panel dovrebbe essere attivo alla volta. Questo significa che il Component parent comune Accordition ha bisogno di tenere traccia di quale Panel Component é attivo. Invece di una value boolean, potrebbe usare un numero come index del Panel attivo per la State variable:

<code>
	const [activeIndex, setActiveIndex] = useState(0);
</code>

Quando l'activeIndex é 0, il primo Panel Component é attivo, quando é 1 é il secondo.

Clickando il button "Show" in entrambi il Panel necessita di cambiare l'active index in Accordition. Un Panel non può impostare lo State activeIndex direttamente perché é definito dentro al Component Accordition. Il Component Accordition necessita di permettere esplicitamente al Component Panel di cambiare il suo State passando un event handler in basso come prop:

<code>
		<>
			<h2>Almaty, Kazakhstan </h2>
			<Panel
				title="About"
				isActive={activeIndex === 0}
				onShow={() => setActiveIndex(0)}
			>
				...
			</Panel>
			<Panel
				title="Etymology"
				isActive={activeIndex === 1}
				onShow={() => setActiveIndex(1)}
			>
				...
			</Panel>
		</>
</code>

Il button element all'interno del Panel Component userà ora la prop onShow come suo Event Handler per il click:

<code>
	function Panel({ title, children, isActive, onShow }) {

    return (
    	<section className="panel">
    		<h3>{title}</h3>
    		{isActive ? <p>{children}</p> : <button onClick={onShow}>Show</button>}
    	</section>
    );

}

export default function Accordion() {
const [activeIndex, setActiveIndex] = useState(0);

    return (
    	<>
    		<h2>Almaty, Kazakhstan </h2>
    		<Panel
    			title="About"
    			isActive={activeIndex === 0}
    			onShow={() => setActiveIndex(0)}
    		>
    			With a population of about 2 million, Almaty is Kazakhstan's largest
    			city. From 1929 to 1997, it was its capital city.
    		</Panel>
    		<Panel
    			title="Etymology"
    			isActive={activeIndex === 1}
    			onShow={() => setActiveIndex(1)}
    		>
    			The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for
    			"apple" and is often translated as "full of apples". In fact, the region
    			surrounding Almaty is thought to be the ancestral home of the apple, and
    			the wild <i lang="la">Malus sieversii</i> is considered a likely
    			candidate for the ancestor of the modern domestic apple.
    		</Panel>
    	</>
    );

}

</code>

Questo completa il sollevamento in alto dello State (Lifting State Up). Muovendo lo State nel parent Component comune permette di coordinare entrambi i Panel. Usando l'active index invece di due flag "isShow" assicura che solo un Panel sia attivo in un dato momento. E passando in basso l'Event Handler ai child assicura che il child possa cambiare lo State del parent.

### 21.5. Controlled and uncontrolled components

E' comune chiamare un Component con del local State come "uncontrolled". Per esempio, il Panel originale con una State variable isActive è uncontrolled perché il suo parent non può influenzare se il Panel é attivo o meno.

In contrasto, si può dire che un Component é "controlled" quando l'informazione importante in esso é guidata dalle props piuttosto che dal proprio local State. Questo permette al parent Component di specificare completamente il suo comportamento. Il Component finale Panel con la prop isActive é controllato dal Component Accordition.

I Components uncontrolled sono più facili da usare rispetto ai loro parents perché occorre una configurazione minore. Ma sono anche meno flessibili quando si vuole coordinarli insieme. I Components controlled sono massimamente flessibili, ma occorre che il parent Component li configuri completamente con le props.

In pratica le terminologie "controlled" e "uncontrolled" non sono strettamente tecniche, ogni Component di solito é un mix tra local State e props. Comunque, questo é uno modo utile di parlare di come i Components sono disegnati e quali capacità offrono.

Quando scriviamo un Component, consideriamo quale informazione in esso viene controllata (attraverso le props) e quale informazione dovrebbe essere non controllata (attraverso lo State). Ma si può sempre cambiare idea e rifattorizzare in seguito.

### 21.6. A single source of truth for each state

Nelle Applicazioni React, molti Components avranno il proprio State. Alcuni State potrebbero "vivere" vicino ai Components Leaf (i Components nella parte più bassa del tree) come gli input. Dell'altro State potrebbe "vivere" vicino al top del tree dell'App invece. Per esempio, persino le Libraries client-side per il routing sono implementate solitamente archiviando la Route corrente nello State di React, e passandola poi in basso attraverso le prop.

Per ogni pezzo unico di State, occorre scegliere il Component che lo "possiederà". Questo principo é anche conosciuto come avere una "single source of truth". Non significa che tutto lo State vive in un songolo posto, ma che per ogni pezzo di State vi é uno specifico Component che ospita tale pezzo di informazione. Invece che duplicare lo State condiviso tra i Components, connviene sollevare lo State al loro parent comune condiviso e passarlo in basso ai children che ne necessitano.

La nostra App cambierà mano a mano che ci si lavora. E' comune muovere lo State verso il basso o verso l'alto mentre ci si sta immaginando dove ogni pezzo dello State "vive". Questo é parte del processo.

Per vedere cosa significa in pratica con molti Components, vedi Thinking in React.

### 21.7. Exercises

1-

<code>
	import { useState } from 'react';

    export default function SyncedInputs() {
    	const [text, setText] = useState('');

    	function handleChange(e) {
    		setText(e.target.value);
    	}

    	return (
    		<>
    			<Input label="First input" text={text} onChange={handleChange}/>
    			<Input label="Second input" text={text} onChange={handleChange}/>
    		</>
    	);
    }

    function Input({ label, text, onChange }) {

    	return (
    		<label>
    			{label}
    			{' '}
    			<input
    				value={text}
    				onChange={onChange}
    			/>
    		</label>
    	);
    }

</code>

Quasi perfetto :white_check_mark:

2-

<code>
	import { useState } from 'react';
	import { foods, filterItems } from './data.js';

    export default function FilterableList() {

    	const [query, setQuery] = useState('');

    	function handleChange(e) {
    		setQuery(filterItems(foods, e.target.value));
    	}

    	return (
    		<>
    			<SearchBar onChange={handleChange}/>
    			<hr />
    			<List items={query} />
    		</>
    	);
    }

    function SearchBar({query, onChange}) {

    	return (
    		<label>
    			Search:{' '}
    			<input
    				value={query}
    				onChange={onChange}
    			/>
    		</label>
    	);
    }

    function List({ items }) {
    	return (
    		<table>
    			<tbody>
    				{items.map(food => (
    					<tr key={food.id}>
    						<td>{food.name}</td>
    						<td>{food.description}</td>
    					</tr>
    				))}
    			</tbody>
    		</table>
    	);
    }

</code>

Corretto

Soluzione tutorial:

<code>
	import { useState } from 'react';
	import { foods, filterItems } from './data.js';

    export default function FilterableList() {
    	const [query, setQuery] = useState('');
    	const results = filterItems(foods, query);

    	function handleChange(e) {
    		setQuery(e.target.value);
    	}

    	return (
    		<>
    			<SearchBar
    				query={query}
    				onChange={handleChange}
    			/>
    			<hr />
    			<List items={results} />
    		</>
    	);
    }

    function SearchBar({ query, onChange }) {
    	return (
    		<label>
    			Search:{' '}
    			<input
    				value={query}
    				onChange={onChange}
    			/>
    		</label>
    	);
    }

    function List({ items }) {
    	return (
    		<table>
    			<tbody>
    				{items.map(food => (
    					<tr key={food.id}>
    						<td>{food.name}</td>
    						<td>{food.description}</td>
    					</tr>
    				))}
    			</tbody>
    		</table>
    	);
    }

</code>

## 22. Preserving and Resetting State

Lo State é isolato tra i Components. React tiene traccia di quale State appartiene a quale Component basandosi sul loro posto nel tree della UI. Si può controllare quando preservare lo State e quando resettarlo tra i re-render.

### 22.1. The UI tree

I browser usano molte tree structures per modellare la UI. Il DOM rappresenta gli elements HTML, il CSSOM fa lo stesso per il CSS. Vi é persino un Accessibility Tree.

React usa anch'esso una tree structure per gestire e modellare le UI che creiamo. React crea gli UI tree dal JSX. Poi React DOM aggiorna gli elements del DOM del browser per far concidere tale UI tree. (React Native traduce questi tree in specifici elements per le piattaforme mobile).

### 22.2. State is tied to a position in the tree

Quando si da uno State ad un Component, si potrebbe pensare che lo State "viva" dentro tale Component. Ma lo State é effettivamente ospitato in React. React associa ogni pezzo di State che sta ospitando con il corretto Component rispetto a dove tale Component si trova nell'UI tree.

<code>

    export default function CounterContainer() {
    	const counter = <Counter />;

    	return (
    		<div>
    			{counter}
    			{counter}
    		</div>
    	);
    }

    function Counter() {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";
    	if (hover) {
    		className += " hover";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>{score}</h1>
    			<button onClick={() => setScore(score + 1)}>Add one</button>
    		</div>
    	);
    }

</code>

Vedi immagine di come si mostrano come tree.

Questi sono due Counter separati perché ognuno é renderizzato nella sua posizione nel tree. Di solito non dobbiamo pensare a queste posizioni per usare React, ma può essere utile capire come lavora.

In React, ogni Component sullo schermo ha un State completamente isolato. Per esempio, se si renderizzano due Components Counter fianco a fianco, ognuno di questi avrà il proprio, indipendente State score e hover.

<code>
export default function CounterContainer() {
	return (
		<div>
			<Counter />
			<Counter />
		</div>
	);
}

function Counter() {
const [score, setScore] = useState(0);
const [hover, setHover] = useState(false);

    let className = "counter";
    if (hover) {
    	className += " hover";
    }

    return (
    	<div
    		className={className}
    		onPointerEnter={() => setHover(true)}
    		onPointerLeave={() => setHover(false)}
    	>
    		<h1>{score}</h1>
    		<button onClick={() => setScore(score + 1)}>Add one</button>
    	</div>
    );

}

</code>

Come si può notare, quando un Counter viene aggiornato, solo lo State per tale Component viene aggiornato.

Vedi immagine.

React manterrà lo State in giro per tutto il tempo fino a che non verrà renderizzato lo stesso Component alla stessa position. Per vedere questo, incrementiamo entrambi i Counters, poi rimuoviamo il secondo Component clickando "Render the secondo counter" e poi aggiungiamolo di nuovo:

<code>
	export default function CounterContainer() {
		const [showB, setShowB] = useState(true);

    	return (
    		<div>
    			<Counter />
    			{showB && <Counter />}
    			<label>
    				<input
    					type="checkbox"
    					checked={showB}
    					onChange={(event) => {
    						setShowB(event.target.checked);
    					}}
    				/>
    				Render the second Counter
    			</label>
    		</div>
    	);
    }

    function Counter() {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";
    	if (hover) {
    		className += " hover";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>{score}</h1>
    			<button onClick={() => setScore(score + 1)}>Add one</button>
    		</div>
    	);
    }

</code>

Si noti che nel momento in cui si ferma il rendering del secondo Counter, il suo State scompaia completamente. Questo perché quando React rimuove un Component, distrugge il suo State.

Quando si riseleziona con il tick "Render the second Counter", un secondo Counter Component ed il suo State vengono inizializzati da scratch (con score = 0) e aggiunti al DOM.

React preserva lo State di un Component fino a che non viene renderizzato alla sua position nel tree della UI. Se viene rimosso, o un Component differente viene renderizzato alla stessa position, React scarta il suo State.

### 22.3. Same component at the same position preserves state

In quest'esempio vi sono due diversi tag <Counter />:

<code>
	export default function CounterContainer() {
		const [isFancy, setIsFancy] = useState(false);

    	return (
    		<div>
    			{isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}
    			<label>
    				<input
    					type="checkbox"
    					checked={isFancy}
    					onChange={(event) => {
    						setIsFancy(event.target.checked);
    					}}
    				/>
    				Use Fancy Styling
    			</label>
    		</div>
    	);
    }

    function Counter({ isFancy }) {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";
    	if (hover) {
    		className += " hover";
    	}
    	if (isFancy) {
    		className += " fancy";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>{score}</h1>
    			<button onClick={() => setScore(score + 1)}>Add one</button>
    		</div>
    	);
    }

</code>

Quando si va a selezionare o meno la checkbox, lo State del Counter non si resetta. Sia che isFancy sia true o false, si ha sempre un Component Counter come primo child del div restituito dal root Component.

Vedi immagine.

E' lo stesso Component alla stessa position, quindi dalla prospettica di React, é lo stesso Counter.

Nota: Si ricordi che é la positione nel tree della UI, non nel markup JSX, che conta per React. Questo Component ha due clausule return con due diversi tag JSX Counter dentro e fuori dall'if:

<code>
	export default function App() {
		const [isFancy, setIsFancy] = useState(false);
		if (isFancy) {
			return (
				<div>
					<Counter isFancy={true} />
					<label>
						<input
							type="checkbox"
							checked={isFancy}
							onChange={e => {
								setIsFancy(e.target.checked)
							}}
						/>
						Use fancy styling
					</label>
				</div>
			);
		}
		return (
			<div>
				<Counter isFancy={false} />
				<label>
					<input
						type="checkbox"
						checked={isFancy}
						onChange={e => {
							setIsFancy(e.target.checked)
						}}
					/>
					Use fancy styling
				</label>
			</div>
		);
	}

    function Counter({ isFancy }) {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = 'counter';
    	if (hover) {
    		className += ' hover';
    	}
    	if (isFancy) {
    		className += ' fancy';
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>{score}</h1>
    			<button onClick={() => setScore(score + 1)}>
    				Add one
    			</button>
    		</div>
    	);
    }

</code>

Ci si potrebbe aspettare che lo State venga resettato quando si seleziona la checkbox, ma non lo fa. Questo perché entrambi questi Counter tag sono renderizzati alla stessa position. React non sa dove vengono inserite le condizioni nella funzione.
Tutto ciò che "vede" é il tree che si restituisce.

In entrambi i casi, il Component App restituisce un div con un Component Counter come primo child. Per React, questi due Counter hanno lo stesso "address": il primo child del primo child della root. Così é come React associa insieme il render precedente e quello successivo, senza tener conto della struttura della propria logica.

### 22.4. Different components at the same position reset state

In quest'esempio, selezionare la checkbox sostituirà Counter con un paragraph:

<code>

    export default function CounterContainer() {
    	const [isPaused, setIsPaused] = useState(false);

    	return (
    		<div>
    			{isPaused ? <p>See you later</p> : <Counter />}
    			<label>
    				<input
    					type="checkbox"
    					checked={isPaused}
    					onChange={(event) => {
    						setIsPaused(event.target.checked);
    					}}
    				/>
    				Take a break
    			</label>
    		</div>
    	);
    }

    function Counter() {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";
    	if (hover) {
    		className += " hover";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>{score}</h1>
    			<button onClick={() => setScore(score + 1)}>Add One</button>
    		</div>
    	);
    }

</code>

Qui si passa tra Components di type differente alla stessa position. Inizialmente, il primo child del div contiene un Counter. Ma quando andiamo a passare al paragraph, React rimuove il Counter dal tree della UI e distrugge il suo State.

Inoltre, quando si renderizza un Component differente alla stessa position, React resetta lo State dell'intero subtree del Component. Per vedere come funziona, incrementiamo il Counter e poi selezioniamo la checkbox:

<code>

    export default function CounterContainer() {
    	const [isFancy, setIsFancy] = useState(false);

    	return (
    		<div>
    			{isFancy ? (
    				<div>
    					<Counter isFancy={true} />
    				</div>
    			) : (
    				<section>
    					<Counter isFancy={false} />
    				</section>
    			)}
    			<label>
    				<input
    					type="checkbox"
    					checked={isFancy}
    					onChange={(event) => {
    						setIsFancy(event.target.checked);
    					}}
    				/>
    				Use fancy styling
    			</label>
    		</div>
    	);
    }

    function Counter({ isFancy }) {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";

    	if (hover) {
    		className += " hover";
    	}

    	if (isFancy) {
    		className += " fancy";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>{score}</h1>
    			<button onClick={() => setScore(score + 1)}>Add One</button>
    		</div>
    	);
    }

</code>

Il Counter viene resettato quando si clicka sulla checkbox. Anche se si renderizza un Counter, il primo child cambia da un div ad una section. Quando il child div viene rimosso dal DOM, l'intero tree, incluso il Counter ed il suo State, vengono distrutti anch'essi.

Come regola generale, se si vuole preservare lo State tra i re-render, la struttura del tree necessita di corrispondere tra un render e l'altro. Se la struttura é differente lo State verrà distrutto perché React distrugge lo State quando rimuove un Component dal tree.

Nota: Questo é anche il motivo perché non si dovrebbe mai annidare le definizioni dei Components. Qui, la funzione del Component MyTextField viene definito dentro MyComponent:

<code>
	import { useState } from 'react';

    export default function MyComponent() {
    	const [counter, setCounter] = useState(0);

    	function MyTextField() {
    		const [text, setText] = useState('');

    		return (
    			<input
    				value={text}
    				onChange={e => setText(e.target.value)}
    			/>
    		);
    	}

    	return (
    		<>
    			<MyTextField />
    			<button onClick={() => {
    				setCounter(counter + 1)
    			}}>Clicked {counter} times</button>
    		</>
    	);
    }

</code>

Ogni volta che si clickerà il button, lo State dell'input scomparirà. Questo succede a causa del fatto che la funzione MyTextField viene ricreata ad ogni render del Component MyComponent. Si sta renderizzando un Component differente nella stessa position, quindi React resetta tutto lo State.
Questo può portare a bug e problemi di performance. Per evitare questi tipi di problematiche, si dichiari le funzioni dei Components al top level, mai annidare le loro definizioni.

### 22.5. Resetting state at the same position

Di default, React preserva lo State di un Component mentre resta nella stessa position. Solitamente, questo é esattamente ciò che vogliamo, quindi ha senso come comportamento di default. Ma a volte, si potrebbe voler resettare lo State di un Component. Si consideri quest'App che permette a due giocatori di tener traccia del loro punteggio durante ogni turno:

<code>

    export default function Scoreboard() {
    	const [isPlayerA, setIsPlayerA] = useState(true);

    	return (
    		<div>
    			{isPlayerA ? <Counter person="Taylor" /> : <Counter person="Sarah" />}
    			<button
    				onClick={() => {
    					setIsPlayerA((prevPlayer) => {
    						return !prevPlayer;
    					});
    				}}
    			>
    				Next player!
    			</button>
    		</div>
    	);
    }

    function Counter({ person }) {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";
    	if (hover) {
    		className += " hover";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>
    				{person}'s score: {score}
    			</h1>
    			<button onClick={() => setScore(score + 1)}>Add one</button>
    		</div>
    	);
    }

</code>

Al momento, quando si cambia giocatore, il punteggio viene mantenuto. I due Counter appaiono nella stessa position, quindi React li vede come lo stesso Counter la cui prop person é stata cambiata.

Ma concettualmente, in quest'App dovrebbero essere due Counters separati. Dovrebbero apparire nello stesso posto nella UI, ma uno é un Counter per Taylor, l'altro é un Counter per Sarah.

Vi sono due modi per resettare lo State quando si passa tra loro:

1. Renderizzare i Components in position differenti
2. Dare ad ogni Component un'identità esplicita con una key

### 22.6. Option 1: Rendering a component in different positions

Se si vuole che questi due Components siano indipendenti, si possono renderizzare in due posizioni differenti:

<code>

    export default function Scoreboard() {
    	const [isPlayerA, setIsPlayerA] = useState(true);

    	return (
    		<div>
    			{isPlayerA && <Counter person="Taylor" />}
    			{!isPlayerA && <Counter person="Sarah" />}
    			<button
    				onClick={() => {
    					setIsPlayerA((prevPlayer) => {
    						return !prevPlayer;
    					});
    				}}
    			>
    				Next player!
    			</button>
    		</div>
    	);
    }

    function Counter({ person }) {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";
    	if (hover) {
    		className += " hover";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>
    				{person}'s score: {score}
    			</h1>
    			<button onClick={() => setScore(score + 1)}>Add one</button>
    		</div>
    	);
    }

</code>

• Inizialmente, isPlayerA é true. Quindi la prima position contiene lo State di Counter e la seconda é vuota.

• Quando si clicka sul button "Next Player" la prima position viene pulita ma la seconda ora contiene un Counter.

Lo State di ogni Counter viene distrutto ogni volta che viene rimosso dal DOM. Per questo viene resettato ogni volta che si clicka il button.

Questa soluzione é conveniente quando si hanno solamente alcuni Components indipendenti che vengono renderizzati nello stesso posto. In quest'esempio, se ne hanno solo due, quindi non é problematico renderizzare entrambi separatamente nel JSX.

### 22.7. Resetting state with a key

Vi é inoltre un altro modo più generico per resettare lo State di un Component.

Abbiamo visto le key quando abbiamo renderizzato le lists.
Le keys appunto non sono solo per le liste. Si possono usare le keys per far distinguere a React i vari Components. Di default, React usa l'ordine all'interno del parent, come "first counter" e "second counter", per discernere tra i Components. Ma le keys permettono di dire a React che questo non é il "primo" counter o il "secondo" counter, ma uno "specifico" counter, per esempio il Counter di Taylor. In questo modo React saprà se il Counter di Taylor appare nel tree.

In quest'esempio i due Counter non condivideranno lo State anche se appaiono nello stesso posto nel JSX:

<code>

    export default function Scoreboard() {
    	const [isPlayerA, setIsPlayerA] = useState(true);

    	return (
    		<div>
    			{isPlayerA ? (
    				<Counter key="Taylor" person="Taylor" />
    			) : (
    				<Counter key="Sarah" person="Sarah" />
    			)}
    			<button
    				onClick={() => {
    					setIsPlayerA((prevPlayer) => {
    						return !prevPlayer;
    					});
    				}}
    			>
    				Next player!
    			</button>
    		</div>
    	);
    }

    function Counter({ person }) {
    	const [score, setScore] = useState(0);
    	const [hover, setHover] = useState(false);

    	let className = "counter";
    	if (hover) {
    		className += " hover";
    	}

    	return (
    		<div
    			className={className}
    			onPointerEnter={() => setHover(true)}
    			onPointerLeave={() => setHover(false)}
    		>
    			<h1>
    				{person}'s score: {score}
    			</h1>
    			<button onClick={() => setScore(score + 1)}>Add one</button>
    		</div>
    	);
    }

</code>

Passare tra Taylor e Sarah non preserverà lo State. Questo perché si é dato ai Components delle key differenti:

<code>
{isPlayerA ? (
	<Counter key="Taylor" person="Taylor" />
) : (
	<Counter key="Sarah" person="Sarah" />
)}
</code>

Specificare una key dice a React di usare la key stessa come parte della position, invece di usare l'ordine secondo il loro parent comune. Questo é il motivo per cui, persino se si renderizzano nello stesso posto nel JSX, React li vede come due Counters differenti, e quindi non condivideranno mai lo State. Ogni volta che un Counter appare sullo schermo, lo State viene creato. Ogni volta che viene rimosso, il suo State viene distrutto. Passare tra questi resetterà il loro State ancora e ancora.

Nota: Ricordare che le keys non sono uniche a livello globale. Specificano solamente la position rispetto al parent.

### 22.8. Resetting a form with a key

Resettare lo State con una key é particolarmente utile quando si ha a che fare con i form.

In questa Chat App, il Component Chat contiene uno State con il text dell'input:

<code>

    export default function Messanger() {
    	const [to, setTo] = useState(contacts[0]);
    	return (
    		<div>
    			<ContactList
    				contacts={contacts}
    				selectedContact={to}
    				onSelect={(contact) => setTo(contact)}
    			/>
    			<Chat contact={to} />
    		</div>
    	);
    }

    const contacts = [
    	{ id: 0, name: "Taylor", email: "taylor@mail.com" },
    	{ id: 1, name: "Alice", email: "alice@mail.com" },
    	{ id: 2, name: "Bob", email: "bob@mail.com" }
    ];


    export default function ContactList({ selectedContact, contacts, onSelect }) {
    	return (
    		<section className="contact-list">
    			<ul>
    				{contacts.map((contact) => (
    					<li key={contact.id}>
    						<button
    							onClick={() => {
    								onSelect(contact);
    							}}
    						>
    							{contact.name}
    						</button>
    					</li>
    				))}
    			</ul>
    		</section>
    	);
    }


    export default function Chat({ contact }) {
    	const [text, setText] = useState("");
    	return (
    		<section className="chat">
    			<textarea
    				value={text}
    				placeholder={"Chat to " + contact.name}
    				onChange={(event) => setText(event.target.value)}
    			/>
    			<br />
    			<button>Send to {contact.email}</button>
    		</section>
    	);
    }

</code>

Si provi ad inserire qualcosa nell'input, e poi premere "Alice" o "Bob" per selezionare un contenitore differente. Si noterà che lo State dell'input viene preservato visto che il Component Chat viene renderizzato alla stessa position nel tree.

In molte altre App questo potrebbe essere il comportamento desiderato, ma non in una Chat App. Non si vuole permettere ad un utente di inviare un messaggio che ha già scritto ad un altra persona a causa di un click accidentale. Per sistemare questo problema aggiungiamo una key nell'istanza del Component Chat:

<code>
		<Chat key={to.id} contact={to} />
</code>

Questo assicura che quando si selezionerà un contenitore differente, il Component Chat verrà ricreato da zero, incluso qualsisi State nel tree al di sotto di questo. React inoltre ricreerà i DOM elements invece di riusarli.

Ora passare tra i recipienti pulirà sempre il text field:

<code>

    export default function Messanger() {
    	const [to, setTo] = useState(contacts[0]);
    	return (
    		<div>
    			<ContactList
    				contacts={contacts}
    				selectedContact={to}
    				onSelect={(contact) => setTo(contact)}
    			/>
    			<Chat key={to.id} contact={to} />
    		</div>
    	);
    }

    const contacts = [
    	{ id: 0, name: "Taylor", email: "taylor@mail.com" },
    	{ id: 1, name: "Alice", email: "alice@mail.com" },
    	{ id: 2, name: "Bob", email: "bob@mail.com" }
    ];

</code>

### 22.9. Preserving state for removed components

In un Chat App reale, probabilmente si vorrebbe recuperare lo State dell'input quando l'utente seleziona il recipiente precedente. Vi sono alcuni modi per tenere lo State "alive" per un Component che non é più visibile:

• Si possono renderizzare tutte le Chat invece che solo quella correte, ma nascondere tutte le altre con il CSS. Le Chat non saranno più rimosse dal tree, quindi i loro local State saranno preservati. Questa soluzione funziona bene per le UI semplici. Ma può diventare molto lenta se i tree nascosti sono grandi e contengono molti DOM nodes.

• Si può portare in alto lo State (Lift the State Up) e ospitare il message pending per ogni recipient nel parent Component. In questo modo quando il child Component viene rimosso non conta, perché é il parent Component che mantiene le informazioni importanti. Questa é la soluzione più comune.

• Si potrebbe usare inoltre una sorgente differente in aggiunta allo State di React. Per esempio si vorrebbe che un message draft persistesse persino se l'utente chiudesse la page. Per implementare questo, si potrebbe far inizializzare lo State del Component Chat leggendolo dal localStorage, e anche salvarvi i messaggi draft.

Non importa quale strategia si sceglierà, una Chat con Alice é concettualmente distinta sa una Chat con Bob, quindi ha senso dare una key al Chat tree basato sul recipiente corrente.

### 22.10. Exercises

1-

Avviene perché lo State dove viene salvato il text viene resettato quando viene resettato al click, creando un nuovo child. Si può aggiungere una key per eliminare il problema:

<code>

    export default function App() {
    	const [showHint, setShowHint] = useState(false);
    	if (showHint) {
    		return (
    			<div>
    				<p><i>Hint: Your favorite city?</i></p>
    				<Form key="answer"/>
    				<button onClick={() => {
    					setShowHint(false);
    				}}>Hide hint</button>
    			</div>
    		);
    	}
    	return (
    		<div>
    			<Form key="answer"/>
    			<button onClick={() => {
    				setShowHint(true);
    			}}>Show hint</button>
    		</div>
    	);
    }

    function Form() {
    	const [text, setText] = useState('');
    	return (
    		<textarea
    			value={text}
    			onChange={e => setText(e.target.value)}
    		/>
    	);
    }

</code>

Errato

Soluzione tutorial, unificare i branches in modo che Form venga renderizzato sempre alla stessa position:

<code>

    export default function App() {
    	const [showHint, setShowHint] = useState(false);
    	return (
    		<div>
    			{showHint &&
    				<p><i>Hint: Your favorite city?</i></p>
    			}
    			<Form />
    			{showHint ? (
    				<button onClick={() => {
    					setShowHint(false);
    				}}>Hide hint</button>
    			) : (
    				<button onClick={() => {
    					setShowHint(true);
    				}}>Show hint</button>
    			)}
    		</div>
    	);
    }

    function Form() {
    	const [text, setText] = useState('');
    	return (
    		<textarea
    			value={text}
    			onChange={e => setText(e.target.value)}
    		/>
    	);
    }

</code>

Dopo ripasso:

Risposta: perché cambia di posizione, allora il Form viene sempre visto come nuovo component al mounting e smontato al press del button, quindi il suo State viene resettato.

<code>

    import { useState } from 'react';

    export default function App() {
    	const [showHint, setShowHint] = useState(false);

    	return (
    		<div>
    			{showHint ?
    				<>
    					<Form />
    				<p><i>Hint: Your favorite city?</i></p>
    					<button onClick={() => {
    						setShowHint(false);
    					}}>Hide hint</button>
    			</> :
    			<>
    				<Form />
    				<button onClick={() => {
    				setShowHint(true);
    			}}>Show hint</button>
    			</>
    			}

    		</div>
    	);
    }

    function Form() {
    	const [text, setText] = useState('');
    	return (
    		<textarea
    			value={text}
    			onChange={e => setText(e.target.value)}
    		/>
    	);
    }

</code>

Quasi Perfetto :white_check_mark:

2-

<code>

    export default function App() {
    	const [reverse, setReverse] = useState(false);
    	let checkbox = (
    		<label>
    			<input
    				type="checkbox"
    				checked={reverse}
    				onChange={e => setReverse(e.target.checked)}
    			/>
    			Reverse order
    		</label>
    	);
    	if (reverse) {
    		return (
    			<>
    				<Field key="lastname" label="Last name" />
    				<Field key="firstname" label="First name" />
    				{checkbox}
    			</>
    		);
    	} else {
    		return (
    			<>
    				<Field key="firstname" label="First name" />
    				<Field key="lastname" label="Last name" />
    				{checkbox}
    			</>
    		);
    	}
    }

    function Field({ label }) {
    	const [text, setText] = useState('');
    	return (
    		<label>
    			{label}:{' '}
    			<input
    				type="text"
    				value={text}
    				placeholder={label}
    				onChange={e => setText(e.target.value)}
    			/>
    		</label>
    	);
    }

</code>

Perfetto :white_check_mark:

3-

<code>

    export default function ContactManager() {
    	const [
    		contacts,
    		setContacts
    	] = useState(initialContacts);
    	const [
    		selectedId,
    		setSelectedId
    	] = useState(0);
    	const selectedContact = contacts.find(c =>
    		c.id === selectedId
    	);

    	function handleSave(updatedData) {
    		const nextContacts = contacts.map(c => {
    			if (c.id === updatedData.id) {
    				return updatedData;
    			} else {
    				return c;
    			}
    		});
    		setContacts(nextContacts);
    	}

    	return (
    		<div>
    			<ContactList
    				contacts={contacts}
    				selectedId={selectedId}
    				onSelect={id => setSelectedId(id)}
    			/>
    			<hr />
    			<EditContact
    				key={selectedId}
    				initialData={selectedContact}
    				onSave={handleSave}
    			/>
    		</div>
    	)
    }

    const initialContacts = [
    	{ id: 0, name: 'Taylor', email: 'taylor@mail.com' },
    	{ id: 1, name: 'Alice', email: 'alice@mail.com' },
    	{ id: 2, name: 'Bob', email: 'bob@mail.com' }
    ];

</code>

Perfetto :white_check_mark:

4-

Consegna poco chiara.

Prima soluzione:

<code>

    export default function Gallery() {
    	const [index, setIndex] = useState(0);
    	const [images, setImages] = useState(savedImages)
    	const hasNext = index < images.length - 1;

    	function handleClick() {
    		if (hasNext) {
    			setIndex(index + 1);
    		} else {
    			setIndex(0);
    		}
    	}

    	let image = images[index];
    	return (
    		<>
    			<button onClick={handleClick}>
    				Next
    			</button>
    			<h3>
    				Image {index + 1} of {images.length}
    			</h3>
    			<img src={image.src} />
    			<p>
    				{image.place}
    			</p>
    		</>
    	);
    }

    let savedImages = [{
    	place: 'Penang, Malaysia',
    	src: 'https://i.imgur.com/FJeJR8M.jpg'
    }, {
    	place: 'Lisbon, Portugal',
    	src: 'https://i.imgur.com/dB2LRbj.jpg'
    }, {
    	place: 'Bilbao, Spain',
    	src: 'https://i.imgur.com/z08o2TS.jpg'
    }, {
    	place: 'Valparaíso, Chile',
    	src: 'https://i.imgur.com/Y3utgTi.jpg'
    }, {
    	place: 'Schwyz, Switzerland',
    	src: 'https://i.imgur.com/JBbMpWY.jpg'
    }, {
    	place: 'Prague, Czechia',
    	src: 'https://i.imgur.com/QwUKKmF.jpg'
    }, {
    	place: 'Ljubljana, Slovenia',
    	src: 'https://i.imgur.com/3aIiwfm.jpg'
    }];

</code>

Seconda soluzione:

<code>

    export default function Gallery() {
    	const [index, setIndex] = useState(0);
    	const hasNext = index < images.length - 1;

    	function handleClick() {
    		if (hasNext) {
    			setIndex(index + 1);
    		} else {
    			setIndex(0);
    		}
    	}

    	let image = images[index];
    	return (
    		<React.Fragment key={index}>
    			<button onClick={handleClick}>
    				Next
    			</button>
    			<h3>
    				Image {index + 1} of {images.length}
    			</h3>
    			<img src={image.src} />
    			<p>
    				{image.place}
    			</p>
    		</React.Fragment>
    	);
    }

    let images = [{
    	place: 'Penang, Malaysia',
    	src: 'https://i.imgur.com/FJeJR8M.jpg'
    }, {
    	place: 'Lisbon, Portugal',
    	src: 'https://i.imgur.com/dB2LRbj.jpg'
    }, {
    	place: 'Bilbao, Spain',
    	src: 'https://i.imgur.com/z08o2TS.jpg'
    }, {
    	place: 'Valparaíso, Chile',
    	src: 'https://i.imgur.com/Y3utgTi.jpg'
    }, {
    	place: 'Schwyz, Switzerland',
    	src: 'https://i.imgur.com/JBbMpWY.jpg'
    }, {
    	place: 'Prague, Czechia',
    	src: 'https://i.imgur.com/QwUKKmF.jpg'
    }, {
    	place: 'Ljubljana, Slovenia',
    	src: 'https://i.imgur.com/3aIiwfm.jpg'
    }];

</code>

Terza soluzione:

<code>

    export default function Gallery() {
    	const [index, setIndex] = useState(0);
    	const hasNext = index < images.length - 1;

    	function handleClick() {
    		if (hasNext) {
    			setIndex(index + 1);
    		} else {
    			setIndex(0);
    		}
    	}

    	let image = images[index];
    	return (
    		<>
    			<button onClick={handleClick}>
    				Next
    			</button>
    			<h3>
    				Image {index + 1} of {images.length}
    			</h3>
    			<img key={index} src={image.src} />
    			<p>
    				{image.place}
    			</p>
    		</>
    	);
    }

    let images = [{
    	place: 'Penang, Malaysia',
    	src: 'https://i.imgur.com/FJeJR8M.jpg'
    }, {
    	place: 'Lisbon, Portugal',
    	src: 'https://i.imgur.com/dB2LRbj.jpg'
    }, {
    	place: 'Bilbao, Spain',
    	src: 'https://i.imgur.com/z08o2TS.jpg'
    }, {
    	place: 'Valparaíso, Chile',
    	src: 'https://i.imgur.com/Y3utgTi.jpg'
    }, {
    	place: 'Schwyz, Switzerland',
    	src: 'https://i.imgur.com/JBbMpWY.jpg'
    }, {
    	place: 'Prague, Czechia',
    	src: 'https://i.imgur.com/QwUKKmF.jpg'
    }, {
    	place: 'Ljubljana, Slovenia',
    	src: 'https://i.imgur.com/3aIiwfm.jpg'
    }];

</code>

Perfetto :white_check_mark:
Terza soluzione anche se insolita.

5-

Il problema l'element list con come child in Component Contact usa una key associata all'index dell'Array displayedContacts. Basta cambiare la key e fare usare contact.id o contact.name:

<code>

    export default function ContactList() {
    	const [reverse, setReverse] = useState(false);

    	const displayedContacts = [...contacts];
    	if (reverse) {
    		displayedContacts.reverse();
    	}

    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					value={reverse}
    					onChange={e => {
    						setReverse(e.target.checked)
    					}}
    				/>{' '}
    				Show in reverse order
    			</label>
    			<ul>
    				{displayedContacts.map((contact, i) =>
    					<li key={contact.id}>
    						<Contact contact={contact} />
    					</li>
    				)}
    			</ul>
    		</>
    	);
    }

    const contacts = [
    	{ id: 0, name: 'Alice', email: 'alice@mail.com' },
    	{ id: 1, name: 'Bob', email: 'bob@mail.com' },
    	{ id: 2, name: 'Taylor', email: 'taylor@mail.com' }
    ];

</code>

Perfetto :white_check_mark:

## 23. Extracting State Logic into a Reducer

I Components con molti aggiornamenti dello State passati attraverso molti event handlers possono essere travolgenti.
Per questi casi si può consolidare tutta la logica di aggionamento dello State fuori dal Component in una singola funzione, chiamata reducer.

### 23.1. Consolidate state logic with a reducer

Mano a mano che i Components crescono in complessità, può diventare duro vedere a prima vista tutti i differenti modi nei quali un Component viene aggionato. Per esempio, il Component TaskApp qui presentato, ospita un Array di tasks nello State e usa tre differenti event handlers per aggiungere, rimuovere ed editare le task:

<code>

    export default function TaskApp() {
    	const [tasks, setTasks] = useState(initialTasks);

    	function handleAddTask(text) {
    		setTasks([
    			...tasks,
    			{
    				id: nextId++,
    				text: text,
    				done: false
    			}
    		]);
    	}

    	function handleChangeTask(task) {
    		setTasks(
    			tasks.map((t) => {
    				if (t.id === task.id) {
    					return task;
    				} else {
    					return t;
    				}
    			})
    		);
    	}

    	function handleDeleteTask(taskId) {
    		setTasks(tasks.filter((t) => t.id !== taskId));
    	}

    	return (
    		<>
    			<h1>Prague Itinerary</h1>
    			<AddTask onAddTask={handleAddTask} />
    			<TaskList
    				tasks={tasks}
    				onChangeTask={handleChangeTask}
    				onDeleteTask={handleDeleteTask}
    			/>
    		</>
    	);
    }

    let nextId = 3;
    const initialTasks = [
    	{ id: 0, text: "Visit Kafka Museum", done: true },
    	{ id: 1, text: "Watch a puppet show", done: false },
    	{ id: 2, text: "Lennon Wall pic", done: false }
    ];

</code>

Ognuno di questi Event Handlers chiama setTasks in modo da aggiornare lo State. Come questo Component cresce, così farà l'ammontare di logica dello State sparsa ovunque. Per ridurre questa complessità e mantenere tutta la logica in un solo posto facilmente accessibile, si può spostare la logica dello State in una singola funzione fuori dal Component, chiamata "reducer".

I Reducers sono un modo differente di gestire lo State. Si può migrare da useState a useReducer in tre step:

1. Spostarsi dal setting dello State al dispatching delle actions.

2. Scrivere una reducer function.

3. Usare il reducer dal Component.

### 23.2. Step 1: Move from setting state to dispatching actions

Gli Event Handlers al momento specificano cosa fare con il setting dello State:

<code>

    function handleAddTask(text) {
    		setTasks([
    			...tasks,
    			{
    				id: nextId++,
    				text: text,
    				done: false
    			}
    		]);
    	}

    	function handleChangeTask(task) {
    		setTasks(
    			tasks.map((t) => {
    				if (t.id === task.id) {
    					return task;
    				} else {
    					return t;
    				}
    			})
    		);
    	}

    	function handleDeleteTask(taskId) {
    		setTasks(tasks.filter((t) => t.id !== taskId));
    	}

</code>

Rimossa tutta la logica di setting dello State. Quello che si sta lasciando sono tre event handlers:

• handleAddTask(text) viene chiamata quando lo user preme "Add".

• handleChangeTask(task) viene chiamata quando lo user cambia una task o preme "Save".

• handleDeleteTask(taskId) viene chiamato quando lo user preme "Delete".

Gestire lo State con i reducers é leggermente differente da usare il setting dello State. Invece di dire a React "cosa fare" impostando lo State, si specifica "cosa lo user ha appena fatto" usando il dispatch di "actions" dagli Event Handlers. La logica di aggiornamento dello State vivrà ovunque. Quindi invece di "impostare (setting) tasks" attraverso un event handler, si effettuerà il dispatch (la spedizione) di un action di "add / change / delete" una task. Questo sarà più descrittivo dell'intento dello user.

<code>

    function handleAddTask(text) {
    	dispatch({
    		type: "added",
    		id: nextId++,
    		text: text
    	});
    }

    function handleChangeTask(task) {
    	dispatch({
    		type: "changed",
    		task: task
    	});
    }

    function handleDeleteTask(taskId) {
    	dispatch({
    		type: "deleted",
    		id: taskId
    	});
    }

</code>

L'object che si passa a dispatch viene chiamata una "action":

<code>
	function handleDeleteTask(taskId) {
			dispatch(
		---> "action" object
				{
				type: "deleted",
				id: taskId
			}
		<--- "action" object
			);
		}
</code>

E' un object JavaScript regolare. Si può decidere cosa inserirvi all'interno, ma generalmente dovrebbe contenere le minime informazioni riguardo a ciò succede. Si aggiungerà la function dispatch stessa in un passo successivo.

Nota: Un action object può avere ogni forma. Per convenzione, é comune dare a questo una string type che descriva cosa accade, e passi ogni altra informazione addizionale in altri fields. Il type é specifico ad un Component, quindi in quest'esempio sia "added" che "added_task" andranno bene. Occorre scegliere un name che dica cos'é accaduto.

<code>
	dispatch({
		// specifico al Component
		type: "what_happened",
		// gli altri fields vanno qui
	})
</code>

### 23.3. Step 2: Write a reducer function

Una reducer function é dove si inserirà la logica dello State. Questa prende due arguments, lo State corrente e l'action object, e restituisce lo State seguente:

<code>

    function yourReducer(state, action){
    	// restituisce lo State seguente da impostare per React
    }

</code>

React imposterà lo State a quello che verrà restituito dal reducer.

Per muovere la logica di setting dello State da un Event Handler ad una reducer function in questo esempio, si dovrà:

1. Dichiarare lo State corrente (tasks) come primo argument

2. Dichiarare l'object "action" come secondo argument

3. Restituire lo State successivo dal reducer (con il quale anche React imposterà lo State).

Ecco tutta la logica di setting dello State migrata ad una reducer function:

<code>

    function tasksReducer(tasks, action) {
    	if (action.type === "added") {
    		return [
    			...tasks,
    			{
    				id: action.id,
    				text: action.text,
    				done: false
    			}
    		];
    	} else if (action.type === "changed") {
    		return tasks.map((t) => {
    			if (t.id === action.task.id) {
    				return action.task;
    			} else {
    				return t;
    			}
    		});
    	} else if (action.type === "deleted") {
    		return tasks.filter((t) => t.id !== action.id);
    	} else {
    		throw Error("Unknown action: " + action.type);
    	}
    }

</code>

Visto che la reducer function prende lo State come un argument (tasks), si può dichiararla fuori dal Component che la userà.
Questo fa diminuire il livello di indentazione e può rendere il codice più facile da leggere.

Nota: Il codice soprastante usa degli statements if/else, ma é convenzione usare degli switch statements dentro i reducer.
Il risultato é lo stesso, ma a prima vista può essere più facile leggere degli switch statements.
Useremo infatti questi nel resto della documentazione:

<code>

    function tasksReducer(tasks, action) {

    	// convenzione usare switch statement:
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

</code>

Si raccomanda di avvolgere ogni case block in una coppia di parentesi grafe, in modo che tali variabili dichiarate all'interno dei diversi case non collidano tra loro. Inoltre, un case solitamente dovrebbe terminare con un return. Se si dimentica il return il codice cadrà nel successivo case, che può portare ad errori.

Se non si é a proprio agio con gli switch, va benissimo usare del blocchi if / else.

### 23.4. Why are reducers called this way?

Anche se i reducer possono "ridurre" l'ammontare di codice dentro al Component, sono stati nominati in questo modo dopo l'operazione reduce() che si può eseguire negli Array.

Il metodo reduce() permette di prendere un Array e "accumulare" una singola value tra molte:

<code>
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce(
	(result, number) => result + number
);
</code>

(Vedi accumulator e value del reducer in Coding Train).

La funzione che si passa alla Higher Order Function reduce() é conosciuta come "reducer". Prende il result presente e il current item, e poi restituisce il prossimo result.
I reducer di React sono un esempio della stessa idea: prendono lo State attuale e la action, e restituiscono lo State successivo. In questo modo, accumulano actions col tempo nello State.

<code>

    import tasksReducer from './tasksReducer.js';

    let initialState = [];
    let actions = [
    	{type: 'added', id: 1, text: 'Visit Kafka Museum'},
    	{type: 'added', id: 2, text: 'Watch a puppet show'},
    	{type: 'deleted', id: 1},
    	{type: 'added', id: 3, text: 'Lennon Wall pic'},
    ];

    let finalState = actions.reduce(tasksReducer, initialState);

    const output = document.getElementById('output');
    output.textContent = JSON.stringify(finalState, null, 2);

</code>

Risultato:

<code>
[
  {
    "id": 2,
    "text": "Watch a puppet show",
    "done": false
  },
  {
    "id": 3,
    "text": "Lennon Wall pic",
    "done": false
  }
]
</code>

Questo é un modo similare a ciò che fa React.js.

### 23.5. Step 3: Use the reducer from your component

Infine, si ha bisogno di agganciare il taskReducer al Component.
Importiamo l'Hook useReducer da React:

<code>
	import {useReducer} from "react";
</code>

Poi si può sostituire lo State:

<code>
	const [tasks, setTasks] = useState(initialTasks);
</code>

con useReducer:

<code>
	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
</code>

L'Hook useReducer é similare a useState - occorre passare a questo un initial State e restituire una Stateful value e un modo per il set dello State (in questo caso, la function dispatch). Ma é un po' differente.

L'Hook useReducer prende due arguments:

1. Una reducer function
2. Un initial State

E restituisce:

1. Una stateful value
2. Una dispatch function (per "spedire (dispatch)" le actions al reducer)

Ora é completamente cablato. Qui, il reducer viene dichiarato nel basso del file del Component:

<code>

    import React, { useState, useReducer } from "react";
    // import AddTask from
    // import TaskList from

    export default function TaskApp() {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	function handleAddTask(text) {
    		dispatch({
    			type: "added",
    			id: nextId++,
    			text: text
    		});
    	}

    	function handleChangeTask(task) {
    		dispatch({
    			type: "changed",
    			task: task
    		});
    	}

    	function handleDeleteTask(taskId) {
    		dispatch({
    			type: "deleted",
    			id: taskId
    		});
    	}

    	return (
    		<>
    			<h1>Prague Itinerary</h1>
    			<AddTask onAddTask={handleAddTask} />
    			<TaskList
    				tasks={tasks}
    				onChangeTask={handleChangeTask}
    				onDeleteTask={handleDeleteTask}
    			/>
    		</>
    	);
    }

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    let nextId = 3;
    const initialTasks = [
    	{ id: 0, text: "Visit Kafka Museum", done: true },
    	{ id: 1, text: "Watch a puppet show", done: false },
    	{ id: 2, text: "Lennon Wall pic", done: false }
    ];

</code>

Se si vuole, si può muovere il reducer in un file differente:

In tasksReducer.jsx:

<code>

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

</code>

In App.jsx:

<code>

    import React, { useState, useReducer } from "react";
    // import AddTask from
    // import TaskList from
    import tasksReducer from "../tasksReducer";

    export default function TaskApp() {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	function handleAddTask(text) {
    		dispatch({
    			type: "added",
    			id: nextId++,
    			text: text
    		});
    	}

    	function handleChangeTask(task) {
    		dispatch({
    			type: "changed",
    			task: task
    		});
    	}

    	function handleDeleteTask(taskId) {
    		dispatch({
    			type: "deleted",
    			id: taskId
    		});
    	}

    	return (
    		<>
    			<h1>Prague Itinerary</h1>
    			<AddTask onAddTask={handleAddTask} />
    			<TaskList
    				tasks={tasks}
    				onChangeTask={handleChangeTask}
    				onDeleteTask={handleDeleteTask}
    			/>
    		</>
    	);
    }

    let nextId = 3;
    const initialTasks = [
    	{ id: 0, text: "Visit Kafka Museum", done: true },
    	{ id: 1, text: "Watch a puppet show", done: false },
    	{ id: 2, text: "Lennon Wall pic", done: false }
    ];

</code>

La logica del Component può essere più facile da leggere quando si separano concetti come questo.
Ora gli Event Handlers specificano solamente cosa accade spedendo (dispatching) actions, e la reducer function determina come lo State di aggiorna in risposta a queste.

### 23.6. Comparing useState and useReducer

I reducers non sono privi di aspetti negativi. Ecco alcuni modi in cui puoi compararli:

• Code Size: Generalmente, con useState si deve scrivere meno codice in anticipo. Con useReducer, si devono scrivere sia una reducer function che le dispatch actions. Comunque useReducer può aiutare a ridurre il codice se molti Event Handlers modificano lo State in modo similare.

• Readability: useState é molto facile da leggere quando l'aggiornamento dello State é semplice. Quando ottiene maggior complessità, potrebbero gonfiare il codice del Component e renderne difficoltosa la lettura. In questo caso, useReducer permette di separare chiaramente il come della logica di aggiornamento dal cosa accade degli event handlers.

• Debugging: Quando vi é un bug con useState, può essere difficoltoso dire dove lo State é stato impostato in modo non corretto e perché. Con useReducer, si può aggiungere un console.log nel reducer per vedere ogni aggionamento dello State, e perché questo accade, in base alle action nello switch. Se ogni action é corretta, si saprà che l'errore si trova nella logica del reducer stesso. Comunque, occorrerà passare attraverso più codice che con useState.

• Testing: Un reducer é una funzione pura che non dipende dal Component. Questo significa che si può esportarlo e testarlo in isolamento rispetto al resto del codice. Mentre generalmente é meglio testare i Components in un ambiente più reale, per delle logiche di aggiornamento dello State più complesse può essere utile asserire che il reducer restituisca un particolare State per un particolare initial State ed action.

• Personal preference: Ad alcune persone piacciono i reducer, ad altre no. E va bene. Sono preferenze. Si può sempre convertire da useState e useReducer e viceversa, sono equivalenti.

Si raccomanda di usare un reducer se si incontrano frequentemente bug a causa degli aggiornamenti non corretti dello State in un Component e si vuole introdurre più struttura nel codice. Non si devono usare i reducer per tutto, si può mixare il tutto e abbinare. Si possono usare addirittura insieme useState e useReducer nello stesso Component.

### 23.7. Writing reducers well

Tenere a mente questi due consigli quando si scrivono i reducer:

• **I Reducers devono essere puri.** Similarmente alle funzioni di aggiornamento dello State, i reducers si eseguono durante il rendering (le actions vengono messe in coda fino al render successivo). Questo significa che i reducers devono essere puri, agli stessi input risultano sempre gli stessi output. Non dovrebbero inviare requests, schedulare timeout, o eseguire dei Side Effects (operazioni che impattano cose al di fuori del Component). Dovrebbero aggiornare objects e array senza mutazioni.

• **Ogni action descrive una singola interazione dell'utente, persino se porta a molteplici cambiamenti nei dati.** Per esempio, se un utente preme "Reset" su di un Form con cinque fields gestiti da un reducer, ha più senso usare un dispatch action "reset_form" piuttosto che cinque separate actions "set_field". Se si volesse loggare ogni azione nel reducer, tale log sarebbe pulito abbastanza da ricostruire quale interazione o risposta avviene in quale ordine. Questo é utile anche nel debugging.

### 23.8. Write concise reducers with Immer

Proprio come con l'aggiornamento di objects e array nel regular State, si può usare la library Immer per rendere i reducers più concisi. Qui, useImmerReducer permette di mutare lo State con push o l'assegnamento arr[i] = :

<code>
	import { useImmerReducer } from "...";
	import AddTask from "...";
	import TaskList from "...";

    function tasksReducer(draft, action) {
    	switch (action.type) {
    		case "added": {
    			draft.push({
    				id: action.id,
    				text: action.text,
    				done: false
    			});
    			break;
    		}
    		case "changed": {
    			const index = draft.findIndex((t) => t.id === action.task.id);
    			draft[index] = action.task;
    			break;
    		}
    		case "deleted": {
    			return draft.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    export default function TaskApp() {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	function handleAddTask(text) {
    		dispatch({
    			type: "added",
    			id: nextId++,
    			text: text
    		});
    	}

    	function handleChangeTask(task) {
    		dispatch({
    			type: "changed",
    			task: task
    		});
    	}

    	function handleDeleteTask(taskId) {
    		dispatch({
    			type: "deleted",
    			id: taskId
    		});
    	}

    	return (
    		<>
    			<h1>Prague Itinerary</h1>
    			<AddTask onAddTask={handleAddTask} />
    			<TaskList
    				tasks={tasks}
    				onChangeTask={handleChangeTask}
    				onDeleteTask={handleDeleteTask}
    			/>
    		</>
    	);
    }

</code>

I Reducers devono essere puri, quindi non dovrebbero mutare lo State. Ma Immer fornisce l'object draft che é un modo sicuro per mutare. Immer crea una copia dello State con i cambiamenti fatti sul draft. Ecco perché i reducers gestiti da useImmerReducer possono mutare i loro primi arguments e non hanno bisogno di restituire uno State.

### 23.9. Exercises:

1-

ContactList.jsx:

<code>

    export default function ContactList({contacts, selectedId, dispatch}) {
    	return (
    		<section className="contact-list">
    			<ul>
    				{contacts.map((contact) => (
    					<li key={contact.id}>
    						<button
    							onClick={() => {
    								// TODO: dispatch changed_selection
    								dispatch({
    									type: "changed_selection",
    									contactId: contact.id,
    									message: ""
    								})
    							}}>
    							{selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
    						</button>
    					</li>
    				))}
    			</ul>
    		</section>
    	);
    }

</code>

Chat.jsx:

<code>
	export default function Chat({contact, message, dispatch}) {
		return (
			<section className="chat">
				<textarea
					value={message}
					placeholder={'Chat to ' + contact.name}
					onChange={(e) => {
						// TODO: dispatch edited_message
						// (Read the input value from e.target.value)
						dispatch({
							type: "edited_message",
							selectedId: contact.id,
							message: e.target.value
						})
					}}
				/>
				<br />
				<button>Send to {contact.email}</button>
			</section>
		);
	}
</code>

Quasi perfetto :white_check_mark:

2-

<code>

    export default function Chat({contact, message, dispatch}) {
    	return (
    		<section className="chat">
    			<textarea
    				value={message}
    				placeholder={'Chat to ' + contact.name}
    				onChange={(e) => {
    					dispatch({
    						type: 'edited_message',
    						message: e.target.value,
    					});
    				}}
    			/>
    			<br />
    			<button onClick={()=> {
    			console.log("Send to: " + contact.email + " with message: " + message);
    			dispatch({
    				type: 'edited_message',
    				message: ''
    			})
    			}}>Send to {contact.email}</button>
    		</section>
    	);
    }

</code>

Perfetto :white_check_mark:

Soluzione alternativa, creare nuova action nel reducer:

<code>

    case 'sent_message': {
    			return {
    				...state,
    				message: '',
    			};
    		}

</code>

3-

<code>
		export const initialState = {
			selectedId: 0,
			messages: {
				0: 'Hello, Taylor',
				1: "Hello, Alice",
				2: "Hello Bob"
			}
		};

    export function messengerReducer(state, action) {
    	switch (action.type) {
    		case 'changed_selection': {
    			return {
    				...state,
    				selectedId: action.contactId
    			};
    		}
    		case 'edited_message': {
    			return {
    				...state,
    				messages: {...state.messages, [state.selectedId]: action.message}
    			};
    		}
    		case 'sent_message': {
    			return {
    				...state,
    				message: '',
    			};
    		}
    		default: {
    			throw Error('Unknown action: ' + action.type);
    		}
    	}
    }

</code>

Quasi funzionante, mancava modifica App.jsx, ripassare invio e ricezione dati dal reducer.

Dopo Ripasso:

<code>
App.jsx:

    import { useReducer } from 'react';
    import Chat from './Chat.js';
    import ContactList from './ContactList.js';
    import { initialState, messengerReducer } from './messengerReducer';

    export default function Messenger() {
    	const [state, dispatch] = useReducer(messengerReducer, initialState);
    	const message = state.messages[state.selectedId];
    	const contact = contacts.find((c) => c.id === state.selectedId);
    	return (
    		<div>
    			<ContactList
    				contacts={contacts}
    				selectedId={state.selectedId}
    				dispatch={dispatch}
    			/>
    			<Chat
    				key={contact.id}
    				message={message}
    				contact={contact}
    				dispatch={dispatch}
    			/>
    		</div>
    	);
    }

    const contacts = [
    	{id: 0, name: 'Taylor', email: 'taylor@mail.com'},
    	{id: 1, name: 'Alice', email: 'alice@mail.com'},
    	{id: 2, name: 'Bob', email: 'bob@mail.com'},
    ];

messagerReducer.jsx

    export const initialState = {
    	selectedId: 0,
    	messages: {
    		0: "Hello, Taylor",
    		1: "Hello, Alice",
    		2: "Hello, Bob"
    	},
    };

    export function messengerReducer(state, action) {
    	console.log(action.message);
    	switch (action.type) {
    		case 'changed_selection': {
    			return {
    				...state,
    				selectedId: action.contactId,
    			};
    		}
    		case 'edited_message': {
    			return {
    				...state,
    				messages:
    				{...state.messages, [state.selectedId]: action.message}
    			};
    		}
    		case 'sent_message': {
    			return {
    				...state,
    				message: '',
    			};
    		}
    		default: {
    			throw Error('Unknown action: ' + action.type);
    		}
    	}
    }

Chat.jsx e ContactList.jsx invariati.

Perfetto :white_check_mark:

</code>

4-

Ricorda: il dispatching di un action chiama un reducer con il current state la action, e archivia il risultato nello state seguente.

<code>
import { useState } from 'react';

export function useReducer(reducer, initialState) {
const [state, setState] = useState(initialState);

function dispatch(action){
setState(reducer(state, action))
}
return [state, dispatch];
}

</code>

Quasi Corretto, guardata spiegazione poi trovata soluzione. :white_check_mark:

## 24. Passing Data Deeply with Context

Di solito, si passano informazioni da un parent Component ad un child Component attraverso le prop.
Ma passare le prop può diventare prolisso e sconveniente se si devono passare attraverso molti Components nel mezzo, o se molti Components nell'App necessitano della stessa informazione. Il Context permette al parent Component di rendere delle informazioni disponibili ad ogni Component nel tree al di sotto di questo, non importa quanto in profondità, senza passarle esplicitamente attraverso le props.

### 24.1. The problem with passing props

Passare le props é un ottimo modo di convogliare dei dati attraverso il tree della UI fino al Component che li userà.
Ma passare le props può diventare prolisso e sconveniente quando si ha bisogno di passare delle prop in profondità nel tree, o se molti Components necessitano delle stesse prop. Il più comune ancestor dei vari Components può essere molto distante da questi che necessitano dei dati, e alzare lo State (Lifting Stae Up) così tanto può portare ad una situazione chiamata "prop drilling".

Per risolvere questa situazione senza quindi dover passare i dati attraverso molti Components intramezzo, si può usare la feauture Context.

### 24.2. Context: an alternative to passing props

Il Context permette ad un parent Component di fornire dati all'intero tree al di sotto di esso. Vi sono molti usi per il Context. Eccone un esempio. Si consideri questo Heading Component che accetta un level per la sua size (dimensione intesa h1, h2...):

<code>

    import ContextHeading from "./ContextHeading";
    import ContextSection from "./ContextSection";

    export default function ContextPage() {
    	return (
    		<ContextSection>
    			<ContextHeading level={1}>Title</ContextHeading>
    			<ContextHeading level={2}>Heading</ContextHeading>
    			<ContextHeading level={3}>Sub-Heading</ContextHeading>
    			<ContextHeading level={4}>Sub-Sub-Heading</ContextHeading>
    			<ContextHeading level={5}>Sub-Sub-Sub-Heading</ContextHeading>
    			<ContextHeading level={6}>Sub-Sub-Sub-Sub-Heading</ContextHeading>
    		</ContextSection>
    	);
    }

    export default function ContextSection({ children }) {
    	return <section className="section">{children}</section>;
    }

    export default function ContextHeading({ level, children }) {
    	switch (level) {
    		case 1:
    			return <h1>{children}</h1>;
    		case 2:
    			return <h2>{children}</h2>;
    		case 3:
    			return <h3>{children}</h3>;
    		case 4:
    			return <h4>{children}</h4>;
    		case 5:
    			return <h5>{children}</h5>;
    		case 6:
    			return <h6>{children}</h6>;
    		default:
    			throw Error("Unknown level: " + level);
    	}
    }

</code>

Diciamo di volere dei molteplici heading all'interno della stessa ContextSection per avere sempre la stessa size:

<code>

    export default function ContextPage() {
    	return (
    		<ContextSection>
    			<ContextHeading level={1}>Title</ContextHeading>
    			<ContextSection>
    				<ContextHeading level={2}>Heading</ContextHeading>
    				<ContextHeading level={2}>Heading</ContextHeading>
    				<ContextHeading level={2}>Heading</ContextHeading>
    				<ContextSection>
    					<ContextHeading level={3}>Sub-heading</ContextHeading>
    					<ContextHeading level={3}>Sub-heading</ContextHeading>
    					<ContextHeading level={3}>Sub-heading</ContextHeading>
    					<ContextSection>
    						<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    						<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    						<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    					</ContextSection>
    				</ContextSection>
    			</ContextSection>
    		</ContextSection>
    	);
    }

</code>

Al momento si passa la prop level ad ogni ContextHeading separatamente:

<code>

    <ContextSection>
    						<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    						<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    						<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    </ContextSection>

</code>

Sarebbe ottimale poter passare la prop level al ContextSection Component invece e rimuoverlo dall' ContextHeading. In questo modo si possono forzare tutti gli Heading Components presenti nella Section ad avere la stessa size:

<code>

    <ContextSection level={3}>
    					<ContextHeading>About</ContextHeading>
    					<ContextHeading>Photos</ContextHeading>
    					<ContextHeading>Videos</ContextHeading>
    </ContextSection>

</code>

Ma come può l'Heading Component conoscere la prop level della più vicina Section? Quello richiederebbe in qualche modo per un child di "chiedere" i dati da qualche parte più in alto nel tree.

Non si può farlo solamente con le prop. Qui é dove il context entra in gioco. Lo si può fare in tre step:

1. Creare un Context - lo si può chiamare in questo caso LevelContext, visto che é per il level dell'heading.

2. Usare tale Context dal Component che necessita di tali dati - il Component Heading userà LevelContext.

3. Fornire tale Context dal Component che specifica i dati - Section fornirà LevelContext.

Il Context permette ad un parent, persino ad uno distante, di fornire dei dati all'intero tree al di sotto di esso.

### 24.3. Step 1: Create the context

Prima, si ha bisogno di creare il Context. Si avrà bisogno di esportarlo da un file così i Components potranno usarlo:

<code>

    import { createContext } from "react";

    export const LevelContext = createContext(1);

</code>

L'unico argument per createContext é la default value. Qui, 1 si refirisce al level degli Heading più grande, ma si può passare ogni tipo di value, persino un object. Si vedrà l'importanza della default value nel prossimo step.

### 24.4. Step 2: Use the context

Ora importiamo l'Hook useContext da React ed il Context stesso:

<code>
	import { useContext } from "react";
	import { LevelContext } from "./LevelContext";
</code>

Correntemente, il Component ContextHeading legge level dalle props:

<code>
	export default function ContextHeading({ level, children }) {...}
</code>

Quindi leviamo la prop level e leggiamo la value dal context appena importato LevelContext:

<code>
	export default function ContextHeading({ children }) {
		const level = useContext(LevelContext); 
		...}
</code>

useContext é un Hook. Proprio come useState e useReducer, si può chiamare un Hook solamente da dentro un Component React, non dentro a loop o conditions.
useContext dice a React che il Component ContextHeading vuole leggere LevelContext.

Ora che ContextHeading non ha più la level prop, non si ha più bisogno di passere la prop level alle istanze di ContextHeading nel JSX:

<code>

    		<ContextSection>
    			<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    			<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    			<ContextHeading level={4}>Sub-sub-heading</ContextHeading>
    		</ContextSection>

</code>

Aggiorniamo quindi il JSX in modo che sia ContextSection a ricevere invece:

<code>

    export default function ContextPage() {
    	return (
    		<ContextSection level={1}>
    			<ContextHeading>Title</ContextHeading>
    			<ContextSection level={2}>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextSection level={3}>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextSection level={4}>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    					</ContextSection>
    				</ContextSection>
    			</ContextSection>
    		</ContextSection>
    	);
    }

</code>

Questo esempio ancora non funziona. Tutti gli Headings al momento hanno la stessa size perché non immaginano nemmeno che si stia usando il Context, non lo si ha ancora fornito, React non sa dove prenderlo.

Se non si fornisce il context, React userà la value di default che si ha specificato nello step precedente. In quest'esempio si ha specificato 1 a createContext nel Component LevelContext, quindi useContext(LevelContext) restituirà 1, impostando tutti gli Headings come h1. Sistemiamo il problema fornendo ad ogni Section il proprio context.

### 24.5. Step 3: Provide the context

Il Component ContextSection al momento renderizza i suoi children:

<code>

    export default function ContextSection({ children }) {
    	return <section className="section">
    						{children}
    					 </section>;
    }

</code>

Avvolgiamoli in un Component Context.Provider per fornire il LevelContext a questi:

<code>
	import { LevelContext } from "./LevelContext";

    export default function ContextSection({ level, children }) {
    	return (
    		<section className="section">
    			<LevelContext.Provider value={level}>
    					{children}
    				</LevelContext.Provider>
    		</section>
    	);
    }

</code>

Questo dice a React: se qualche Component dentro questa Section chiede per LevelContext, gli si dia questo level.
Il Component userà la value del più vicino <LevelContext.Provider/> nell'UI tree sopra di esso.

<code>

    export default function ContextPage() {
    	return (
    		<ContextSection level={1}>
    			<ContextHeading>Title</ContextHeading>
    			<ContextSection level={2}>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextSection level={3}>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextSection level={4}>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    					</ContextSection>
    				</ContextSection>
    			</ContextSection>
    		</ContextSection>
    	);
    }

</code>

E' lo stesso risultato del codice originale, ma non si ha bisogno di passare la prop level ad ogni Component ContextHeading. Invece, si figura il proprio level di heading dal più vicino soprastante Component ContextSection:

1. Si passa un level prop a ContextSection
2. Il Component ContextSection avvolge i suoi children in un <LevelContext.Provider value={level}>.
3. I Components ContextHeading chiedono la value più vicina soprastante di LevelContext con useContext(LevelContext).

### 24.6. Using and providing context from the same component

Al momento, si deve ancora specificare ogni level di una section manualmente:

<code>

    export default function Page() {
    	return (
    		<Section level={1}>
    			...
    			<Section level={2}>
    				...
    				<Section level={3}>
    					...

</code>

Visto che il context permette di leggere informazioni da un Component soprastante, ogni ContextSection potrebbe leggere level dalla ContextSection soprastante, e passando level + 1 in basso automaticamente. Così é come si può fare:

<code>
	import { useContext } from "react";
	import { LevelContext } from "./LevelContext";

    export default function ContextSection({ children }) {
    	const level = useContext(LevelContext);
    	return (
    		<section className="section">
    			<LevelContext.Provider value={level + 1}>
    				{children}
    			</LevelContext.Provider>
    		</section>
    	);
    }

</code>

Con questo cambiamento, non vi é più la necessità di passare la prop level ne al ContextSection ne al ContextHeading:

<code>

    export default function ContextPage() {
    	return (
    		<ContextSection>
    			<ContextHeading>Title</ContextHeading>
    			<ContextSection>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextHeading>Heading</ContextHeading>
    				<ContextSection>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextHeading>Sub-heading</ContextHeading>
    					<ContextSection>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    						<ContextHeading>Sub-sub-heading</ContextHeading>
    					</ContextSection>
    				</ContextSection>
    			</ContextSection>
    		</ContextSection>
    	);
    }

</code>

Ora sia ContextHeading che ContextSection leggono LevelContext e si figurano quanto sono in profondità. E il Component ContextSection avvolge i propri children nel LevelContext per specificare che tutto dentro a questo é ad un livello più "profondo".

Nota: Quest'esempio usa i livelli degli heading perché si mostrano visualmente come i Components annidati possono sovrascrivere il Context. Ma il Context é utile per molti altri casi. Si può passare verso il basso qualsisi informazione di cui si ha bisogno dall'intero subtree: il color theme corrente, lo user loggato corrente e così via.

### 24.7. Context passes through intermediate components

Si possono inserire quanti Components desideriamo tra il Component che fornisce il Context e quello che lo usa. Questo include sia i Components integrati come un div che i Components creati da noi.

In quest'esempio, lo stesso Component Post (con un border dashed) viene renderizzato a due livelli di annidamento. Si noti che l'Heading Component dentro a questo ottiene il suo level automaticamente dalla più vicina Section:

<code>

LevelContext.jsx

    import { createContext } from "react";
    export const LevelContext = createContext(0);

ProfilePage.jsx

    import React from "react";
    import ProfileHeading from "./ProfileHeading";
    import ProfileSection from "./ProfileSection";

    export default function ProfilePage() {
    	return (
    		<ProfileSection>
    			<ProfileHeading>My Profile</ProfileHeading>
    			<Post title="Hello traveller!" body="Read about my adventures" />
    			<AllPosts />
    		</ProfileSection>
    	);
    }

    function AllPosts() {
    	return (
    		<ProfileSection>
    			<ProfileHeading>Posts</ProfileHeading>
    			<RecentsPosts />
    		</ProfileSection>
    	);
    }

    function RecentsPosts() {
    	return (
    		<ProfileSection>
    			<ProfileHeading>Recent Posts</ProfileHeading>
    			<Post title="Flavors of Lisbon" body="...those pastéis de nata!" />
    			<Post title="Buenos Aires in the rhythm of tango" body="I loved it!" />
    		</ProfileSection>
    	);
    }

    function Post({ title, body }) {
    	return (
    		<ProfileSection isFancy={true}>
    			<ProfileHeading>{title}</ProfileHeading>
    			<p>
    				<i>{body}</i>
    			</p>
    		</ProfileSection>
    	);
    }

ProfileSection.jsx

    import { useContext } from "react";
    import { LevelContext } from "./LevelContext";

    export default function ProfileSection({ children, isFancy }) {
    	const level = useContext(LevelContext);
    	return (
    		<section className={"section " + (isFancy ? "fancy" : "")}>
    			<LevelContext.Provider value={level + 1}>
    				{children}
    			</LevelContext.Provider>
    		</section>
    	);
    }

ProfileHeading.jsx

    import { useContext } from "react";
    import { LevelContext } from "./LevelContext";

    export default function ProfileHeading({ children }) {
    	const level = useContext(LevelContext);
    	switch (level) {
    		case 0:
    			throw Error("Heading must be inside a Section!");
    		case 1:
    			return <h1>{children}</h1>;
    		case 2:
    			return <h2>{children}</h2>;
    		case 3:
    			return <h3>{children}</h3>;
    		case 4:
    			return <h4>{children}</h4>;
    		case 5:
    			return <h5>{children}</h5>;
    		case 6:
    			return <h6>{children}</h6>;
    		default:
    			throw Error("Unknown level: " + level);
    	}
    }

</code>

Non si esegue nulla di speciale per far funzionare quest'esempio. Una ProfileSection specifica il context per il tree dentro a questo, così si può inserire un ProfileHeading ovunque, ed avrà la corretta size.

Il Context permette di scrivere Components che si "adattano ai loro dintorni" e visualizzano se stessi differentemente in base a dove o, in altre parole, in quale contesto (context) vengono renderizzati.

Il funzionamento del context potrebbe ricordare l'ereditarietà delle property nel CSS. Nel CSS si può speificare un color: blue per un div, ed ogni DOM node dentro a questo, non importa quanto in profondità, erediterà tale color a meno che altri DOM nodes nel mezzo non sovrascrivano tale property con color : green, per esempio. Similarmente in React, l'unico modo per sovrascrivere del context proveniente da più in alto, é avvolgere i children in un context provider con una value differente.

In CSS, differenti properties come color e background-color non si sovrascrivono tra loro. Si possono impostare diverse properties color senza impattare sul background-color. Similarmente, diversi context di React non vanno a sovrascriversi tra loro. Ogni context che si crea con createContext() é completamente separato dagli altri, e si lega ai Components usando e fornendo (using and providing) quel particolare context. Un Component può usare o fornire differenti context senza problemi.

### 24.8. Before you use context

Il Context é molto tentevole da usare. Comunque questo significa che é troppo facile abusarne. Solo perché si ha bisogno di passare varie props a vari livelli di profondità non significa che si dovrebbero inserire tali informazioni nel context.

Ecco alcune alternative che si dovrebbero considerare prima di usare il context:

1. **Cominciare passando le props**. Se i Components non sono banali, non é inusuale passare dozzine di prop in basso attraverso dozzine di Components. Può far sgobbare, ma rende molto chiaro quali Components usano quali dati.

2. **Estrarre Components e passare del JSX come children a questi**. Se si passano dei dati attraverso vari layer o Components intermedi che non usano tali dati, e li passano solo verso il basso, di solito significa che si é dimenticato di estrarre quale Component lungo la via. Per esempio, forse si potrebbero passare dei dati come prop come posts a dei visual Components che non li usano direttamente come <Layout posts={posts}>. Invece si può far prendere a Layout children come prop, e renderizzare <Layout><Posts posts={posts}>/Layout>.
   Questo riduce il numero di layes tra il Component che specifica i dati e quello che li necessita.

Se nessuno di questi approcci funziona bene per la situazione, si consideri il Context.

### 24.9. Use cases for context

• **Theming**: se un App permette all'utente di cambiare il suo aspetto, per esempio con la dark mode, si può inserire un Context Provider nel top dell'App, e usare tale Context nei Components che ne necessitano per cambiare il visual look.

• **Current Account**: molti Components possono necessitare di conoscere l'utente corrente loggato. Inserirlo nel Context rende conveniente leggerlo ovunque nel tree. Alcune App permettono inoltre di operare con molteplici account allo stesso momento, per esempio lasciare un commento come uno user differente. In questi casi può essere conveniente avvolgere una parte della UI in un Provider annidato con una value di account corrente differente.

• **Routing**: la maggior parte delle soluzioni di Routing usano il context internamente per ospitare la route corrente. Questo é il modo in cui ogni link "sa" se é attivo o no. Se si volesse costruire il proprio router, questo metodo é auspicabile.

• **Managing State**: mano a mano che l'App cresce, vi potrebbe finire con l'avere molto State nel top dell'App, con molti Components distanti verso il basso che vorrebbero cambiarlo. E' comune usare un Reducer insieme al Context per gestire uno State generale complesso e passarlo verso il basso a Components senza troppe seccature.

Il Context non é limitato alle static values. Se si passa una value differente al render successivo, React aggiornerà tutti i Components sottostanti leggendolo. Ecco perché il Context viene usato spesso in combinazione con lo State.

In generale, se alcune informazioni sono necessarie da Components distanti nel tree, conviene farsi aiutare dal Context.

### 24.10. Exercises

1-

<code>

App.js

    import { useState, useContext } from 'react';
    import { places } from './data.js';
    import { getImageUrl } from './utils.js';
    import {ImageSizeContext} from "./Context.js";

    export default function App() {
    	const [isLarge, setIsLarge] = useState(false);
    	let imageSize = useContext(ImageSizeContext);
    	imageSize = isLarge ? 150 : 100;


    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={isLarge}
    					onChange={e => {
    						setIsLarge(e.target.checked);
    					}}
    				/>
    				Use large images
    			</label>
    			<hr />
    		<ImageSizeContext.Provider value={imageSize}>
    			<List/>
    		</ImageSizeContext.Provider>
    		</>
    	)
    }

    function List() {
    	const listItems = places.map(place =>
    		<li key={place.id}>
    			<Place
    				place={place}
    			/>
    		</li>
    	);
    	return <ul>{listItems}</ul>;
    }

    function Place({ place }) {
    	return (
    		<>
    			<PlaceImage
    				place={place}
    			/>
    			<p>
    				<b>{place.name}</b>
    				{': ' + place.description}
    			</p>
    		</>
    	);
    }

    function PlaceImage({ place }) {
    	const imageSize = useContext(ImageSizeContext);
    	return (
    		<img
    			src={getImageUrl(place)}
    			alt={place.name}
    			width={imageSize}
    			height={imageSize}
    		/>
    	);
    }

Context.js

    import {createContext} from "react";

    export const ImageSizeContext = createContext();

    oppure

    import {createContext} from "react";

    export const ImageSizeContext = createContext(100);

</code>

Quasi perfetto, non serve dichiarazione:

let imageSize = useContext(ImageSizeContext);

Basta passare direttamente in ImageSizeContext.Provider value={imageSize}:

<code>

    export default function App() {
    	const [isLarge, setIsLarge] = useState(false);
    	const imageSize = isLarge ? 150 : 100;


    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={isLarge}
    					onChange={e => {
    						setIsLarge(e.target.checked);
    					}}
    				/>
    				Use large images
    			</label>
    			<hr />
    		<ImageSizeContext.Provider value={imageSize}>
    			<List/>
    		</ImageSizeContext.Provider>

</code>

## 25. Scaling Up with Reducer and Context

I Reducers permettono di consolidare la logica di aggiornamento di un Component.
Il Context permette di passare informazioni in profondità ad altri Components.
Si possono combinare reducers e context per gestire lo State di uno screen complesso.

### 25.1. Combining a reducer with context

Partiamo dall'esempio mostrato nel capitolo Introduction to reducers, dove lo State veniva gestito da un reducer. La reducer function contiene tutta la logica di aggiornamento dello State e viene dichiarata nella parte inferiore del file:

<code>

    import { useReducer } from "react";
    import AddTask from "./AddTaskReducerContext";
    import TaskList from "./TaskListReducerContext";

    export default function TaskApp() {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	function handleAddTask(text) {
    		dispatch({
    			type: "added",
    			id: nextId++,
    			text: text
    		});
    	}

    	function handleChangeTask(task) {
    		dispatch({
    			type: "changed",
    			task: task
    		});
    	}

    	function handleDeleteTask(taskId) {
    		dispatch({
    			type: "deleted",
    			id: taskId
    		});
    	}

    	return (
    		<>
    			<h1>Day off in Kyoto</h1>
    			<AddTask onAddTask={handleAddTask} />
    			<TaskList
    				tasks={tasks}
    				onChangeTask={handleChangeTask}
    				onDeleteTask={handleDeleteTask}
    			/>
    		</>
    	);
    }

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    let nextId = 3;

    const initialTasks = [
    	{ id: 0, text: "Philosopher’s Path", done: true },
    	{ id: 1, text: "Visit the temple", done: false },
    	{ id: 2, text: "Drink matcha", done: false }
    ];

</code>

Un Reducer aiuta a mantenere gli Event Handlers corti e concisi. Comunque, mano a mano che l'App cresce, si potrebbe incappare in un'altra difficoltà. Al momento, lo State tasks e la function dispatch sono solamente disponibili al top level del TaskApp Component. Per permettere ad altri Components di leggere la lista delle tasks o cambiarla, occorre passare verso il basso esplicitamente lo State corrente, e gli Event Handlers che lo cambiano, come prop.

Per esempio, TaskApp passa una lista di task e gli Event Handlers a TaskList:

<code>
	<TaskList 
		tasks={tasks}
		onChangeTask={handleChangeTask}
		onDeleteTask={handleDeletetask}
	 />
</code>

E TaskList passa gli Event Handlers a Task:

<code>
	<Task 
		task={task} 
		onChange={onChangeTask} 
		onDelete={onDeleteTask} 
	/> 
</code>

In un piccolo esempio come questo, funziona bene, ma se si hanno decine o centinaia di Components nel mezzo, passare verso il basso tutto lo State e le funzioni può essere abbastanza frustrante.

Questo é il motivo per cui, come un'alternativa al passarle attraverso le prop, si potrebbe voler inserire sia lo State tasks che la dispatch function nel Context.
In questo modo ogni Component al di sotto di TaskApp nel tree può leggere le tasks e spedire (dispatch) delle actions senza il ripetitivo "prop drilling".

Ecco come si può combinare un Reducer con un Context:

1. **Creare** un Context

2. **Inserire** State e Dispatch dentro il Context

3. **Usare** il Context ovunque nel tree.

### 25.2. Step 1: Create the context

L'Hook useReducer restituisce le correnti tasks e la dispatch function che permette di aggiornarle:

<code>
	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
</code>

Per passarle verso il basso nel tree, si creeranno due Contexts separati:

• TasksContext fornisce la lista corrente delle tasks

• TasksDispatchContext fornisce la funzione che permette ai Components di eseguire il dispatch delle actions.

Occorre esportarle da un file separato in modo da poter importarle in seguito in altri file:

<code>

    import { createContext } from "react";

    export const TasksContext = createContext(null);
    export const TasksDispatchContext = createContext(null);

</code>

Qui si sta passando null come value di default ad entrambi i context. Le values attuali saranno fornite dal Component TaskApp.

### 25.3. Put state and dispatch into context

Ora si possono importare entrambi i contexts nel TaskApp Component. Prendere tasks e dispatch restituito da useReducer e fornirle all'intero tree sottostante:

<code>

    import { TasksContext, TasksDispatchContext } from "./TaskContext";

    export default function TaskApp() {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
    	...
    	return (
    			<TasksContext.Provider value={tasks}>
    				<TasksDispatchContext.Provider>
    					<h1>Day off in Kyoto</h1>
    					<AddTask onAddTask={handleAddTask} />
    					<TaskList
    						tasks={tasks}
    						onChangeTask={handleChangeTask}
    						onDeleteTask={handleDeleteTask}
    					/>
    				</TasksDispatchContext.Provider>
    			</TasksContext.Provider>
    		);
    }

</code>

Per ora, si passano le informazioni sia attraverso le props che nel context.

Nel prossimo step, rimuoveremo il passaggio dalle props.

### 25.4. Step 3: Use context anywhere in the tree

Ora non vi é più bisogno di passare la lista o gli Event Handlers verso il basso nel tree:

<code>

    return (
    		<TasksContext.Provider value={tasks}>
    			<TasksDispatchContext.Provider>
    				<h1>Day off in Kyoto</h1>
    				<AddTask />
    				<TaskList />
    			</TasksDispatchContext.Provider>
    		</TasksContext.Provider>
    	);
    }

</code>

Invece ogni Component che necessita della task list può leggerla da TaskContext:

<code>

    import React, { useState, useContext } from "react";
    import { TasksContext } from "./TaskContext";

    export default function TaskList() {
    	const tasks = useContext(TasksContext);
    	return (
    		<ul>
    			{tasks.map((task) => (
    				<li key={task.id}>
    					<Task task={task} onChange={onChangeTask} onDelete={onDeleteTask} />
    				</li>
    			))}
    		</ul>
    	);
    }

</code>

Per aggiornare la task list, ogni Component può leggere la function dispatch da context e chiamarla:

<code>

    export default function AddTask() {
    	const [text, setText] = useState("");
    	const dispatch = useContext(TasksDispatchContext);
    	return (
    		<>
    			<input
    				placeholder="Add task"
    				value={text}
    				onChange={(event) => setText(event.target.value)}
    			/>
    			<button
    				onClick={() => {
    					setText("");
    					dispatch({
    						type: "added",
    						id: nextId++,
    						text: text
    					});
    				}}
    			>
    				Add
    			</button>
    		</>
    	);
    }

</code>

Il TaskApp Component (TaskManager) non passa nessun Event Handler verso il basso, e neanche la TaskList non passa nessun Event Handler al Task Component. Ogni Component legge il context che necessita:

<code>

App.js

    import { useReducer } from "react";
    import AddTask from "./AddTaskReducerContext";
    import TaskList from "./TaskListReducerContext";
    import { TasksContext, TasksDispatchContext } from "./TaskContext";

    export default function TaskApp() {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	return (
    		<TasksContext.Provider value={tasks}>
    			<TasksDispatchContext.Provider value={dispatch}>
    				<h1>Day off in Kyoto</h1>
    				<AddTask />
    				<TaskList />
    			</TasksDispatchContext.Provider>
    		</TasksContext.Provider>
    	);
    }

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    const initialTasks = [
    	{ id: 0, text: "Philosopher’s Path", done: true },
    	{ id: 1, text: "Visit the temple", done: false },
    	{ id: 2, text: "Drink matcha", done: false }
    ];

TasksContext.js

    import { createContext } from "react";

    export const TasksContext = createContext(null);
    export const TasksDispatchContext = createContext(null);

AddTask.js

    import React, { useState, useContext } from "react";
    import { TasksDispatchContext } from "./TaskContext";

    export default function AddTask() {
    	const [text, setText] = useState("");
    	const dispatch = useContext(TasksDispatchContext);
    	return (
    		<>
    			<input
    				placeholder="Add task"
    				value={text}
    				onChange={(event) => setText(event.target.value)}
    			/>
    			<button
    				onClick={() => {
    					setText("");
    					// onAddTask(text);
    					dispatch({
    						type: "added",
    						id: nextId++,
    						text: text
    					});
    				}}
    			>
    				Add
    			</button>
    		</>
    	);
    }

    let nextId = 3;

TaskList.js

    import React, { useState, useContext } from "react";
    import { TasksContext, TasksDispatchContext } from "./TaskContext";

    export default function TaskList() {
    	const tasks = useContext(TasksContext);
    	return (
    		<ul>
    			{tasks.map((task) => (
    				<li key={task.id}>
    					<Task task={task} />
    				</li>
    			))}
    		</ul>
    	);
    }

    function Task({ task }) {
    	const [isEditing, setIsEditing] = useState(false);
    	const dispatch = useContext(TasksDispatchContext);
    	let taskContent;
    	if (isEditing) {
    		taskContent = (
    			<>
    				<input
    					value={task.text}
    					onChange={(event) => {
    						dispatch({
    							type: "changed",
    							task: {
    								...task,
    								text: event.target.value
    							}
    						});
    					}}
    				/>
    				<button onClick={() => setIsEditing(false)}>Save</button>
    			</>
    		);
    	} else {
    		taskContent = (
    			<>
    				{task.text}
    				<button onClick={() => setIsEditing(true)}>Edit</button>
    			</>
    		);
    	}

    	return (
    		<label>
    			<input
    				type="checkbox"
    				checked={task.done}
    				onChange={(event) => {
    					dispatch({
    						type: "changed",
    						task: {
    							...task,
    							done: event.target.checked
    						}
    					});
    				}}
    			/>
    			{taskContent}
    			<button
    				onClick={() => {
    					dispatch({
    						type: "deleted",
    						id: task.id
    					});
    				}}
    			>
    				Delete
    			</button>
    		</label>
    	);
    }

</code>

Lo State "vive" ancora nel top level del Component TaskApp, gestito con useReducer. Ma le sue tasks e la funzione dispatch sono ora disponibili per ogni Component sottostante nel tree importando ed usando questi contexts.

### 25.5. Moving all wiring into a single file

Non occorre farlo, ma si potrebbero declassare ulteriormente i Components muovendo sia il Reducer che il Context in un singolo file. Correntemente, TasksContext.js contiene solo due dichiarazioni context:

<code>

    import { createContext } from "react";

    export const TasksContext = createContext(null);
    export const TasksDispatchContext = createContext(null);

</code>

Questo file sta per essere affollato. Verrà mosso il Reducer nello stesso file. Poi si dichiarerà un nuovo Component TasksProvider nello stesso file. Questo Component legherà tutti i pezzi assieme:

1. Gestirà lo State con un Reducer.
2. Fornirà entrambi i Contexts al Component sottostante.
3. Prenderà children come prop in modo che si possa passare del JSX a questo.

<code>

In TaskContext.jsx

    import { createContext, useReducer } from "react";

    export const TasksContext = createContext(null);
    export const TasksDispatchContext = createContext(null);

    export function TaskProvider({ children }) {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	return (
    		<TasksContext.Provider value={tasks}>
    			<TasksDispatchContext.Provider value={dispatch}>
    				{children}
    			</TasksDispatchContext.Provider>
    		</TasksContext.Provider>
    	);
    }

</code>

Questo rimuove tutta la complessità ed il cablaggio dal Component TaskApp (in TaskManager):

<code>
In TaskManager.jsx

    import AddTask from "./AddTaskReducerContext";
    import TaskList from "./TaskListReducerContext";
    import { TaskProvider } from "./TaskContext";

    export default function TaskApp() {
    	return (
    		<TaskProvider>
    			<h1>Day off in Kyoto</h1>
    			<AddTask />
    			<TaskList />
    		</TaskProvider>
    	);
    }

In TasksContext.jsx

    import { createContext, useReducer } from "react";

    export const TasksContext = createContext(null);
    export const TasksDispatchContext = createContext(null);

    export function TaskProvider({ children }) {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	return (
    		<TasksContext.Provider value={tasks}>
    			<TasksDispatchContext.Provider value={dispatch}>
    				{children}
    			</TasksDispatchContext.Provider>
    		</TasksContext.Provider>
    	);
    }

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    const initialTasks = [
    	{ id: 0, text: "Philosopher’s Path", done: true },
    	{ id: 1, text: "Visit the temple", done: false },
    	{ id: 2, text: "Drink matcha", done: false }
    ];

</code>

Si può inoltre esportare le funzioni che usano il Context da TasksContext.jsx:

<code>

    export function useTasks() {
    	return useContext(TasksContext);
    }

    export function useTasksDispatch() {
    	return useContext(TasksDispatchContext);
    }

</code>

Quando un Component necessiterà di leggere il Context, potrà farlo attraverso queste funzioni:

<code>

    	const tasks = useTasks();

    	const dispatch = useTasksDispatch();

</code>

Questo non cambierà il comportamento in qualsiasi modo, ma permetterà di dividere ulteriormente questi Contexts e aggiungere della logica a queste funzioni.
Ora tutti i Context ed i Reducer sono cablati in
TasksContext.jsx.
Questo mantiene i Components puliti e ordinati, concentrati su cosa mostreranno piuttosto che da dove ottengono i dati:

<code>

In TasksContext.jsx:

    import { createContext, useReducer } from "react";

    export const TasksContext = createContext(null);
    export const TasksDispatchContext = createContext(null);

    export function TaskProvider({ children }) {
    	const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

    	return (
    		<TasksContext.Provider value={tasks}>
    			<TasksDispatchContext.Provider value={dispatch}>
    				{children}
    			</TasksDispatchContext.Provider>
    		</TasksContext.Provider>
    	);
    }

    export function useTasks() {
    	return useContext(TasksContext);
    }

    export function useTasksDispatch() {
    	return useContext(TasksDispatchContext);
    }

    function tasksReducer(tasks, action) {
    	switch (action.type) {
    		case "added": {
    			return [
    				...tasks,
    				{
    					id: action.id,
    					text: action.text,
    					done: false
    				}
    			];
    		}
    		case "changed": {
    			return tasks.map((t) => {
    				if (t.id === action.task.id) {
    					return action.task;
    				} else {
    					return t;
    				}
    			});
    		}
    		case "deleted": {
    			return tasks.filter((t) => t.id !== action.id);
    		}
    		default: {
    			throw Error("Unknown action: " + action.type);
    		}
    	}
    }

    const initialTasks = [
    	{ id: 0, text: "Philosopher’s Path", done: true },
    	{ id: 1, text: "Visit the temple", done: false },
    	{ id: 2, text: "Drink matcha", done: false }
    ];

In TasksList.jsx

    import React, { useState, useContext } from "react";
    import { useTasks, useTasksDispatch } from "./TaskContext";

    export default function TaskList() {
    	const tasks = useTasks();
    	return (
    		<ul>
    			{tasks.map((task) => (
    				<li key={task.id}>
    					<Task task={task} />
    				</li>
    			))}
    		</ul>
    	);
    }

    function Task({ task }) {
    	const [isEditing, setIsEditing] = useState(false);
    	const dispatch = useTasksDispatch();
    	let taskContent;
    	if (isEditing) {
    		taskContent = (
    			<>
    				<input
    					value={task.text}
    					onChange={(event) => {
    						dispatch({
    							type: "changed",
    							task: {
    								...task,
    								text: event.target.value
    							}
    						});
    					}}
    				/>
    				<button onClick={() => setIsEditing(false)}>Save</button>
    			</>
    		);
    	} else {
    		taskContent = (
    			<>
    				{task.text}
    				<button onClick={() => setIsEditing(true)}>Edit</button>
    			</>
    		);
    	}

    	return (
    		<label>
    			<input
    				type="checkbox"
    				checked={task.done}
    				onChange={(event) => {
    					dispatch({
    						type: "changed",
    						task: {
    							...task,
    							done: event.target.checked
    						}
    					});
    				}}
    			/>
    			{taskContent}
    			<button
    				onClick={() => {
    					dispatch({
    						type: "deleted",
    						id: task.id
    					});
    				}}
    			>
    				Delete
    			</button>
    		</label>
    	);
    }

</code>

Si può pensare al TasksProvider come una parte dello schermo che sa come gestire le tasks, con useTasks come un modo di leggerle e con useTasksDispatch come un modo per aggiornarle da ogni Component sottostante nel tree.

Nota:
Le funzioni come useTasks e useTasksDispatch vengono chiamato Custom Hooks. La funzione viene considerata un Custom Hook se il suo nome inizia con use. Questo permette di usare gli altri Hooks, come useContext, dentro ad esso.

Mano a mano che l'App crescerà, si potrebbero avere varie coppie context-reducer come questo. Questo é un modo potente per scalare un'App e sollevare lo State in alto senza un eccessivo lavoro se si vuole accedere ai dati più in profondità nel tree.

## 26. Escape Hatches

Alcuni Components potrebbero necessitare di controllare e sincronizzarsi con sistemi al di fuori di React.
Per esempio, si potrebbe necessitare di mettere il focus su un input usando la browser API, o connettere e stare in ascolto per dei message da un server remoto. In questo capitolo, si impareranno le vie di fuga (Escape Hatches) che permetteranno di "uscire fuori" da React.js e connettersi con sistemi esterni. Molte delle logiche di un'App e il suo data flow non si relazionano con queste features.

### 26.1. Referecing values with refs

### 26.2. Manipulating the DOM with refs

### 26.3. Synchronizing with Effects

### 26.4. You Might Not Need An Effect

### 26.5. Lifecycle of reactive effects

### 26.6. Separating events from Effects

### 26.7. Removing Effect dependencies

### 26.8. Reusing logic with custom Hooks

## 27. Referencing values with Refs

Quando si vuole che un Component "ricordi" delle informazioni, ma non si vuole che quelle informazioni avviino dei nuovi render, si può usare un "ref".

### 27.1. Adding a ref to your component

Si può aggiungere un ref ad un Component importando l'Hook useRef da React:

<code>
	import { useRef } from "react";
</code>

Dentro al Component, si chiami l'Hook useRef e si passi l'initial Value alla quale si vuole far riferimento come singolo argument. Per esempio, qui un ref alla value 0:

<code>
  const ref = useRef(0);
</code>

useRef restituisce un object con una property current con value corrispondente all'argument passato:

<code>
{
	current: 0
}
</code>

Si può accedere alla current value di tale ref attraverso la property ref.current. Questa value é intenzionalmente mutabile, ciò significa che si può sia leggere che scrivere. E' come una tasca segreta del Component che React non traccia. Questo é ciò che lo rende una "via di fuga" dal data flow unidirezzionale di React.

Qui un button incrementa ref.current ad ogni click:

<code>
	import { useRef } from "react";

    export default function Counter() {
    	let ref = useRef(0);

    	function handleClick() {
    		ref.current = ref.current + 1;
    		console.log("You clicked " + ref.current + " times");
    	}

    	return <button onClick={handleClick}>Click Me!</button>;
    }

</code>

Il ref punta ad un numero, ma, come lo State, può essere qualunque cosa: una string, un object o persino una funzione. A differenza dello State, ref é un plain JavaScript Object con la property current che si può leggere e modificare.

Si noti che il Component non effettua il re-render ad ogni incremento. Come lo State, anche le refs sono trattenute da React tra i re-render. Comunque, impostare lo State avvia il re-render di un Component, mentre modificare una ref non lo fa.

### 27.2. Example: building a stopwatch

Si possono combianare ref e State in un singolo Component. Per esempio, creiamo un cronometro che lo user può avviare o fermare premendo un button. Per fare in modo di visualizzare quanto tempo é passato da quando l'utente ha premuto Start, occorrerà tenere traccia di quando il button Start é stato premuto e qual'é l'ora corrente. Queste informazioni vengono usate per il rendering, quindi ne terremo traccia nello State:

<code>
	const [startTime, setStartTime] = useState(null);
	const [now, setNow] = useState(null);
</code>

Quando l'utente preme "Start", si userà setInterval per far in modo di aggiornare il tempo ogni 10 millisecondi:

<code>

    export default function StopWatch() {
    	const [startTime, setStartTime] = useState(null);
    	const [now, setNow] = useState(null);

    	function handleStart() {
    		// Comincia a contare
    		setStartTime(Date.now());
    		setNow(Date.now());
    		// Aggiorna l'ora corrente ogni 10ms.
    		setInterval(() => {
    			setNow(Date.now());
    		}, 10);
    	}

    	let secondPassed = 0;
    	if (startTime != null && now != null) {
    		secondPassed = (now - startTime) / 1000;
    	}

    	return (
    		<>
    			<h2>Time passed: {secondPassed.toFixed(3)}</h2>
    			<button onClick={handleStart}>Start</button>
    		</>
    	);
    }

</code>

Quando verrà premuto il button "Stop", si necessiterà di cancellare l'interval esistente così che si fermerà l'aggionamento della State variable "now". Si può farlo chiamando clearInterval, ma occorrerà fornire l'interval ID che é stato precedentemente restituito dalla chiamata a setInterval quando l'utente preme Start. Si avrà bisogno do tenere traccia dell'ID dell'interval da qualche parte. Visto che l'ID dell'interval non viene usato per il rendering, vi si può tenere traccia in un ref:

<code>

    export default function StopWatch() {
    	const [startTime, setStartTime] = useState(null);
    	const [now, setNow] = useState(null);
    	const intervalRef = useRef(null);

    	function handleStart() {
    		setStartTime(Date.now());
    		setNow(Date.now());

    		clearInterval(intervalRef.current);
    		intervalRef.current = setInterval(() => {
    			setNow(Date.now());
    		}, 10);
    	}

    	function handleStop() {
    		clearInterval(intervalRef.current);
    	}

    	let secondPassed = 0;
    	if (startTime != null && now != null) {
    		secondPassed = (now - startTime) / 1000;
    	}

    	return (
    		<>
    			<h2>Time passed: {secondPassed.toFixed(3)}</h2>
    			<button onClick={handleStart}>Start</button>
    			<hr />
    			<button onClick={handleStop}>Stop</button>
    		</>
    	);
    }

</code>

Quando un pezzo di informazione viene usato per il rendering, viene mantenuto nello State. Quando un pezzo di informazione é necessario solo dagli Event Handlers e lo cambiano e non si necessita un re-render, usare un ref potrebbe essere più efficente.

### 27.3. Differences between refs e state

Forse si sta pensando che le ref siano meno "strict" dello State, si possono mutare invece di dover sempre usare una setting function dello State, per esempio. Ma in molti casi, si vorrà usare proprio lo State. Le ref sono una "via di fuga" che non si userà spesso. Ecco come lo State e le Ref si possono comparare:

<code>

Ref --> useRef(InitialValue) restituisce {current: initialValue}

State --> useState(initialValue) restituisce la current value della State variable e una State setter function
([value, setValue])

Ref --> Non attiva un re-render quando lo si cambia

State --> Attiva un re-render quando lo si cambia

Ref --> Mutabile - si può modificare e aggiornare la value di current fuori dal processo di rendering

State --> Immutabile - occorre usare la State setter function per modificare le State Variables mettendo in coda un re-render.

Ref --> Non si dovrebbe leggere o scrivere la value di current durante il rendering

State --> Si può leggere lo State quando si vuole. Comunque ogni render ha la propria istantanea dello State che non cambia.

</code>

Ecco un counter button che viene implementato con lo State:

<code>

    import { useState } from "react";

    export default function Counter() {
    	const [count, setCount] = useState(0);

    	function handleClick() {
    		setCount(count + 1);
    	}

    	return <button onClick={handleClick}>You Clicked {count} Times</button>;
    }

</code>

Visto che la value di count viene visualizzata, ha senso usare una State variable per questo. Quando la value di counter viene impostata con setCount(), React re-renderizza il Component e lo screen si aggiorna per riflettere il nuovo count.

Se si prova ad implementare questo con un Ref, React non re-renderizzerà mai il Component, quindi non si vedrà mai il count cambiare. Clickando quindi il button non aggiornerà mai il suo text.

Ecco perché quando si legge ref.current durante il render, questo porta a codice inaffidabile. Se si ha bisogno di tale codice, si usi lo State al suo posto.

### 27.4. How does useRef work inside?

Sebbene sia useState che useRef siano forniti da React, in principio useRef poteva essere implementato sul top di useState. Si può immaginarlo all'interno di React implementato così:

<code>
Dentro a React:

    function useRef(initialValue){
    	const [ref, unused] = useState({current: initialValue});
    	return ref;
    }

</code>

Durante il primo render, useRef restituiva {current: initialValue}. Quest'object viene archiviato da React, quindi durante il successivo render lo stesso object verrà restituito. Si noti la setter function dello State non sia usata in quest'esempio: non é necessaria perché useRef ha bisogno di restituire sempre lo stesso object.

React fornisce una versione integrata di useRef perché é una pratica abbastanza comune. Ma la si può pensare come ad una regolare State variable senza un setter. Se si ha famigliarità con l'object oriented programming, le Ref possono ricordare le instance fields, ma invece this.something si scrive
somethingRef.current.

### 27.5. When to use refs

Tipicamente, si userà una Ref quando il Component avrà bisogno di fare un "passo fuori" da React e comunicare con un'API esterna, spesso una browser API che non impatta sulla visualizzazione (apparence) del Component. Ecco alcuni di queste rare situazioni:

• Archiviare ID dei timeout
• Archiviare e manipolare DOM elements, coperti nella prossima pagina
• Archiviare altri objects che non sono necessari per calcolare il JSX.

Se il Component necessita di archiviare delle value, ma che non impattano nella logica di render, si scelgano le Ref.

### 27.6. Best practice for refs

Seguendo questi principi si renderanno i Components più predittivi / prevedibili:

• **Trattare le Ref come una via di fuga**. Le Ref sono utili quando si lavora con sistemi esterni o le API del browser. Se troppa della logica dell'App e del data flow si basa sulle Ref, probabilemente occorre ripensare all'approccio seguito.

• **Non leggere o scrivere ref.current durante il rendering**. Se delle informazioni sono necessarie durante il rendering, meglio usare lo State. Visto che React non sa quando ref.current cambia, persino leggerlo durante il rendering renderebbe il comportamento del Component difficile da prevedere. L'unica eccezione a questo é del codice come if(!ref.current) ref.current = new Thing() che imposta solamente la Ref durante il primo render.

Le limitazioni dello State di React non di applicano alle Ref. Per esempio, lo State si comporta come un'istantanea per ogni render e non si aggiorna in modo sincrono. Ma quando si muta la current value di un Ref, cambia immediatamente:

<code>

    ref.current = 5;
    console.log(ref.current); //5

</code>

Questo perché la Ref stessa é un object JavaScript regolare, quindi si comporta come tale.

Non ci si deve preoccupare inoltre dell'evitare mutazioni quando si lavora con una Ref. Visto che l'object che si sta mutando non viene usato per il rendering, React non si occuperà di ciò che si sta facendo con la Ref o i suoi contents.

### 27.6. Refs and the DOM

Si può puntare una Ref ad ogni value. Comunque, il caso d'uso più comune per una Ref é accedere ad un DOM element. Per esempio, é maneggevole se si vuole attivare il focus su un input in modo programmatico. Quando si passa una Ref ad un attributo ref nel JSX, come <div ref={myRef}></div>, React inserirà il corrispondente DOM element dentro a myRef.current.
Vedi specifiche nel prossimo capitolo.

### 27.7. Exercises

1-

<code>

    import { useState, useRef } from 'react';

    export default function Chat() {
    	const [text, setText] = useState('');
    	const [isSending, setIsSending] = useState(false);
    	let timeoutID = useRef(null);

    	function handleSend() {
    		setIsSending(true);
    		timeoutID.current = setTimeout(() => {
    			alert('Sent!');
    			setIsSending(false);
    		}, 3000);
    	}

    	function handleUndo() {
    		setIsSending(false);
    		clearTimeout(timeoutID.current);
    	}

    	return (
    		<>
    			<input
    				disabled={isSending}
    				value={text}
    				onChange={e => setText(e.target.value)}
    			/>
    			<button
    				disabled={isSending}
    				onClick={handleSend}>
    				{isSending ? 'Sending...' : 'Send'}
    			</button>
    			{isSending &&
    				<button onClick={handleUndo}>
    					Undo
    				</button>
    			}
    		</>
    	);
    }

</code>

Perfetto :white_check_mark:

2-

Serve lo State, necessaria la value nel render. Con una Ref al cambio della value non avviene il re-render del Component.

<code>

    import { useState, useRef } from 'react';

    export default function Toggle() {
    	const [isOn, setIsOn] = useState(false);

    	return (
    		<button onClick={() => {
    			setIsOn(prevValue => !prevValue);
    		}}>
    			{isOn ? 'On' : 'Off'}
    		</button>
    	);
    }

</code>

Perfetto :white_check_mark:
Migliore del tutorial. Nella setter function sempre consigliato di usare la prevValue nella funzione.

3-

La variabile esterna timeoutId viene resettata per ogni Component al Click.
Usare una Ref per archiviare il timeoutID all'interno della dichiarazione del Component, così ne verrà creata una per ogni Component.

<code>

    import {useRef} from "react";

    function DebouncedButton({ onClick, children }) {
    let timeoutID = useRef(null);
    	return (
    		<button onClick={() => {
    			clearTimeout(timeoutID.current);
    			timeoutID.current = setTimeout(() => {
    				onClick();
    			}, 1000);
    		}}>
    			{children}
    		</button>
    	);
    }

    export default function Dashboard() {
    	return (
    		<>
    			<DebouncedButton
    				onClick={() => alert('Spaceship launched!')}
    			>
    				Launch the spaceship
    			</DebouncedButton>
    			<DebouncedButton
    				onClick={() => alert('Soup boiled!')}
    			>
    				Boil the soup
    			</DebouncedButton>
    			<DebouncedButton
    				onClick={() => alert('Lullaby sung!')}
    			>
    				Sing a lullaby
    			</DebouncedButton>
    		</>
    	)
    }

</code>

Quasi Perfetto :white_check_mark:
Dimenticato di cambiare nel clearTimeout il timeoutID in timeoutID.current. Il resto perfetto.

4-

Prima soluzione - andare a visualizzare la value dell'input usando la browser API:

<code>

    import { useState, useRef } from 'react';

    export default function Chat() {
    	const [text, setText] = useState('');

    	function handleSend() {

    		setTimeout(() => {
    			alert('Sending: ' + document.querySelector('input').value);
    		}, 3000);
    	}

    	return (
    		<>
    			<input
    				value={text}
    				onChange={e => setText(e.target.value)}
    			/>
    			<button
    				onClick={handleSend}>
    				Send
    			</button>
    		</>
    	);
    }

</code>

Seconda soluzione - salvare l'Element HTML sulla Ref e poi visualizzare elem.current.value nell'alert.

<code>

    import { useState, useRef } from 'react';

    export default function Chat() {
    	const [text, setText] = useState('');
    	let inputElem = useRef(null)

    	function handleSend() {
    		inputElem.current = document.querySelector('input');

    		setTimeout(() => {
    			alert('Sending: ' + inputElem.current.value);
    		}, 3000);
    	}

    	return (
    		<>
    			<input
    				value={text}
    				onChange={e => setText(e.target.value)}
    			/>
    			<button
    				onClick={handleSend}>
    				Send
    			</button>
    		</>
    	);
    }

</code>

ERRATO - Soluzione: agire sull'Event Handler onChange

<code>

    import { useState, useRef } from 'react';

    export default function Chat() {
    	const [text, setText] = useState('');
    	const textRef = useRef(text);

    	function handleChange(event){
    		setText(event.target.value);
    		textRef.current = event.target.value;
    	}

    	function handleSend() {
    		setTimeout(() => {
    			alert('Sending: ' + textRef.current);
    		}, 3000);
    	}

    	return (
    		<>
    			<input
    				value={text}
    				onChange={handleChange}
    			/>
    			<button
    				onClick={handleSend}>
    				Send
    			</button>
    		</>
    	);
    }

</code>

## 28. Manipulating the DOM with Refs

React aggiorna automaticamente il DOM per far corrispondere l'output del render, in modo che i Components non abbiano bisogno di manipolarlo. Comunque, a volte si potrebbe aver bisogno di accedere ai DOM elements gestendo da React, per esempio per attivare il focus su un node, scrollarlo o misurare la sua size o position. Non vi sono modi integrati per fare queste cose in React, perciò avremo bisogno di una Ref ad un DOM node.

### 28.1. Getting a ref to the node

Per accedere ad un DOM node gestendo da React, per prima cosa importiamo l'Hook useRef:

<code>
	import {useRef} from "react";
</code>

Poi, lo si usi per dichiarare un Ref dentro al Component:

<code>
	const myRef = useRef(null);
</code>

Infine, passare la Ref come atttribute "ref" al tag JSX per il quale si vuole ottenere il DOM node:

<code>
	<div ref={myRef}></div>
</code>

L'Hook useRef restituisce un object con una singola property chiamata current. Inizialmente myRef.current sarà null. Quando React creerà un DOM node per questo div, inserirà una reference a questo node in myRef.current. Si potrà poi accedere a questo DOM node da un Event Handler e usando la browser API integrata definita in questo.

Si potrà usare ogni browser API, come per esempio:

<code>
	myRef.current.scrollIntoView();
</code>

### 28.2. Example: Focusing a text input

In questo esempio, clickando sul button si focalizzerà (focus) l'input:

<code>

    import { useRef } from "react";

    export default function Form() {
    	const inputRef = useRef(null);

    	function handleClick() {
    		inputRef.current.focus();
    	}

    	return (
    		<>
    			<input ref={inputRef} />
    			<button onClick={handleClick}>
    				Focus the input
    			</button>
    		</>
    	)
    }

</code>

Per implementare questo:

1. Dichiarare inputRef con l'Hook useRef.

2. Passarlo come <input ref={unputRef}/>. Questo dice a React di inserire il suo DOM node input in inputRef.current.

3. Nella funzione handleClick, leggere l'input DOM node da inputRef.current e chiamare il metodo focus() su di esso con inputRef.current.focus().

4. Passare l'Event Handler handleClick al button con un onClick.

Mentre la manipolazione del DOM é l'uso più comune per le Ref, l'Hook useRef può essere usato per archiviare altre cose esterne a React, come gli ID dei timer.
Similarmente allo State, le Ref rimangono tra i render. Le Ref sono come State variables che non attivano un re-render quando le si imposta. Vedi capitolo precedente per ulteriori dettagli sulle Ref.

### 28.3. Example: Scrolling to an element

Si può avere più di una singola Ref in un Component. In questo esempio, vi é un carousel con tre immagini. Ogni button centra un'immagine chiamando il metodo del browser ScrollIntoView del corrispondente DOM node:

<code>

    import React, { useRef } from "react";

    export default function CatFriends() {
    	const firstCatRef = useRef(null);
    	const secondCatRef = useRef(null);
    	const thirdCatRef = useRef(null);

    	function handleScrollToFirstCat() {
    		firstCatRef.current.scrollIntoView({
    			behaviour: "smooth",
    			block: "nearest",
    			inline: "center"
    		});
    	}

    	function handleScrollToSecondCat() {
    		secondCatRef.current.scrollIntoView({
    			behaviour: "smooth",
    			block: "nearest",
    			inline: "center"
    		});
    	}

    	function handleScrollToThirdCat() {
    		thirdCatRef.current.scrollIntoView({
    			behaviour: "smooth",
    			block: "nearest",
    			inline: "center"
    		});
    	}

    	return (
    		<>
    			<nav>
    				<button onClick={handleScrollToFirstCat}>Tom</button>
    				<hr />
    				<button onClick={handleScrollToSecondCat}>Maru</button>
    				<hr />
    				<button onClick={handleScrollToThirdCat}>Jellylorum</button>
    			</nav>
    			<div>
    				<ul>
    					<li>
    						<img
    							src="https://placekitten.com/g/200/200"
    							alt="Tom"
    							ref={firstCatRef}
    						/>
    					</li>
    					<li>
    						<img
    							src="https://placekitten.com/g/300/200"
    							alt="Maru"
    							ref={secondCatRef}
    						/>
    					</li>
    					<li>
    						<img
    							src="https://placekitten.com/g/250/200"
    							alt="Jellylorum"
    							ref={thirdCatRef}
    						/>
    					</li>
    				</ul>
    			</div>
    		</>
    	);
    }

</code>

### 28.4. How to manage a list of refs using a ref callback

Negli esempi sopra riportati, vi sono un numero predefinito di Ref. Alle volte comunque si potrebbe aver bisogno di una Ref per ogni item dei una list, e si potrebbe non sapere quanti ne potremmo avere. Un mapping come questo non funzionerà:

<code>

    <ul>
    	{items.map((item) => {
    		// Non funziona!
    		const ref = useRef(null);
    		return <li ref={ref} />;
    	})}
    </ul>

</code>

Questo perché gli Hooks devono essere chiamati nel top-level di un Component. Non si può chiamare useRef in un loop, una condition, o dentro una chiamata a map per esempio.

Una possibilità di aggirare la cosa é passare una funzione all'attribute ref. Questa viene chiamata Ref callback. React chiamerà le Ref callback con il DOM node quando sarà il momento di impostare la Ref, e poi con null quando sarà il momento di pulire. Questo permetterà di gestire un proprio Array o un Map, e accedere ad ogni Ref attraverso il suo index o altro tipo di ID.

Questo esempio mostra come si può usare quest'approccio per scorrere ad un node arbitrario in una lunga lista:

<code>

    import React, { useRef } from "react";

    export default function CatFriends() {
    	const itemsRef = useRef(null);

    	function scrollToId(itemId) {
    		const map = getMap();
    		const node = map.get(itemId);
    		node.scrollIntoView({
    			behavior: "smooth",
    			block: "nearest",
    			inline: "center"
    		});
    	}

    	function getMap() {
    		if (itemsRef.current) {
    			// Inizializza il Map al primo uso
    			itemsRef.current = new Map();
    		}
    		return itemsRef.current;
    	}

    	return (
    		<>
    			<nav>
    				<button onClick={() => scrollToId(0)}>Tom</button>
    				<button onClick={() => scrollToId(5)}>Maru</button>
    				<button onClick={() => scrollToId(9)}>Jellylorum</button>
    			</nav>
    			<div>
    				<ul>
    					{catList.map((cat) => (
    						<li
    							key={cat.id}
    							ref={(node) => {
    								const map = getMap();
    								if (node) {
    									map.set(cat.id, node);
    								} else {
    									map.delete(cat.id);
    								}
    							}}
    						>
    							<img src={cat.imageUrl} alt={"Cat #" + cat.id} />
    						</li>
    					))}
    				</ul>
    			</div>
    		</>
    	);
    }

    const catList = [];
    for (let i = 0; i < 10; i++) {
    	catList.push({
    		id: i,
    		imageUrl: "https://placekitten.com/250/200?image=" + i
    	});
    }

</code>

In quest'esempio, itemsRef non ospita un singolo DOM node. Invece, ospita un Map da un Item ID ad un DOM node, visto che le Ref possono ospitare qualunque value.
La Ref callback su ogni item si prende cura dell'aggiornamento del Map:

<code>

    					<li
    						key={cat.id}
    						ref={(node) => {
    							const map = getMap();
    							if (node) {
    								map.set(cat.id, node);
    							} else {
    								map.delete(cat.id);
    							}
    						}}
    					>

</code>

Questo permette successivamente di leggere i DOM nodes individualmente dal Map.

### 28.5. Accessing another component's DOM nodes

Quando si inserisce una Ref in un Component integrato che da come output un browser element come un input, React imposterà la property current della Ref al corrispondente DOM node, l'attuale input nel browser.

Comunque, se si prova ad inserire una Ref nel proprio Component, come <MyInput />, di default si otterrà null. Ecco un esempio che lo dimostra. Si noti come clickando il button non avviene il focus sull'input:

<code>

    import React, { useRef } from "react";

    function MyInput(props) {
    	return <input {...props} />;
    }

    export default function MyForm() {
    	const inputRef = useRef(null);

    	function handleClick() {
    		inputRef.current.focus();
    	}

    	return (
    		<>
    			<MyInput ref={inputRef} />
    			<button onClick={handleClick}>Focus the input</button>
    		</>
    	);
    }

</code>

React a questo punto darà un Error. Questo avviene perché di default React non permette ad un Component di accedere ai DOM nodes di altri Components. Nemmeno se sono dei children dello stesso. Questo é intenzionale. Le Ref sono una via di fuga che dovrebbe essere usata con parsimonia. Manipolare manualmente un DOM node di un altro Component rende il codice ancora più fragile.

Invece, i Components che vogliono esporre i loro DOM nodes hanno un "opt" per tale comportamento. Un Component può specificare che "manda avanti / inoltra" la sua Ref ad uno dei suoi children. Ecco come MyInput può usare la forwardRef API:

<code>

    const MyInput = forwardRef((props, ref) => {
    	return <input {...props} ref={ref} />;
    });

</code>

Così é come funziona:

1. <MyInput ref={inputRef} /> dice a React di inserire il corrispondente DOM node in input.current. Comunque, dipende dal Component MyInput di optare in quello, di default non lo fa.

2. Il Component MyInput viene dichiarato usando forwardRef. Questo sceglie di ricevere la inputRef in se stesso da sopra come secondo argument "ref" che viene dichiarato dopo props.

3. Il Component MyInput stesso passa la ref che ha ricevuto all'input al suo interno.

Ora clickando il button per attivare il focus sull'input funziona:

<code>

    import React, { forwardRef, useRef } from "react";

    const MyInput = forwardRef((props, ref) => {
    	return <input {...props} ref={ref} />;
    });

    export default function MyForm() {
    	const inputRef = useRef(null);

    	function handleClick() {
    		inputRef.current.focus();
    	}

    	return (
    		<>
    			<MyInput ref={inputRef} />
    			<button onClick={handleClick}>Focus the input</button>
    		</>
    	);
    }

</code>

Nei design systems, é un pattern comune per i Components di basso livello come i buttons, gli input e così via, per far passare avanti le loro ref ai loro DOM nodes. D'altro canto, i Components di alto livello come i form, le list o le section delle page di solito non espongono i loro DOM nodes per evitare dependencies accidentali nella struttura del DOM.

### 28.6. Exposing a subset of the API with an imperative handle

Nell'esempio precedente, MyInput espone l'input element originale del DOM. Questo permette al parent Component di chiamare focus su di esso. Comunque questo permette anche al parent Component di fare qualcos'altro, per esempio cambiarne lo style CSS. In casi non comuni, si potrebbe voler applicare delle restrizioni alle funzionalità esposte. Lo si può fare usando useImperativeHandle:

<code>

    import React, { forwardRef, useRef, useImperativeHandle } from "react";

    const MyInput = forwardRef((props, ref) => {
    	const realInputRef = useRef(null);
    	useImperativeHandle(ref, () => ({
    		focus() {
    			realInputRef.current.focus();
    		}
    	}));
    	return <input {...props} ref={realInputRef} />;
    });

    export default function MyForm() {
    	const inputRef = useRef(null);

    	function handleClick() {
    		inputRef.current.focus();
    	}

    	return (
    		<>
    			<MyInput ref={inputRef} />
    			<button onClick={handleClick}>Focus the input</button>
    		</>
    	);
    }

</code>

Qui, realInputRef dentro MyInput ospita l'effettivo DOM node input. Comunque, useImperativeHandle istruisce React nel fornire il proprio object speciale come value della Ref al parent Component. Quindi inputRef.current dentro al MyForm avrà solamente il metodo focus. In questo caso, la Ref non "gestisce" (handle) il DOM node, ma un object custom che é stato creato dentro alla chiamata useImperativeHandle.

### 28.7. When React attaches the refs

In React, ogni aggionamento é diviso in due fasi:

• Durante il render, React chiama tutti i Components per figurarsi cosa dovrebbe essere sullo schermo.

• Durante il commit, React applica i cambiamenti al DOM.

In generale, non si vuole accedere alle Ref durante il rendering. Questo vale anche per le Ref che ospitano il DOM nodes. Durante il primo render, i DOM nodes non sono ancora stati creati, quindo ref.current sarebbe null. E durante il rendering degli aggiornamenti, i DOM nodes non sono ancora stati aggiornati. Quindi é troppo presto per leggerli.

React imposta ref.current durante il commit. Prima di aggiornare il DOM, React imposta values legate a ref.current a null. Dopo aver aggiornato il DOM, React le imposta immediatamente ai corrispondenti DOM nodes.

Di solito si accede alle Ref dagli Event Handlers. Se si vuole far qualcosa con una Ref, ma non vi é alcun particolare Event al quale assiociarlo, si potrebbe necessitare di un Effect (Side Effect), del quale parleremo nei prossimi capitoli.

### 28.8. Flushing state updates synchronously with flushSync

Si consideri questo codice, che aggiunge un nuovo ToDo e scorre la lista in basso all'ultimo child della lista. Si noti come, per qualche ragione, scorra sempre al todo che é appena prima dell'ultimo aggiunto:

<code>

    import { useState, useRef } from "react";

    export default function TodoList() {
    	const listRef = useRef(null);
    	const [text, setText] = useState("");
    	const [todos, setTodos] = useState(initialTodos);

    	function handleAdd() {
    		const newTodo = { id: nextId++, text: text };
    		setText("");
    		setTodos([...todos, newTodo]);
    		listRef.current.lastChild.scrollIntoView({
    			behavior: "smooth",
    			block: "nearest"
    		});
    	}

    	return (
    		<>
    			<button onClick={handleAdd}>Add</button>
    			<input value={text} onChange={(event) => setText(event.target.value)} />
    			<ul ref={listRef}>
    				{todos.map((todo) => (
    					<li key={todo.id}>{todo.text}</li>
    				))}
    			</ul>
    		</>
    	);
    }

    let nextId = 0;
    let initialTodos = [];
    for (let i = 0; i < 20; i++) {
    	initialTodos.push({
    		id: nextId++,
    		text: "todo #" + (i + 1)
    	});
    }

</code>

Il problema risiede in queste due linee:

<code>

    	setTodos([...todos, newTodo]);
    	listRef.current.lastChild.scrollIntoView();

</code>

In React, gli aggionamenti dello State vengono messi in coda. Di solito, questo é ciò che vogliamo. Comunque qui causa un problema, perché setTodos non aggiorna immediatamente il DOM.
Quindi nel momento che si scorre la lista all'ultimo element, la todo non é ancora stata aggiunta. Questo é il motivo che lo scrolling arriva sempre indietro di un item.

Per sistemare il problema, si può forze React ad aggiornare ("flush") il DOM in modo sincrono. Per fare questo, occorre importare flushSync dal react-dom e avvolgere lo State update in una chiamata a flushSync:

<code>

    	flushSync(() => {
    		setTodos([...todos, newTodo]);
    	});

    	listRef.current.lastChild.scrollIntoView()

</code>

Questo da istruzione a React di aggiornare il DOM in modo sincrono subito dopo che il codice avvolto in flushSync viene eseguito. Come risultato, l'ultimo todo sarà già inserito nel DOM nel momento che si prova a scorrere:

<code>

    import { useState, useRef } from "react";
    import { flushSync } from "react-dom";

    export default function TodoList() {
    	const listRef = useRef(null);
    	const [text, setText] = useState("");
    	const [todos, setTodos] = useState(initialTodos);

    	function handleAdd() {
    		const newTodo = { id: nextId++, text: text };
    		flushSync(() => {
    			setText("");
    			setTodos([...todos, newTodo]);
    		});
    		listRef.current.lastChild.scrollIntoView({
    			behavior: "smooth",
    			block: "nearest"
    		});
    	}

    	return (
    		<>
    			<button onClick={handleAdd}>Add</button>
    			<input value={text} onChange={(event) => setText(event.target.value)} />
    			<ul ref={listRef}>
    				{todos.map((todo) => (
    					<li key={todo.id}>{todo.text}</li>
    				))}
    			</ul>
    		</>
    	);
    }

    let nextId = 0;
    let initialTodos = [];
    for (let i = 0; i < 20; i++) {
    	initialTodos.push({
    		id: nextId++,
    		text: "todo #" + (i + 1)
    	});
    }

</code>

### 28.9. Best practices for DOM manipulation with refs

Le Ref sono una via di fuga. Si dovrebbero usare solamente quando si deve fare un passo fuori da React. Esempi comuni di questo comprendono gestire il focus, scorrere ad una position, o chiamare delle browser API che React non espone.

Se si resta su azioni non distruttive come il focusing o lo scrolling, non si dovrebbero incontrare problemi. Comunque, se si prova a modificare il DOM manualmente, si può rischiare di entrare in conflitto con i cambiamenti che React sta compiendo.

Per illustrare questo problema, questo esempio include i messaggio di benvenuto e due buttons. Il primo button alterna la sua presenza usando il conditional rendering e lo State, come di solito si fa in React. Il secondo button usa la DOM API remove() per rimuoverlo forzatamente dal DOM fuori dal controllo di React.

Si provi a premere "Toggle with setState" per alcune volte. Il message dovrebbe apparire e scomparire. Poi premendo "Remove from the DOM". Questo lo rimuove forzatamente. Infine, premiamo "Toggle with setState", ed é qui che incontreremo l'errore:

<code>

    import { useState, useRef } from "react";

    export default function Counter() {
    	const [show, setShow] = useState(true);
    	const ref = useRef(null);

    	return (
    		<div>
    			<button
    				onClick={() => {
    					setShow(!show);
    				}}
    			>
    				Toggle with setState
    			</button>
    			<button
    				onClick={() => {
    					ref.current.remove();
    				}}
    			>
    				Remove from the DOM
    			</button>
    			{show && <p ref={ref}>Hello World</p>}
    		</div>
    	);
    }

</code>

Dopo aver rimosso manualmente il DOM element con il button relativo alla Ref, se si userà di nuovo il button relativo allo State, si avrà un errore. Questo avviene perché é stato cambiato il DOM, e React non sa come continuare a gestirlo correttamente.

E' sempre meglio evitare di cambiare i DOM nodes gestiti da React. Modificando, aggiungendo children o rimuovendone dagli elements gestiti da React si può finire i risultati visuali inaspettati o a dei crash come nell'esempio appena mostrato.

Comunque, questo non significa che non si può fare del tutto. Richiede cautela. Si possono modificare in modo sicuro parti del DOM che React non ha alcun motivo di aggiorare. Per esempio, se qualche div é sempre vuoto nel JSX, React non ha motivo di toccare la sua lista di children. Perciò é sicuro aggiungere o rimuovere elements da li.

### 28.10. Exercises

1-

<code>

    import { useState, useRef } from 'react';

    export default function VideoPlayer() {
    	const [isPlaying, setIsPlaying] = useState(false);
    	const videoRef = useRef(null);

    	function handleClick() {
    		const nextIsPlaying = !isPlaying;
    		setIsPlaying(nextIsPlaying);
    		if(nextIsPlaying){
    			videoRef.current.play();
    		} else {
    			videoRef.current.pause();
    		}
    	}

    	return (
    		<>
    			<button onClick={handleClick}>
    				{isPlaying ? 'Pause' : 'Play'}
    			</button>
    			<video width="250" ref={videoRef} onPlay={() => {setIsPlaying(true)}} onPause={() => {setIsPlaying(false)}}>
    				<source
    					src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
    					type="video/mp4"
    				/>
    			</video>
    		</>
    	)
    }

</code>

Perfetto :white_check_mark:

2-

<code>

    import {useRef} from "react";

    export default function Page() {
    	const ref = useRef(null);

    	function handleClick(){
    		ref.current.focus();
    	}
    	return (
    		<>
    			<nav>
    				<button onClick={handleClick}>Search</button>
    			</nav>
    			<input
    				placeholder="Looking for something?" ref={ref}
    			/>
    		</>
    	);
    }

</code>

Quasi Perfetto :white_check_mark:
Di diverso il tutorial crea una funzione inline nell'Event Handler del button rispetto a quella staccata handleClick.

3-

<code>

    import { useState, useRef } from 'react';
    import { flushSync } from "react-dom";

    export default function CatFriends() {
    	const [index, setIndex] = useState(0);
    	const imageListRef = useRef(null)
    	return (
    		<>
    			<nav>
    				<button onClick={() => {
    						let node;
    						if (index < catList.length - 1) {
    									flushSync(() => {
    										setIndex(index + 1);
    									})
    									node = imageListRef.current.children[index];
    								} else {
    										setIndex(0);
    										node = imageListRef.current.children[0];

    									}
    								node.scrollIntoView({
    															behavior: 'smooth',
    															block: 'nearest',
    															inline: 'start'
    														});
    				}}>
    					Next
    				</button>
    			</nav>
    			<div>
    				<ul ref={imageListRef}>
    					{catList.map((cat, i) => (
    						<li key={cat.id}>
    							<img
    								className={
    									index === i ?
    										'active' :
    										''
    								}
    								src={cat.imageUrl}
    								alt={'Cat #' + cat.id}
    							/>
    						</li>
    					))}
    				</ul>
    			</div>
    		</>
    	);
    }

    const catList = [];
    for (let i = 0; i < 10; i++) {
    	catList.push({
    		id: i,
    		imageUrl: 'https://placekitten.com/250/200?image=' + i
    	});
    }

</code>

Funzionante ma migliore quella del tutorial: nell'element li inserisce un attribute ref con all'interno un ternary operator con condizione simile al className dell'img.

<code>

    import { useRef, useState } from 'react';
    import { flushSync } from 'react-dom';

    export default function CatFriends() {
    	const selectedRef = useRef(null);
    	const [index, setIndex] = useState(0);

    	return (
    		<>
    			<nav>
    				<button onClick={() => {
    					flushSync(() => {
    						if (index < catList.length - 1) {
    							setIndex(index + 1);
    						} else {
    							setIndex(0);
    						}
    					});
    					selectedRef.current.scrollIntoView({
    						behavior: 'smooth',
    						block: 'nearest',
    						inline: 'center'
    					});
    				}}>
    					Next
    				</button>
    			</nav>
    			<div>
    				<ul>
    					{catList.map((cat, i) => (
    						<li
    							key={cat.id}
    							ref={index === i ?
    								selectedRef :
    								null
    							}
    						>
    							<img
    								className={
    									index === i ?
    										'active'
    										: ''
    								}
    								src={cat.imageUrl}
    								alt={'Cat #' + cat.id}
    							/>
    						</li>
    					))}
    				</ul>
    			</div>
    		</>
    	);
    }

    const catList = [];
    for (let i = 0; i < 10; i++) {
    	catList.push({
    		id: i,
    		imageUrl: 'https://placekitten.com/250/200?image=' + i
    	});
    }

<code>

4-

Da completare:

<code>
SearchInput.jsx:

import {forwardRef} from 'react';

    const SearchInput = forwardRef((props, ref) => {
    	return (
    		<input
    			ref={ref}
    			placeholder="Looking for something?"
    		/>
    	);
    })

oppure:

    import {useRef, forwardRef, useImperativeHandle} from 'react';

    const SearchInput = forwardRef((props, ref) => {
    	const imperativeRef = useRef(null);
    	useImperativeHandle(ref, () => ({
    		focus(){
    			imperativeRef.current.focus();
    		}
    	}))
    	return (
    		<input
    			ref={imperativeRef}
    			placeholder="Looking for something?"
    		/>
    	);
    })

    export default SearchInput;

SearchButton.jsx

    export default function SearchButton(props) {
    	const inputRef = props.inputRef;
    	function handleClick(){
    		inputRef.current.focus();
    	}
    	return (
    		<button onClick={handleClick}>
    			Search
    		</button>
    	);
    }

oppure:

    export default function SearchButton(props) {
    	const inputRef = props.inputRef;

    	return (
    		<button onClick={() => inputRef.current.focus()}>
    			Search
    		</button>
    	);
    }

App.jsx

    import { useRef } from 'react';
    import SearchButton from './SearchButton.js';
    import SearchInput from './SearchInput.js';

    export default function Page() {
    	const inputRef = useRef(null);
    	return (
    		<>
    			<nav>
    				<SearchButton inputRef={inputRef} />
    			</nav>
    			<SearchInput ref={inputRef} />
    		</>
    	);
    }

</code>

Perfettamente funzionante, soluzione tutorial leggermente diversa:

<code>
SearchInput.jsx

    import { forwardRef } from 'react';

    export default forwardRef(
    	function SearchInput(props, ref) {
    		return (
    			<input
    				ref={ref}
    				placeholder="Looking for something?"
    			/>
    		);
    	}
    );

SearchButton.jsx

    export default function SearchButton({ onClick }) {
    	return (
    		<button onClick={onClick}>
    			Search
    		</button>
    	);
    }

App.jsx

    import { useRef } from 'react';
    import SearchButton from './SearchButton.js';
    import SearchInput from './SearchInput.js';

    export default function Page() {
    	const inputRef = useRef(null);
    	return (
    		<>
    			<nav>
    				<SearchButton onClick={() => {
    					inputRef.current.focus();
    				}} />
    			</nav>
    			<SearchInput ref={inputRef} />
    		</>
    	);
    }

</code>

## 29. Synchronizing with Effects

Alcuni Components hanno bisogno di sincronizzarsi con sistemi esterni. Per esempio, si potrebbe voler controllare un Component non-React basato sullo State di React, impostare una connessione al server, o mandare un log di un analytics quando un Component appare sullo schermo. Gli Effects permettono di eseguire del codice dopo il rendering, in modo che si possa sincronizzare il Component con dei sistemi esterni a React.

### 29.1. What are Effects and how they different from events?

Prima di cominciare con gli Effect occorre aver familiarità con due tipi di logica dentro a React Components:

• **Rendering Code** - vive nel top level del Component. Qui é dove si prendono le props e lo State, vengono trasformati e restituiscono il JSX desiderato sullo schermo. Il Rendering Code dev'essere puro. Come una formula matematica, dovrebbe calcolare solo il risultato e nulla altro.

• **Event Handlers** - sono funzioni annidate dentro ai Components che fanno cose piuttosto che calcolarle. Un Event Handler può aggiornare un input field, eseguire come submit una POST request HTTP per comprare un prodotto, o portare l'utente ad un'altra schermata. Gli Event Handlers contengono dei "Side Effects", cambiano lo State del programma, causati da una specifica azione dell'utente, per esempio clickando un button o digitando.

Alle volte questo non é abbastanza. Si consideri un Components ChatRoom che deve connettersi al server della chat se é visibile sullo schermo. Connettersi ad un server non é puro calcolo (é un Side Effect) quindi non può avvenire durante il rendering. Comunque, non vi é un singolo particolare Event come un click che causa la visualizzazione di ChatRoom.

Gli Effect permettono di specificare dei Side Effects che sono causati dal rendering stesso, piuttosto che da un particolare event. Mandare un message nella chat é un event perché é direttamente causato dal click dell'utente su uno specifico button. Comunque, impostare una connessione al server é un Effect perché dovrebbe accadere senza tener conto di quale interazione ha causato l'apparizione del Component. Gli Effects si eseguono alla fine della fase di Commit, dopo che lo screen si é aggiornato. Questo é un buon momento per sincronizzare i Components React con qualche sistema esterno (come la rete o una libreria di terze parti).

Nota:
Da qui in avanti, "Effect" con la maiuscola si riferirà alla specifica definizione sopra enunciata, cioé un Side Effect causato dal rendering stesso. Per riferirci al concetto più ampio di programmazione, si definirà side effect.

### 29.2. You might not need ad Effect

Non si abbia fretta di aggiungere un Effect al Component. Si tenga a mente che di Effects sono tipicamente dei passi all'esterno del codice React che ci si sincronizza con sistemi esterni. Questo include le browser API, i widget di terze parti, la rete e così via. Se l'Effect aggiusta solamente lo State su cui si basa o dell'altro State, si potrebbe non volere un Effect.

### 29.3. How to write an Effect

Per scrivere un Effect, si seguano questi tre Step:

1. **Dichiarare un Effect**. Di default, l'Effect si eseguirà dopo ogni render.

2. **Specificare un Effect Dependency**. La maggior parte degli Effects dovrebbero rieseguirsi solo quando necessario piuttosto che dopo ogni render. Per esempio, un'animazione in dissolvenza dovrebbe attivarsi solo quando un Component appare. Connettersi e disconnettersi da una chat room dovrebbe avvenire solo quando il Component appare e scompare, o quando la chat room cambia. Si imparerà come controllarlo specificando le dependencies.

3. **Aggiungere il cleanup se necessario**. Alcuni Effecfs hanno bisogno di specificare come fermarsi, tornare indietro o eseguire una fase di cleanup su ciò che hanno fatto. Per esempio, "connect" ha bisogno di "disconnect", "subscribe" di "unsubscribe" e "fetch" ha bisogno o di "cancel" o di "ignore". Si imparerà come fare tutto questo restituendo una cleanup function.

Vediamo ognuno di questi Step nel dettaglio.

### 29.4. Step 1: Dichiarare un Effect

Per dichiarare un Effect nel Component, si importi l'Hook useEffect da React:

<code>
	import { useEffect } from "react";	
</code>

Poi lo si chiami nel top level del Component e si inserisca del codice dentro al Component:

<code>

    function MyComponentEffect() {

    	useEffect(() => {
    		// Il codice inserito qui si eseguirà ad ogni render
    	});

    	return <div></div>;
    }

</code>

Ogni volta che il Component si renderizza, React aggiornerà lo screen e poi eseguirà il codice all'interno di useEffect. In altre parole, useEffect "ritarda" (delays) un pezzo di codice dall'eseguirsi fino a che il render non viene proiettato nello screen.

Vediamo come possiamo usare un Effect per sincronizzarci con un sistema esterno.
Si consideri un Component React VideoPlayer. Sarebbe bello poter controllare se é in Play o in Pause passando una prop isPlaying ad questo:

<code>

    function VideoPlayer({ scr, isPlaying }) {
    	// fare qualcosa con isPlaying
    	return <video src={src} />;
    }

</code>

Comunque il tag browser "video" non ha una prop isPlaying. L'unico modo per controllarlo é chiamare manualmente i metodi play() e pause() sul DOM element. Si avrà bisogno di sincronizzare la value della prop isPlaying, che dice se il video si sta eseguendo correntemente, con chiamate come play() e pause().

Avremo bisogno prima di tutto di ottenere una ref al DOM node "video".

Si potrebbe esser tentati di provare a chiamare play() e pause() durante il rendering, ma non é corretto:

<code>

    import { useState, useRef, useEffect } from "react";

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	if (isPlaying) {
    		ref.current.play(); // chiamare questo durante il rendering non é permesso
    	} else {
    		ref.current.pause(); // inoltre, questo causa un crash
    	}
    	return <video ref={ref} src={src} />;
    }

    export default function VideoContainer() {
    	const [isPlaying, setIsPlaying] = useState(false);
    	return (
    		<>
    			<button onClick={() => setIsPlaying(!isPlaying)}>
    				{isPlaying ? "Pause" : "Play"}
    			</button>
    			<VideoPlayer
    				isPlaying={isPlaying}
    				src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
    			/>
    		</>
    	);
    }

</code>

La ragione per la quale questo codice non é corretto é che prova a fare qualcosa con il DOM node durante il rendering. In React, il rendering dovrebbe essere un puro calcolo di JSX e non dovrebbe contenere side effects come la modifica del DOM.

Inoltre, quando il Component VideoPlayer viene chiamato per la prima volta, il suo DOM non esiste ancora. Non vi é ancora un DOM node dove poter chiamare play() o pause(), perché React non sa ancora che DOM creare finché non viene restituito il JSX.

La soluzione qui é avvolgere il side effect con useEffect e muoverlo quindi fuori dal calcolo del rendering:

<code>

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if (isPlaying) {
    			ref.current.play();
    		} else {
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	});
    }

</code>

Avvolgendo l'aggiornamento del DOM in un Effect, si permette a React di aggiornare lo screen per prima cosa. Poi si eseguirà l'Effect.

Quando il Component VideoPlayer si renderizza (sia la prima volta che nel caso di rerender), alcune cose accadranno. Per prima, React aggiornerà lo screen, assicurandosi che il tag "video" sia nel DOM con le corrette props. Poi React eseguirà l'Effect. Infine, l'Effect chiamerà play() o pause() in base alla value di isPlaying.

Premendo Play e Pause varie volte di può vedere come il video player rimanga sincronizzato con la value di isPlaying:

<code>

    import { useState, useRef, useEffect } from "react";

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if (isPlaying) {
    			ref.current.play();
    		} else {
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	});
    }

    export default function VideoContainer() {
    	const [isPlaying, setIsPlaying] = useState(false);
    	return (
    		<>
    			<button onClick={() => setIsPlaying(!isPlaying)}>
    				{isPlaying ? "Pause" : "Play"}
    			</button>
    			<VideoPlayer
    				isPlaying={isPlaying}
    				src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
    			/>
    		</>
    	);
    }

</code>

In quest'esempio, il "sistema esterno" che si é sincronizzato con lo State di React é stata la browser media API. Si può usare un approccio similare per avvolgere del codice legacy non-React (come dei plugin jQuery) in Components declarative React.

Si noti che controllare un video player é molto più complesso nella pratica. La chiamata a play() può fallire, lo user potrebbe voler usare play o pause con i controlli integrati del browser e così via. Questo esempio é molto semplificato ed incompleto.

Note:
Di default, gli Effects si eseguono dopo ogni render. Questo é il motivo per cui codici come questo causano un infinite loop:

<code>

    const [count, setCount] = useState(0);

    useEffect(() => {
    	setCount(count + 1);
    })

</code>

Gli Effects si eseguono come risultato del rendering. Impostare lo State attiva un rerendering. Impostare lo State immediatamente in un Effect é come attaccare la presa della corrente a se stessa. L'Effect si esegue, imposta lo State, che causa un rerender, che causa l'esecuzione dell'Effect, che imposta lo State e così via.

Gli Effects di solito dovrebbero sincronizzare i Components con un sistema esterno. Se non vi é alcun sistema esterno e si vuole solamente aggiustare dello State di base o altro State, non si dovrebbe usare un Effect, vedi capitolo successivo.

### 29.5. Specify the Effect dependencies

Di default, gli Effects si eseguono dopo ogni render. Spesso, non é ciò che si vuole:

• Alle volte, é lento. Sincronizzare con un sistema esterno non é sempre istantaneo, quindi si vuole saltare l'esecuzione a meno che non sia necessaria. Per esempio, non si vuole riconnettersi con il server della chat ad ogni tasto premuto.

• Alle volte, é sbagliato. Per esempio, non si vuole attivare un'animazione in dissolvenza ad ogni tasto premuto. L'animazione dovrebbe eseguirsi solamente una volta quando il Component appare per la prima volta.

Per dimostrare il problema, ecco l'esempio precedente con qualche chiamata al console.log ed un input text che aggiorna lo State del parent Component. Si noti come il digitare causi il rieseguirsi dell'Effect:

<code>

    import { useState, useRef, useEffect } from "react";

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if (isPlaying) {
    			console.log("Calling video.play()");
    			ref.current.play();
    		} else {
    			console.log("Calling video.pause()");
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	});
    }

    export default function VideoContainer() {
    	const [isPlaying, setIsPlaying] = useState(false);
    	const [text, setText] = useState("");
    	return (
    		<>
    			<input value={text} onChange={(event) => setText(event.target.value)} />
    			<button onClick={() => setIsPlaying(!isPlaying)}>
    				{isPlaying ? "Pause" : "Play"}
    			</button>
    			<VideoPlayer
    				isPlaying={isPlaying}
    				src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
    			/>
    		</>
    	);
    }

</code>

Si può dire a React di saltare le riesecuzioni dell'Effect non necessarie specificando un Array di dependencies come secondo argument della chiamata a useEffect. Cominciamo aggiungendo un Array vuoto [] all'esempio sopra riportato:

<code>

    useEffect(() => {
    	...
    	}, []);

</code>

Ora si vedrà un Error che indica che l'Hook useEffect di React ha una dependency mancante: isPlaying:

<code>

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if (isPlaying) {
    			console.log("Calling video.play()");
    			ref.current.play();
    		} else {
    			console.log("Calling video.pause()");
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	}, []);
    }

    export default function VideoContainer() {
    	const [isPlaying, setIsPlaying] = useState(false);
    	const [text, setText] = useState("");
    	return (
    		<>
    			<input value={text} onChange={(event) => setText(event.target.value)} />
    			<button onClick={() => setIsPlaying(!isPlaying)}>
    				{isPlaying ? "Pause" : "Play"}
    			</button>
    			<VideoPlayer
    				isPlaying={isPlaying}
    				src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
    			/>
    		</>
    	);
    }

</code>

Il problema é che il codice dentro all'Effect dipende sulla base a cosa fa la prop isPlaying, ma questa dependency non é dichiarata esplicitamente. Per sistemare questo problema, basta aggiungere isPlaying al dependency array:

<code>

    useEffect(() => {
    		if (isPlaying) { // viene usato qui...
    			ref.current.play();
    		} else {
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	}, [isPlaying]); // ...quindi deve essere dichiarato qui

</code>

Ora tutte le dependency sono dichiarate, quindi non vi sono errori. Specificando [isPlaying] nel Dependency Array diciamo a React che dovrebbe saltare la riesecuzione dell'Effect se ilPlaying é lo stesso rispetto al precedente rendering. Con questo cambiamento, digitare all'interno dell'input non causerà il rieseguirsi dell'Effect, ma premere Play/Pause lo causerà:

<code>

    import { useState, useRef, useEffect } from "react";

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if (isPlaying) {
    			console.log("Calling video.play()");
    			ref.current.play();
    		} else {
    			console.log("Calling video.pause()");
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	}, [isPlaying]);
    }

    export default function VideoContainer() {
    	const [isPlaying, setIsPlaying] = useState(false);
    	const [text, setText] = useState("");
    	return (
    		<>
    			<input value={text} onChange={(event) => setText(event.target.value)} />
    			<button onClick={() => setIsPlaying(!isPlaying)}>
    				{isPlaying ? "Pause" : "Play"}
    			</button>
    			<VideoPlayer
    				isPlaying={isPlaying}
    				src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
    			/>
    		</>
    	);
    }

</code>

Il Dependency Array può contenere molteplici dependencies. React salterà il rerunning dell'Effect solo se tutte le dependencies specificate avranno le stesse values che avevano durante il render precedente. React compara le dependencies values usando la comparazione Object.is. Si vedano le referece di useEffect per i dettagli.

Si noti che non si possono "scegliere" le dependencies. Si andrà verso un errore se le dependencies specificate non coincideranno con ciò che React si aspetta basandosi sul codice contenuto nell'Effect. Questo é utile per cogliere molti bug all'interno del codice. Se non si vuole che del codice si riesegua, si cambi il codice dell'Effect stesso in modo da non necessitare di una determinata dependency.

Nota:
Il comportamento senza il Dependency Array e con un empty Dependency Array [] sono differenti:

<code>
useEffect(() => {
	<!-- Questo di esegue ad ogni render -->
})
useEffect(() => {
	<!-- Questo si esegue solo nel mount - quando il Component appare -->
}, [])
useEffect(() => {
	<!-- Questo si esegue al mount e anche alla variazione di a o b dall'ultimo render -->
}, [a, b])
</code>

Vedremo più da vicino con significa "Mount" nel prossimo Step.

### 29.6. Why was the ref omitted from the dependencies array?

Questo Effect usa sia ref che isPlaying ma solo quest'ultima viene dichiarata come una dependency:

<code>

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if (isPlaying) {
    			console.log("Calling video.play()");
    			ref.current.play();
    		} else {
    			console.log("Calling video.pause()");
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	}, [isPlaying]);
    }

</code>

Questo perché l'object ref ha una "stable identity" (identità stabile): React garantisce che si otterrà sempre lo stesso object dalla stessa chiamata a useRef su ogni render. Non cambia mai, quindi non causerà mai da solo il re-run dell'Effect. Quindi, non importa se lo si include o meno.

Includerlo va bene ugualmente:

<code>

    function VideoPlayer({ scr, isPlaying }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if (isPlaying) {
    			console.log("Calling video.play()");
    			ref.current.play();
    		} else {
    			console.log("Calling video.pause()");
    			ref.current.pause();
    		}
    		return <video ref={ref} src={src} loop playsInline />;
    	}, [isPlaying, ref]);
    }

</code>

Le set function restituite dallo State hanno anch'esse un identità stabile, quindi le si vedrà omesse dal Dependency Array. Se il compilatore permette di omettere una dependency senza errori, é sicuro farlo.

Omettere le dependencies sempre stabili funziona solamente quando il compilatore può "vedere" che quell'object é sempre stabile. Per esempio, se ref venisse passata da un parent Component, si dovrebbe specificarla nel Dependency Array. Comunque, questo va bene perché non si può sapere se il parent Component passa sempre la stessa ref, o passa una tra varie ref in modo condizionale. Quindi l'effect dipenderà da quale ref gli viene passata.

### 29.7. Add cleanup if needed

Si consideri un esempio differente. Si sta scrivendo un Component ChatRoom che necessita di connettersi al server della chat quando appare. Si vorrà ottenere da una createConnection() API un object con i metodi connect() e disconnect(). Come si mantiene un Component connesso mentre viene visualizzato da un utente?

Cominciamo scrivendo la logica dell'Effect:

<code>

    useEffect(() => {
    	const connection = createConnection();
    	connection.connect();
    })

</code>

Sarebbe lento connettersi alla chat dopo ogni re-render, quindi aggiungiamo un Dependency Array:

<code>

    useEffect(() => {
    	const connection = createConnection();
    	connection.connect();
    }, [])

</code>

Il codice all'interno dell'Effect non usa alcuna prop o State, quindi il Dependency Array sarà empty []. Questo dice a React di eseguire questo codice solamente quando il Component "mount" (viene montato), cioé quando appare nello schermo per la prima volta.

Proviamo ad eseguire questo codice:

<code>

chat.jsx

    export function createConnection() {
    	// Una reale implementazione si connetterebbe effettivamente al server
    	return {
    		connect() {
    			console.log("✅ Connecting...");
    		},
    		disconnect() {
    			console.log("❌ Disconnected.");
    		}
    	};
    }

ChatRoom.jsx

    import { useEffect } from "react";
    import { createConnection } from "./chatDependency";

    export default function ChatRoom() {
    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    	}, []);
    	return <h1>Welcome to the chat!</h1>;
    }

</code>

Questo Effect si eseguirà solo nella fase di Mount, quindi ci si può aspettare che venga visualizzato nella console "✅ Connecting...". Comunque, se si controlla, questo verrà eseguito due volte. Perché questo accade?

Si immagini che il Component ChatRoom sia parte di un'App più grande con molti screen differenti. L'utente comincia il suo viaggio nella Page CHatRoom. Il Component si monta e chiama connection.connect(). Poi si immagini che lo user navighi in un altra schermata, per esempio nella Settings Page. Il Component ChatRoom si smonterà. Infine, lo user clicka Back ed il Component ChatRoom si monta nuovamente. Questo imposterà una seconda connection, ma la prima non é mai stata distrutta. Mano a mano che lo user naviga attraverso l'App, le connessioni continueranno ad accumularsi.

Bug come questi sono molto sfuggevoli senza un testing manuale approfondito. Per aiutare a trovarli velocemente, in development React rimonta tutti i Components di nuovo immediatamente dopo il mount iniziale.

Poter vedere il log "✅ Connecting..." due volte aiuta a notare il reale problema: il codice non chiude la connessione quando il Component viene smontato.

Per sistemare il problema, occorre restituire una Cleanup function dall'Effect:

<code>

    useEffect(() => {
    	connection.connect();
    	return () => {
    		connection.disconnect();
    	}
    }, [])

</code>

React chiamerà la Cleanup function ogni volta prima che l'Effect si riesegua nuovamente, e una volta finale quando il Component viene smontato (viene rimosso). Vediamo cosa accade quando viene implementata la Cleanup function:

<code>

    import { useEffect } from "react";
    import { createConnection } from "./chatDependency";

    export default function ChatRoom() {
    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		return () => connection.disconnect();
    	}, []);
    	return <h1>Welcome to the chat!</h1>;
    }

</code>

Ora si ottengono tre console.log in development:

1. "✅ Connecting..."
2. "❌ Disconnected."
3. "✅ Connecting..."

Questo é il corretto comportamento in development. Rimontando il Component React verifica che navigare oltre e tornare indietro non rompa il codice. Disconnettersi e poi connettersi nuovamente é esattamente cosa dovrebbe accadere. Quando si implementa il cleanup correttamente, non ci dovrebbero essere differenze visibili dall'utente tra eseguire l'Effect una volta contro eseguirlo, eseguire il cleanup ed eseguirlo nuovamente. Vi é inoltre una coppia di chiamate connect/disconnect visto che React sta provando il codice in cerca di bug in development. Questo é normale, meglio non levarlo.

In fase di Production, si vedrà "✅ Connecting..." stampato solo una volta. Rimontare i Components avviene solamente in fase di Development per aiutare a trovare Effects che necessitano della fase di Cleanup. Si può anche disattivare la Strict mode per uscire dal comportamento del Development, ma é sconsigliato. Questo permette di trovare molti bug come quello appena illustrato.

### 29.8. How to handle the Effect firing twice in development

React rimonta intenzionalmente i Components in Development per trovare bug come nell'ultimo esempio. La domanda corretta non é "come eseguire un Effect una volta" ma "come sistemare l'Effect in modo che funzioni dopo essere stato rimontato".

Di solito la risposta é implementare un Cleanup function. La Cleanup function dovrebbe fermare o ripristinare qualunque cosa l'Effect stesse facendo. La regola di condotta é che lo user non dovrebbe essere in grado di distinguere tra l'Effect eseguito una volta (come in Production) e una sequenza di setup --> cleanup --> setup (come si vede in Development).

La maggior parte degli Effects che si scriveranno corrisponderà ad uno dei pattern comuni sottostanti:

#### 29.8.1. Controlling non-React widgets

A volte si avrà bisogno di aggiungere dei widget della UI che non sono scritti per React. Per esempio, diciamo di voler aggiungere un Component map alla Page. Ha un metodo setZoomLevel() e vorremmo tenere il zoom level sincronizzato con una variabile zoomLevel nel codice React. L'Effect si mostrerà simile a questo:

<code>

    useEffect(() => {
    	const map = mapref.current;
    	map.setZoomLevel(zoomLevel);
    }, [zoomLevel]);

</code>

Si noti che non vi é necessità di una Cleanup function in questo caso. In Development, React chiamerà l'Effect due volte, ma non é un problema perché chiamare setZoomLevel due volte con le stesse values non fa nulla. Potrebbe essere leggermente più lento, ma non importa perché non verrà rimontato inutilmente in Production.

Alcune API non permettono di chiamarle due volte di fila. Per esempio, il metodo showModal nell'element <dialog > da un errore se viene chiamato due volte. Qui occorre implementare una Cleanup function e far chiudere il dialog:

<code>

    useEffect(() => {
    	const dialog = dialogRef.current;
    	dialog.showModal();
    	return () => dialog.close();
    }, [])

</code>

In fase di Development, l'Effect chiamerà showModal(), poi immediatamente close() e poi nuovamente showModal(). Questo ha lo stesso comportamento dal punto di vista dell'utente che chiamare una sola volta showModal(), come si verdà in Production.

#### 29.8.2. Subscribing to events

Se l'Effect subscribe a qualcosa, la Cleanup function dovrebbe eseguire l'unsubscribe:

<code>

    useEffect(() => {
    	function handleScroll(event){
    		console.log(window.scrollX, window.scrollY);
    	}
    	window.addEventListener("scroll", handleScroll);
    	return () => window.removeEventListener("scroll", handleScroll);
    }, [])

</code>

In Development, l'Effect chiamerà addEventListener(), poi immediatamente removeEventListener() e poi nuovamente addEventListener() con lo stesso handler. Quindi ci sarà solo un subscription attiva al momento. Questo é lo stesso comportamento visto dal punto di vista dell'utente rispetto al chiamarlo una sola volta in Production.

#### 29.8.3. Trigger animations

Se l'Effect esegue un animazione su qualcosa, la Cleanup function dovrebbe resettare l'animazione alle values iniziali:

<code>

    useEffect(() => {
    	const node = ref.current; // attiva l'animazione
    	node.style.opacity = 1;
    	return () => {
    		node.style.opacity = 0; // reset alla value iniziale
    	}
    }, [])

</code>

In Development, l'opacity sarebbe impostata ad 1, poi a 0 e poi ad 1 nuovamente. Questo dovrebbe mostrarsi come un comportamento medesimo, dal punto di vista dello user, rispetto ad impostare direttamente ad 1 una sola volta in Production. Se si usa una library di terze parti per le animazioni con supporto alle interpolazioni, la Cleanup function dovrebbe resettare la timeline al suo stato iniziale.

#### 29.8.4. Fetching data

Se l'Effect esegue il fetch su qualcosa, la Cleanup function dovrebbe o eseguire l'abort del fetch o ingnorare il risultato:

<code>

    useEffect(() => {
    	let ignore = false;

    	async function startFetching(){
    		const json = await fetchTodos(userId);
    		if(!ignore){
    			setTodos(json);
    		}
    	}
    	startFetching();

    	return () => {
    		ignore = true;
    	}
    }, [userId])

</code>

Non si può eseguire il ripristino su una network request appena avvenuta, ma la Cleanup function dovrebbe assicurarsi che il fetch che non é più rilevante non continui ad avere effetti sull'App. Se lo userId cambia da "Alice" a "Bob" la Cleanup assicura che la response ad "Alice" venga ignorata persino se arriva dopo quella a "Bob".

In Development, si vedranno due fetch nella Network Tab. Non vi é nulla di errato qui. Con l'approccio mostrato sopra, il primo Effect verrà immediatamente passato alla fase di Cleanup quindi la sua copia della variabile ignore sarà impostata a true. Quindi persino se vi fosse un'ulteriore request, non avrebbe effetto nello State grazie al controllo if(!ignore).

In Production, ci sarebbe solamente una request. Se la seconda request in Development risulta fastidiosa, il migliore approccio é usare una soluzione che deduplica le requests e coglie (catch) le loro response tra i Components:

<code>

    function TodoList(){
    	const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);
    	// ...
    }

</code>

Questo non solo migliorerà l'esperienza di sviluppo, ma renderà anche l'App più veloce. Per esempio, lo User che preme il button Back non dovrà aspettare perché i dati vengano caricati nuovamente perché saranno salvati nella cache. Si può costruire una cache in proprio o usare una delle alternative manuali al fetching negli Effects.

#### 29.8.5. Deep Dive - What are good alternatives to data fetching in Effects?

Scrivere delle chiamate a fetch dentro agli Effects é un modo popolare di eseguire il fetch dei dati, specialmente nelle App client-side complete. Questo é, comunque, un approccio molto manuale e ha dei difetti rilevanti:

• **Gli Effects non si eseguono sul server**. Questo significa che l'HTML iniziale server-rendered includerà solamente un loading State e nessun dato. Il computer client dovrà effettuare il download di tutto il codice JavaScript e renderizzare l'App solo per scoprire che ora ha bisogno di effettuare il download dei dati. Questo non é molto efficente.

• **Eseguire il Fetch direttamente negli Effects rende più facile la creazione di "network waterfalls"**. Si immagini di renderizzare il parent Component, si esegue il Fetch dei dati e poi si renderizzano i child Components e questi cominciano il fetch dei loro dati. Se la rete non é molto veloce, questo é significativamente più lento rispetto ad effettuare il fetch dei dati in parallelo.

• **Eseguire il Fetch direttamente negli Effect di solito significa che non si effettua un preload o il cache dei dati**. Per esempio, se il Component viene smontato e poi rimontato, dovrà eseguire il fetch dei dati nuovamente.

• **Non é molto ergonomico**. Vi é abbastanza codice da scrivere quando si eseguono delle chiamate fetch in un modo che non soffra di bug come le race conditions (vedi link).

Questa lista di problematiche non é specifica di React. Si applica al fetch dei dati al momento del mount con ogni library. Come con il routing, il fetch dei dati non é banale da fare correttamente, quindi si consiglia di seguire questi approcci:

• Se si usa un framework, si usino i meccanismi di fetching integrati. I moderni frameworks React hanno integrati dei meccanismi di fetching dei dati che sono efficenti e non soffrono delle problematiche elencate sopra.

• Altrimenti si consideri di usare o costruire una cache client-side. Soluzioni popolari includono React Query, useSWR e React Rounter. Si può costruire la propria soluzione anche, nel caso in cui si voglia usare gli Effects di nascosto, ma aggiunge logica per riduplicare le requests, eseguire il cache delle responses ed evitare le network waterfalls (eseguendo il preload dei dati o l'hosting dei dati necessari alle routes).

Si può continuare ad eseguire il fetch dei dati direttamente negli Effects se nessun di questi approcci é comodo.

#### 29.8.6. Sending Analytics

Si consideri questo codice che manda un analytics event alla visita della pagina:

<code>

    useEffect(() => {
    	logVisit(url);
    } [url])

</code>

In Delopment, logVisit sarebbe chiamato due volte per ogni URL, quindi si potrebbe essere tentati di sistemarlo. Si raccomanda di mantenere il codice com'é. Come con gli esempi precedenti, non vi una differenza di comportamento tra eseguire questo Effect una o due volte. Da un punto di vista pratico, logVisit non dovrebbe far nulla in Development perché non si vogliono log dalle macchine usate per lo sviluppo che vanno ad inficiare le metriche. Il Component va a rimontarsi ogni volta che si salva il suo file quindi vi sarebbero dei log di visite in più rispetto a quelle reali.

In Production, non ci saranno duplicati dei log delle visite.

Per eseguire il debug degli events analytics che si stanno mandando, si può eseguire il deploy dell'App in un ambiente staging (che esegue in Production Mode) o optare temporaneamente per uscire dalla Strict Mode e i suoi remounting di controllo delle modalità Development. Si possono inoltre mandare gli analytics dagli event handlers del cambio di route o utilizzare gli intersection observers, al posto di un Effect.

#### 29.8.7. Not an Effect: Initializing the application

Una parte determinata di logica dovrebbe eseguirsi solamente quando l'App si avvia. La si può inserire fuori dai Components:

<code>

    if(typeof window !== "undefined"){
    	// Controllo se si sta eseguendo nel browser
    	checkAuthToken();
    	loadDataFromLocalStorage();
    }

    function App(){
    	// ...
    }

</code>

Questo garantisce che tale logica si esegua solamente una volta che il browser carica la pagina.

#### 29.8.8. Not an Effect: Buying a product

A volte, persino se si scrive una Cleanup function, non vi é modo di prevenire delle conseguenze visibili allo user dell'eseguire l'effect due volte. Per esempio, forse l'Effect manda una POST request come l'acquisto di un prodotto:

<code>

    useEffect(() => {
    	// 🔴 Errato: Questo Effect si attiva due volte in development,
    	// esponendo un problema nel codice
    	fetch("/api/buy", {method: "POST"});
    }, [])

</code>

Non si dovrebbe voler acquistare due volte qui. Comunque, questo é anche il motivo perché non si dovrebbe inserire questa logica in un Effect. E se lo User andasse in un'altra pagina e premesse "Back"? L'Effect si rieseguirebbe. Non si vuole che venga acquistato un prodotto ogni volta che l'utente visita la pagina, lo si vuole fare solo al click del button "Buy".

L'acquisto non deve essere causato dal rendering, ma da una specifica interazione. Si cancelli quindi l'eventuale Effect e si sposti la request a /api/buy nell'Event Handler del Buy button:

<code>

    function handleClick(){
    	// ✅ l'acquisto (Buy) é un event perché viene causato da...
    	// una particolare interazione
    	fetch("/api/buy", {method: "POST"});
    }

</code>

Questo illustra che il remounting rompe la logica dell'App, e non copre dall'eventuale esistenza di bug. Da una prospettiva dell'utente, visitare una pagina non dovrebbe essere diverso dal visitarla, clickare un link e premere Indietro. React verifica che un Component rispetti questo principio rimontandolo una volta in più in fase di Development.

### 29.9. Putting it all together

Questo Playground può aiutare a "farsi un'idea" di come gli Effects funzionano in pratica.

Questo esempio usa setTimout per schedulare un console.log con l'input text che appare tre secondi dopo che l'Effect si esegue. La Cleanup function cancella il timeout pendente. Si cominci premendo "Mount the Component":

<code>

    import { useState, useEffect } from "react";

    function Playground() {
    	const [text, setText] = useState("a");

    	useEffect(() => {
    		function onTimeout() {
    			console.log("⏰ " + text);
    		}
    		console.log('🔵 Schedule "' + text + '" log');
    		const timeoutId = setTimeout(onTimeout, 3000);

    		return () => {
    			console.log('🟡 Cancel "' + text + '" log');
    			clearTimeout(timeoutId);
    		};
    	}, [text]);

    	return (
    		<>
    			<label>
    				What to log:{" "}
    				<input value={text} onChange={(event) => setText(event.target.value)} />
    			</label>
    			<h1>{text}</h1>
    		</>
    	);
    }

    export default function PlayGroundContainer() {
    	const [show, setShow] = useState(false);
    	return (
    		<>
    			<button onClick={() => setShow(!show)}>
    				{show ? "Unmount" : "Mount"} the component
    			</button>
    			{show && <hr />}
    			{show && <Playground />}
    		</>
    	);
    }

</code>

Si vedranno tre log per prima cosa: 🔵 Schedule "a" log, 🟡 Cancel "a" log, 🔵 Schedule "a" log di nuovo. Tre secondi dopo comparirà un log con "a". Come appreso precedentemente, la coppia aggiuntiva schedule/cancel compare perché React rimonta il Component una volta in più in fase di Development per verificare che si abbia implementato una fase di Cleanup correttamente.

Ora editiamo l'input per dire "abc". Se lo si fa abbastanza velocemente, si vedrà si vedrà un log Schedule "ab" log seguito immediatamente da 🟡 Cancel "ab" log e 🔵 Schedule "abc" log. React esegue sempre il Cleanup sull'Effect del precedente render prima dell'Effect del successivo render. Questo perché se si scrive qualcosa nell'input velocemente vi é al massimo un timeout schedulato in un momento. Si editi l'input varie volte e si guardino i log per farsi un'idea di come la fase di Cleanup agisca sugli Effects.

Si scriva qualcosa nell'input e poi si prema immediatamente "Unmount the Component". Si noti come l'unmounting esegua il clean up sull'ultimo render dell'Effect. Qui pulisce l'ultimo timeout prima che abbia l'opportunità di attivarsi.

Infine, si editi il Component levando la Cleanup function, in modo che i timeout non vengano cancellati. Tre secondi dopo, come intuibile, vi sarà un timeout per ogni digitazione. Ogni Effect "coglie" la value di text dal suo corrispondente render. Non importa che lo State text sia cambiato: un Effect dal render con text = "ab" vedrà sempre "ab". Gli Effects da ogni render sono isolati dagli altri. Per approfondire, vedi Closures in MDN.

### 29.10. Each render has its own Effects

Si può pensare a useEffect come all'attaccare un pezzo di comportamento all'output del render. Si consideri questo Effect:

<code>

    export default function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]);

    	return <h1>Welcome to {roomId}</h1>;
    }

</code>

Vediamo cosa accade esattamente quando lo user naviga nell'App.

### 29.11. Initial render

Lo user visita <ChatRoom roomId="general" />. Sostituiamo roomId con "general":

<code>
	// JSX per il primo render (roomId = "general")
	return <h1>Welcome to general</h1>;
</code>

L'Effect é inoltre parte dell'output del rendering. Il primo Effect del render diviene:

<code>

    // Effect per il primo render (roomId = "general")
    () => {
    	const connection = createConnection("general");
    	connection.connect();
    	return () => connection.disconnect();
    },
    // Dependencies per il primo render (roomId = "general")
    ["general"]

</code>

React esegue questo Effect, che connette con la chat room "general".

### 29.12. Re-render with same dependencies

Diciamo che in <ChatRoom roomId="general" /> avvenga un re-render. L'output del JSX quindi sarà lo stesso:

<code>

    // JSX per il secondo render (roomId = "general")
    return <h1>Welcome to general</h1>;

</code>

React vede che il secondo output del rendering non é cambiato, quindi non aggiorna il DOM.

L'Effect per il secondo render si mostra così:

<code>

    // Effect per il secondo render (roomId = "general")
    () => {
    	const connection = createConnection("general");
    	connection.connect();
    	return () => connection.disconnect();
    },
    // Dependencies per il secondo render (roomId = "general")
    ["general"]

</code>

React compara ["general"] dal secondo render con ["general"] nel primo render. Visto che tutte le dependencies sono uguali, React ignorerà l'Effect dal secondo render. Non verrà mai chiamato.

### 29.13. Re-render with different dependencies

Poi, lo user visita <ChatRoom roomId="travel" />. Questa volta, il Component restituisce un diverso JSX:

<code>

    // JSX per il terzo render (roomId = "travel")
    return <h1>Welcome to travel</h1>

</code>

React aggiorna il DOM per cambiare "Welcome to general" in "Welcome to travel".

L'Effect dal terzo render si mostra come:

<code>

    // Effect per il terzo render (roomId = "travel")
    () => {
    	const connection = createConnection("travel");
    	connection.connect();
    	return () => connection.disconnect();
    },
    // Dependencies per il terzo render (roomId = "travel")
    ["travel"]

</code>

React compara ["travel"] dal terzo render con ["general"] dal secondo render. Una dependency é diversa:
Object.is("travel", "general") risulta false.
L'Effect non può essere saltato.

Prima che React possa applicare l'Effect dal terzo render, ha bisogno di eseguire la fase di Cleanup dell'ultimo Effect che si é eseguito. Il secondo Effect del render é stato saltato, quindi React ha bisogno di eseguire il cleanup dell'Effect del primo render. Se si controlla si constaterà che la sua Cleanup function chiama disconnect() sulla connction che é stata creata con createConnection("general"). Questo disconnette l'App dalla chat room "general".

Dopo di questo React esegue l'Effect del terzo render. Si connette quindi con la chat room "travel".

### 29.14. Unmount

Infine, diciamo che lo user se ne va, e il ChatRoom Component viene smontato. React esegue la Cleanup function dell'ultimo Effect. L'ultimo Effect é stato dal terzo render. La fase di cleanup del terzo render distrugge la connection: createConnection("travel"). Quindi l'App si disconnette dalla chat room "travel".

### 29.15. Development-only behaviors

Quando la Strict Mode é attivata, React rimonta ogni Component una volta in più dopo il mount (lo State ed il DOM sono preservati). Questo aiuta a trovare gli Effects che necessitano di una fase di Cleanup ed espongono bug come le race conditions citate precedentemente. Addizionalmente, React monterà gli Effects nuovamente se si salva un file in modalità Development. Entrambi questi comportamenti sono specifici della fase di Development.

### 29.16. Exercises

1- Non funziona perché al momento della chiamata a ref.current, l'input non esiste ancora. Occorre chiamarlo con il metodo focus dentro ad un Effect:

<code>

    import { useEffect, useRef } from 'react';

    export default function MyInput({ value, onChange }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		ref.current.focus();
    	}, [])

    	return (
    		<input
    			ref={ref}
    			value={value}
    			onChange={onChange}
    		/>
    	);
    }

</code>

Perfetto :white_check_mark:

2- Ricordare conditional all'interno dell'Effect, mai all'esterno:

<code>

    import { useEffect, useRef } from 'react';

    export default function MyInput({ shouldFocus, value, onChange }) {
    	const ref = useRef(null);

    	useEffect(() => {
    		if(shouldFocus){
    			ref.current.focus();
    		}
    	}, [shouldFocus]);

    	return (
    		<input
    			ref={ref}
    			value={value}
    			onChange={onChange}
    		/>
    	);
    }

</code>

Perfetto :white_check_mark:

3- Si necessita di una Cleanup function per fermare l'interval.

<code>

    import { useState, useEffect } from 'react';

    export default function Counter() {
    	const [count, setCount] = useState(0);

    	useEffect(() => {
    		function onTick() {
    			setCount(c => c + 1);
    		}

    		const intervalId = setInterval(onTick, 1000);
    		return () => clearInterval(intervalId);
    	}, []);

</code>

Perfetto :white_check_mark:

4- Ripassato tutorial per capire soluzione:

<code>

    import { useState, useEffect } from 'react';
    import { fetchBio } from './api.js';

    export default function Page() {
    	const [person, setPerson] = useState('Alice');
    	const [bio, setBio] = useState(null);

    	useEffect(() => {
    		let ignore = false;
    		setBio(null)

    				fetchBio(person).then(result => {
    					if(!ignore){
    					setBio(result);
    					}
    				})

    		return () => {
    			ignore = true;
    		}
    	}, [person]);

    	return (
    		<>
    			<select value={person} onChange={e => {
    				setPerson(e.target.value);
    			}}>
    				<option value="Alice">Alice</option>
    				<option value="Bob">Bob</option>
    				<option value="Taylor">Taylor</option>
    			</select>
    			<hr />
    			<p><i>{bio ?? 'Loading...'}</i></p>
    		</>
    	);
    }

</code>

Perfetto :white_check_mark:

## 30. You Might Not Need an Effect

Gli Effects sono una via di fuga dal paradigma di React. Permettono di fare un passo all'esterno di React e sincronizzare i Components con dei sistemi esterni come un widget non-React, il network o il DOM del browser. Se non vi é nessun sistema esterno coinvolto, per esempio se si vuole aggiornare lo State di un Component quando delle props o lo State cambia, non si dovrebbe necessitare di un Effect. Rimuovere gli Effects non necessari renderà il tuo codice più facile da seguire, veloce da eseguire e meno propenso ad errori.

### 30.1. How to remove unneccessary Effects

Vi sono due casi comuni per i quali non si necessita di un Effect:

• **Non si necessita degli Effects per trasformare i dati per il rendering**. Per esempio, diciamo di voler filtrare una lista prima di mostrarla. Si potrebbe essere tentati di scrivere un Effect che aggiorna una State variable quando la lista cambia. Comunque, questo é inefficente. Quando si aggiorna lo State, React chiamerà prima le funzioni dei Components per calcolare cosa dovrebbe esserci nello schermo. Poi React eseguirà gli Effects. Se l'Effect aggiorna immediatamente lo State, questo farà ricominciare l'intero processo da zero. Per evitare che passino render non necessari, meglio trasformare tutti i dati nel top-level dei Components. Tale codice rieseguirà tutto automaticamente se le prop o lo State cambieranno.

• **Non si necessita degli Effects per gestire gli user events**.
Per esempio, diciamo di voler mandare una POST request ad /api/buy e mostrare una notifica quando lo user acquista un prodotto. Nell'Event Handler click del Buy button, si sa esattamente ciò che accade. Al momento che l'Effect si esegue, non si sa cosa lo user ha fatto (per esempio, quale button é stato clickato). Questo é il motivo per cui é meglio gestire gli user events nei corrispondenti Event Handlers.

Si avrà bisogno degli Effect per sincronizzarsi con sistemi esterni. Per esempio, si può scrivere un Effect che mantenga un widget jQuery sincronizzato con lo State di React. Si può inoltre eseguire il fetch dei dati con gli Effects: per esempio, si può sincronizzare i risultati di una ricerca con la query corrente della ricerca. Si tenga a mente che i framework moderni forniscono dei meccanismi di data fetching più efficenti rispetto allo scrivere gli Effects direttamente nei Components.

Per ottenere la giusta intuizione, vediamo qualche esempio concreto.

### 30.2. Updating state based on props or state

Supponiamo di avere un Component con due State variables: firstName e lastName. Da queste si vuole calcolare un fullName concatenandole.
Inoltre, vorremo aggiornare fullName se firstName o lastName cambiassero.
Il primo istinto potrebbe essere quello di aggiungere una State variable fullName ed aggiornarla in un Effect:

<code>

    function Form() {
    	const [firstName, setFirstName] = useState("Taylor");
    	const [lastName, setLastName] = useState("Swift");

    	// 🔴 Evitare: State ridondante ed Effect non necessario
    	const [fullName, setFullName] = useState("");
    	useEffect(() => {
    		setFullName(firstName + " " + lastName);
    	}, [firstName, lastName]);
    }

</code>

Questo é più complicato del necessario. Ed é anche inefficente: effettua un intero passaggio del render con una State value per fullName, poi immediatamente re-renderizza con la value aggiornata. Si possono rimuovere sia la State variable che l'Effect:

<code>

    function Form() {
    	const [firstName, setFirstName] = useState("Taylor");
    	const [lastName, setLastName] = useState("Swift");

    	// ✅ Buono: calcolato durante il rendering
    	const fullName = firstName + " " + lastName;
    	// ...
    }

</code>

Quando qualcosa può essere calcolato dalle prop esistenti o dallo State, non bisogna inserirlo nello State. Invece, conviene calcolarlo durante il rendering. Questo rende il codice più veloce (si possono evitare gli ulteriori aggionamenti a "cascata"), più semplice (si rimuove del codice) e meno propenso ad errori (si evitano i bug causati da diverse State variables che vanno fuori sincronia tra loro). Vedi dettagli in Thinging in React.

### 30.3. Caching expensive calculations

Questo Component computa visibleTodos prendendo i todos che riceve dalle props e filtrandoli in base alla prop filter. Ci si potrebbe sentire tentati di archiviare il result nello State ed aggiornarlo da un Effect.

<code>

    function TodoList({ todos, filter }) {
    	const [newTodo, setNewTodo] = useState("");

    	// 🔴 Evitare: State ridondante e Effect non necessario

    	const [visibleTodos, setVisibleTodos] = useState([]);
    	useEffect(() => {
    		setVisibleTodos(getFilteredTodos(todos, filter));
    	}, [todos, filter]);

    	// ...
    }

</code>

Come nell'esempio precedente, questo é sia non necessario che inefficente. Prima di tutto rimuoviamo lo State e l'Effect:

<code>

    function TodoList({ todos, filter }) {
    	const [newTodo, setNewTodo] = useState("");

    	// ✅ Questo va bene se getFilteredTodos() non é lento
    	const visibleTodos = getFilteredTodos(todos, filter);
    	// ...
    }

</code>

Di solito questo codice va bene. Ma forse getFilteredTodos é lento o si hanno molti todos. In tale caso non si vuole ricalcolare getFilteredTodos() se delle State variables non relazionate come newTodo vengono cambiate.
Si può salvare in una cache, o "memoize", un calcolo dispendioso in termini di memoria, avvolgendolo in un Hook useMemo:

<code>

    function TodoList({ todos, filter }) {
    	const [newTodo, setNewTodo] = useState("");

    	const visibleTodos = useMemo(() => {
    		// ✅ Non si riesegue a meno che todos o filter non cambino
    		return getFilteredTodos(todos, filter);
    	}, [todos, filter]);
    	// ...
    }

</code>

O, scritto in un unica riga:

<code>

    function TodoList({ todos, filter }) {
    	const [newTodo, setNewTodo] = useState("");

    		// ✅ Non si riesegue a meno che todos o filter non cambino

    		const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter])

    		// ...

    }

</code>

Questo dice a React che non si vuole che la funzione interna venga rieseguita a meno che todos o filter non cambino. React ricorderà la value restituita da getFilteredTodos() durante il render iniziale.
Durante i successivi render, controllerà se todos o filter sono differenti. Se sono gli stessi dell'ultima volta, useMemo restituirà l'ultimo risultato che ha archiviato. Ma se sono differenti, React chiamerà nuovamente la funzione interna, e ne archivierà il risultato.

La funzione che si avvolge in useMemo si esegue durante il rendering, quindi funziona solamente per calcoli puri.

### 30.4. How to tell if a calculation is expensive?

In generale, a meno che non si stia creando o eseguendo un loop tra migliaia di objects, probabilmente non si può considerare costoso in termini di memoria (expensive). Se si vuole avere più certezza della cosa, si può aggiungere un console.log per misurare il tempo impiegato da un pezzo di codice:

<code>

    console.time("filter array")
    const visibleTodos = getFilteredTodos(todos, filter);
    console.timeEnd("filter array");

</code>

Si faccia performare l'interazione che si sta misurando, per esempio digitando in un input. Si vedranno i log come
filter array: 0.15ms nella console.
Se il tempo complessivo raggiunge un quantitativo considerevole, diciamo 1ms o più, ha senso memorizzarne il calcolo.
Come esperimento, si può provare ad avvolgere il calcolo in useMemo per verificare se il tempo totale di logo aumenta con l'interazione o no:

<code>

    function TodoList({ todos, filter }) {
    	const [newTodo, setNewTodo] = useState("");

    	console.time("filter array");
    	const visibleTodos = useMemo(
    		() => getFilteredTodos(todos, filter),
    		[todos, filter]
    	);
    	console.timeEnd("filter array");
    	// ...
    }

</code>

useMemo non renderà il primo render più veloce. Aiuta solamente a saltare del lavoro inutile negli aggiornamenti.

Si tenga anche a mente che probabilmente si sta usano una macchina più veloce rispetto a quella dei futuri utenti, quindi é una buona idea testare le performance con un rallentamento artificiale, per esempio quelli di Chrome.

Inoltre si noti che misurare le performance in fase di Development non darà i risultati più accurati. Per esempio, si consideri il doppio rendering dovuto alla Strict mode. Per ottenere delle tempistiche più accurate, si esegua la build dell'App in Production e la si testi con dei device simili a quelli finali.

### 30.5. Resetting all state when a prop changes

Questo ProfilePage Component riceve una prop userId. Questa pagina contiene un input comment, e si userà una State variable comment per ospitare la sua value. Si noterà un problema: quando si naviga da un profilo all'altro, lo State comment non viene resettato. Come risultato, é facile postare accidentalmente un commento da un user profile errato. Per sistemare questo problema, Si desidera pulire la State variable comment quando la prop userId cambia:

<code>

    export default function ProfilePage({ userId }) {
    	const [comment, setComment] = useState("");

    	// 🔴 Evitare: Resettare lo State al cambio della prop...
    	//    all'interno di un Effect
    	useEffect(() => {
    		setComment("");
    	}, [userId]);
    	// ...
    }

</code>

Questo é inifficente perché ProfilePage e i suoi children si renderizzeranno prima con la vecchia value, e poi si renderizzeranno nuovamente. E' anche complicato perché per farlo si necessita di farlo in ogni Component che ha dello State dentro a ProfilePage. Per esempio, se la UI del comment é annidata, si vorrà pulire anche il comment annidato.

Al posto di questo, si può dire a React che ogni profilo dell'utente é concettualmente un diverso profilo dandogli una key esplicita. Dividere il Component in due e passare un attribute key dal Component esterno verso quello interno:

<code>ù

    export default function ProfilePage({ userId }) {
    	return <Profile userId={userId} key={userId} />;
    }

    function Profile({ userId }) {
    	// ✅ Questo e ogni altro State sottostante di resetterà al cambio
    	// della key
    	const [comment, setComment] = useState("");
    }

</code>

Normalmente, React preserva lo State quando lo stesso Component viene renderizzato nella stessa posizione. Ma passando userId come key al Component Profile, si sta chiedendo a React di trattare i Components Profile con differenti userId come due differenti Components che non dovrebbero condividere alcuno State. Nel momento in cui la key (impostata alla value di userId) cambia, React ricreerà il DOM e resetterà lo State del Profile Component e quello di tutti i suoi children. Ora il comment field si ripulirà automaticamente quando si navigherà tra profili diversi.

Si noti che in quest'esempio, solo il Component esterno ProfilePage viene esportato ed é visibile agli altri file nel progetto. I Components che renderizzano ProfilePage non hanno bisogno di passare la key a questo: passano userId come una prop regolare. Il fatto che ProfilePage lo passi come key al Component interno Profile é un dettaglio dell'implementazione.

### 30.6. Adjusting some state when a prop changes

A volte, si vorrebbe resettare o aggiustare una parte dello State al cambio di una prop, ma non tutto lo State.

Il Component List riceve una lista di items come prop, e mantiene l'item selezionato nella State variable selection. Si vorrebbe resettare la selection a null se la items prop riceve un Array differente:

<code>

    import { useState, useEffect } from "react";

    function List({ items }) {
    	const [isReverse, setIsReverse] = useState(false);
    	const [selection, setSelection] = useState(null);

    	// 🔴 Evitare: Aggiustare lo State al cambio della prop...
    	// in un Effect
    	useEffect(() => {
    		setSelection(null);
    	}, [items]);
    	// ...
    }

</code>

Anche questo non é l'ideale. Ogni volta che items cambia, la List e i suoi child Components vengono renderizzati con una selection value vecchia come prima cosa. Poi React aggiornerà il DOM ed eseguirà gli Effects. Infine, la chiamata a setSelection(null) causerà un altro re-render della List e dei suoi child Components, ricominciando l'intero processo.

Cominciamo cancellando l'Effect. Invece, aggiustiamo lo State direttamente durante il rendering:

<code>

    function List({ items }) {
    	const [isReverse, setIsReverse] = useState(false);
    	const [selection, setSelection] = useState(null);

    	// Meglio: Aggiustare lo State durante il rendering

    	const [prevItems, setPrevItems] = useState(items);
    	if (items !== prevItems) {
    		setPrevItems(items);
    		setSelection(null);
    	}
    	// ...
    }

</code>

Archiviare le informazioni dal render precedente come questo può essere difficile da comprendere ma é meglio di aggiornare lo stesso State nell'Effect. Nell'esempio sopra riportato, setSelection viene chiamata direttamente durante un render. React renderizzerà di nuovo la List immediatamente dopo di questo con uno statement return. React non ha ancora renderizzato i children di List o aggiornato il DOM, quindi questo permette ai children di List di saltare il rendering con value di selection vecchia.

Quando si aggiona un Component durante il rendering, React manda via il JSX restituito e riprova immediatamente il rendering. Per evitare dei retries molto lenti a cascata, React permette solamente di aggiornare lo stesso State del Component durante un render. Se si aggiorna lo State di un altro Component durante un render, si vedrà un errore. Un condition come items !== prevItems é necessaria per evitare loop. Si può sistemare lo State in questo modo, ma tutti gli altri Side Effects, come cambiare il DOM o impostare i timeout, dovrebbero stare negli Event Handlers o negli Effects per mantenere i Components puri.

Anche se questo pattern é più efficente rispetto ad un Effect, molti Components non hanno bisogno neanche di questo. Non importa come lo si fa, sistemare lo State in base alle prop o ad altro State rende il data flow più difficoltoso da capire e debuggare. Sempre meglio controllare invece se si può resettare tutto lo State con una key o calcolare tutto durante il rendering. Per esempio, invece di archiviare, e resettare, l'item selezionato, si può archiviare l'itemId selezionato:

<code>

    function List({ items }) {
    	const [isReverse, setIsReverse] = useState(false);
    	const [selectedId, setSelectedId] = useState(null);

    	// ✅ Migliore: Calcolare tutto durante il rendering
    	const selection = items.find((item) => item.id === selectedId) ?? null;
    	// ...
    }

</code>

Ora non vi nessun é bisogno di "aggiustare" lo State. Se l'item con il corrispondente selected ID é nella lista, rimane selezionato. Se non lo é, la selection calcolata durante il rendering sarà null perché non vi é alcun item trovato. Questo comportamento é diverso, ma ragguardevolmente migliore perché molti cambiamenti ad items preservano la selezione.

### 30.7. Sharing logic between event handlers

Diciamo di avere una product page con due buttons, Buy e Checkout, ed entrambi ti permettono di comprare tale product. Si vorrebbe mostrare una notifica se lo user inserisse il product nel carrello. Chiamare showNotifications() in entrambi i buttons degli event handlers click sembra ripetitivo quindi si potrebbe essere tentati di mettere questa logica in un Effect:

<code>

    function ProductPage({ product, addToCart }) {

    	// 🔴 Evitare: logica specifica di un event dentro ad un Effect

    	useEffect(() => {
    		if (product.isInCart) {
    			showNotification(`Added ${product.name} to the shopping cart`);
    		}
    	}, [product]);

    	function handleBuyClick() {
    		addToCart(product);
    	}

    	function handleCheckoutClick() {
    		addToCart(product);
    		navigateTo("/checkout");
    	}
    	// ...
    }

</code>

Questo Effect non é necessario. Molto probabilemente causarà bug. Per esempio, diciamo che la nostra App "ricorda" lo shopping cart tra i reload della pagina. Se si aggiunge un product al cart una volta e si ricarica la pagina, la notifica apparirà di nuovo. E continuerà ad apparire ogni volta che si ricaricherà quella product page. Questo perché product.isInCart sarà già true al caricamento della pagina, così l'Effect soprastante chiamerà showNotification().

Quando non si é sicuri se del codice dovrebbe essere in un Effect o in un Event Handler, ci si chieda perché questo codice necessita di essere eseguito. Si usi l'Effect solo per il codice che dovrebbe eseguirsi perché il Component sia visualizzato dall'utente. In questo esempio, la notifica dovrebbe apparire perché lo user preme il button, non perché la page viene visualizzata. Si cancelli l'Effect e si inserisca la logica condivisa in una function chiamata da entrambi gli Event Handlers:

<code>

    function ProductPage({ product, addToCart }) {
    	// ✅ Buono: la logica specifica di un event viene chiamata
    	// dagli event handlers.

    	function buyProduct() {
    		addToCart(product);
    		showNotification(`Added ${product.name} to the shopping cart.`);
    	}

    	function handleBuyClick() {
    		buyProduct();
    	}

    	function handleCheckoutClick() {
    		buyProduct();
    		navigateTo("/checkout");
    	}
    	// ...
    }

</code>

Entrambi questi rimuovono l'Effect non necessario e correggono il bug.

### 30.8. Sending a POST request

Questo Component Form manda due tupi di POST requests. Manda un analytics event quando viene montato. Quando si riempie il Form e si clicka il Submit button, manda un POST request all'endpoint /api/register:

<code>

    import { useState, useEffect } from "react";

    function Form() {
    	const [firstName, setFirstName] = useState("");
    	const [lastName, setLastName] = useState("");

    	// ✅ Buono: Questa logica dovrebbe eseguirsi visto che
    	// il Component é stato visualizzato

    	useEffect(() => {
    		post("analytics/event", { eventName: "visit_form" });
    	}, []);

    	// 🔴 Evitare: Logica specifica di un Event dentro ad un
    	// Effect

    	const [jsonToSubmit, setJsonToSubmit] = useState(null);
    	useEffect(() => {
    		if (joinToSubmit !== null) {
    			post("/api/register", jsonToSubmit);
    		}
    	}, [jsonToSubmit]);

    	function handleSubmit(event) {
    		event.preventDefault();
    		setJsonToSubmit({ firstName, lastName });
    	}

    	// ...
    }

</code>

Applichiamo lo stesso criterio usato nell'esempio precedente.

La POST request dell'analytics dovrebbe rimanere in un Effect. Questo perché la ragione del mandare l'event analytics é che il Form é stato visualizzato, mostrato sul display. Si attiverà due volte in Development.

Comunque, la POST request a /api/register non é causata dal fatto che il Form venga visualizzato. Si vuole mandare la request in uno specifico momento: quando l'utente preme il button. Dovrebbe avvenire solo al momento di quella specifica interazione. Si cancelli il secondo Effect e si inserisca la POST request nell'Event Handler:

<code>

    import { useState, useEffect } from "react";

    function Form() {
    	const [firstName, setFirstName] = useState("");
    	const [lastName, setLastName] = useState("");

    	// ✅ Buono: Questa logica si esegue visto che
    	// il Component é stato visualizzato

    	useEffect(() => {
    		post("analytics/event", { eventName: "visit_form" });
    	}, []);

    	function handleSubmit(event) {
    		event.preventDefault();

    		// ✅ Buono: logica specifica di un Event é nell'Evnet Handler

    		post("/api/register", { firstName, lastName });
    	}

    	// ...
    }

</code>

Quando si sceglie di inserire della logica in un Event Handler o in un Effect, la questione principale alla quale si deve rispondere é quale tipo di logica sia rispetto alla prospettiva dello user. Se questa logica é causata da una particolare interazione, la si mantenga nell'Event Handler. Se é causata dal fatto che lo user sta vedendo il Component nello schermo, allora si resti sull'Effect.

### 30.9. Chains of computations

Alle volte si potrebbe essere tentati di concatenare gli Effect che sistemano un pezzo di State basato su altro State:

<code>

    function Game() {
    	const [card, setCard] = useState(null);
    	const [goldCardCount, setGoldCardCount] = useState(0);
    	const [round, setRound] = useState(1);
    	const [isGameOver, setIsGameOver] = useState(false);

    	// 🔴 Evitare: Concatenare gli Effects che sistemano lo State esclusivamente per attivarsi tra loro

    	useEffect(() => {
    		if (card !== null && card.gold) {
    			setGoldCardCount((c) => c + 1);
    		}
    	}, [card]);

    	useEffect(() => {
    		if (goldCardCount > 3) {
    			setRound((r) => r + 1);
    			setGoldCardCount(0);
    		}
    	}, [goldCardCount]);

    	useEffect(() => {
    		if (round > 5) {
    			setIsGameOver(true);
    		}
    	}, [round]);

    	useEffect(() => {
    		console.log("Good Game");
    	}, [isGameOver]);

    	function handlePlaceCard(nextCard) {
    		if (isGameOver) {
    			throw Error("Game already ended");
    		} else {
    			setCard(nextCard);
    		}
    	}

    	// ...
    }

</code>

Vi sono due problemi in questo codice.

Un problema é che é molto inefficente: il Component (e i suoi children) sono devono essere rerenderizzati tra ogni chiamata alle setter functions nella catena. Nell'esempio soprastante, nel caso peggiore (setCard --> render --> setGoldCardCount --> render --> setRound --> render --> setIsgameOver --> render) vi sono tre rerender non necessari.

Persino se non fosse lenta, mano a mano che il codice si evolve, si incapperebbe in casi dove la "chain" che si ha scritto non corrisponderebbe con le nuove necessità. Si immagini di aggiungere un modo di risalire alla storia delle mosse del gioco. Lo si potrebbe fare aggiornando ogni State variable ad una value nel passato. Comunque, impostando lo State card a una value dal passato attiverebbe la chain di Effects e cambierebbero i dati che si sta mostrando. Tale codice é rigido e fragile.

In questo caso, é meglio calcolare ciò che si può durante il rendering, e sistemare lo State nell'Event Handler:

<code>

    function Game() {
    	const [card, setCard] = useState(null);
    	const [goldCardCount, setGoldCardCount] = useState(0);
    	const [round, setRound] = useState(1);

    	// ✅ Buono: calcolare ciò che si può durante il rendering
    	const isGameOver = round > 5;

    	function handlePlaceCard(nextCard) {
    		throw Error("Game already ended.");
    	}

    	// ✅ Calcolare tutto lo State successivo nell'Event Handler

    	setCard(nextCard);
    	if (nextCard.gold <= 3) {
    		if (goldCardCount(goldCardCount + 1)) {
    			setGoldCardCount(goldCardCount + 1);
    		} else {
    			setGoldCardCount(0);
    			setRound(round + 1);
    			if (round === 5) {
    				console.log("Good game!");
    			}
    		}
    	}

    	// ...
    }

</code>

Questo é molto più efficente. Inoltre, se si implementa un modo per vedere la storia del gioco, ora si sarà in grado di impostare ogni State variable ad una mossa dal passato senza attivare la chain di Effects che aggiusta ogni altra value. Se si ha bisogno di riusare la logica in più handlers, si può estrarre una funzione e chiamarla dentro tali Handlers.

Si ricordi che dentro gli Event Handlers, lo State si comporta come un'istantanea. Per esempio, persino dopo la chiamata a setRound(round + 1), la variabile round rifletterà la value al momento che lo user ha clickato il button. Se si necessita di usare la value successiva per i calcoli, occorre definirla manualmente come const nextRound = round + 1.

In alcuni casi, non si può calcolare lo State successivo direttamente nell'Event Handler. Per esempio, si immagini un form con molteplici dropdown dove le option del successivo dropdown dipendono dalla value selezionata nel precedente dropdown. Qui potrebbe essere appropriata una catena di Effects perché ci si sta sincronizzando con il network.

### 30.10. Initializing the application

Parte della logica dovrebbe eseguirsi solo una volta quando l'App si carica.

Si potrebbe essere tentati di piazzarla in un Effect nel top-level del Component:

<code>

    function InitialApp() {
    	// 🔴 Evitare: Effect con logica che dovrebbe eseguirsi
    	// solo una volta
    	useEffect(() => {
    		loadDataFromLocalStorage();
    		checkAuthToken();
    	}, []);
    }

</code>

In ogni caso, ci si accorgerà velocemente che si eseguirà due volte in Development. Questo può causare errori, per esempio potrebbe invalidare il token dell'autenticazione perchè la funzione non é stata disegnata per essere chiamata due volte. In generale, i Component dovrebbero essere resilienti nell'essere rimontati. Questo include il Component al top level App.jsx.

Anche se potrebbe non essere rimontato nella pratica in Production, seguire gli stessi vincoli in tutti i Components rende più facile muovere e riusare il codice. Se della logica deve essere eseguita una volta quando l'App carica piuttosto che una volta ogni volta che il Component viene montato, si aggiunga una variabile al top level per tracciare se é già stata eseguita:

<code>

    import { useEffect } from "react";

    let didInit = false;

    function InitialApp() {
    	useEffect(() => {
    		if (!didInit) {
    			didInit = true;

    			// ✅ Si esegue una volta quando l'App carica

    			loadDataFromLocalStorage();
    			checkAuthToken();
    		}
    	}, []);
    	// ...
    }

</code>

Si può anche eseguirlo durante l'inizializzazione e prima che l'App renderizzi:

<code>

    if (window !== "undefined") {
    	// controlla se stiamo eseguendo nel browser

    	// ✅ Si esegue una volta per ogni caricamento dell'App
    	loadDataFromLocalStorage();
    	checkAuthToken();
    }

    function App(){
    	// ...
    }

</code>

Il codice al top level si esegue una volta quando il Component viene importato, persino se finisce per non essere renderizzato. Per evitare ralletamenti o comportamenti inaspettati quando importiamo Components arbitrari, conviene non sovrausare questo pattern. Si mantenga la logica di inizializzazione estesa all'App nei root Components dei modules come App.jsx o nell'entry point dell'Applicazione.

### 30.11. Notifyng parent components about state changes

Diciamo di star scrivendo un Component Toggle con uno State interno isOn che può essere true o false. Vi sono diversi modi per eseguire il toggle su questo (non il click o il drag). Si vuole notificare al parent Component se lo State interno di Toggle cambia, quindi esponiamo un event onChange e chiamiamolo dall'Effect:

<code>

    function Toggle({ onChange }) {
    	const [isOn, setIsOn] = useState(false);

    	// 🔴 Evitare: l'handler onChange si esegue troppo tardi
    	useEffect(() => {
    		onChange(isOn);
    	}, [isOn, onChange]);

    	function handleClick() {
    		setIsOn(!isOn);
    	}

    	function handleDragEnd(event) {
    		if (isCloserToRightEdge(event)) {
    			setIsOn(true);
    		} else {
    			setIsOn(false);
    		}
    	}

    	// ...
    }

</code>

Come prima, questo non é l'ideale. Il Component Toggle aggiorna il suo State prima, e React aggiorna lo screen. Poi React esegue l'Effect, che chiama la function onChange passata da un parent Component. Ora il parent Component aggiornerà il proprio State, cominciando un altro passaggio di render. Sarebbe meglio eseguire tutto in un singolo passaggio.

Si cancelli l'Effect e invece si aggiorni lo State di entrambi i Component tramite lo stesso Event Handler:

<code>

    import { useState } from "react";

    function Toggle({ onChange }) {
    	const [isOn, setIsOn] = useState(false);

    	function updateToggle(nextIsOn) {
    		// ✅ Buono: esegue tutti gli aggionamenti durante
    		// l'Event che li ha causati
    		setIsOn(nextIsOn);
    		onChange(nextIsOn);
    	}

    	function handleClick() {
    		updateToggle(!isOn);
    	}

    	function handleDragEnd(event) {
    		if (isCloserToRightEdge(event)) {
    			updateToggle(true);
    		} else {
    			updateToggle(false);
    		}
    	}

    	// ...
    }

</code>

Con questo approccio, sia il Component Toggle che il suo parent Component aggiornano il loro State durante l'Event. React mette in coda aggiornamenti da diversi Components insieme, così ci sarà un solo passaggio del render.

Si potrebbe anche essere in grado di rimuovere lo State tutto insieme, e invece ricevere isOn dal parent Component:

<code>

    // ✅ Buono comunque: il Component é controllato completamente
    // dal suo parent

    function Toggle({ isOn, onChange }) {
    	function handleClick() {
    		onChange(!isOn);
    	}

    	function handleDragEnd(event) {
    		if (isCloserToRightEdge(event)) {
    			onChange(true);
    		} else {
    			onChange(false);
    		}
    	}
    	// ...
    }

</code>

Il Lifting State Up permette al parent Component di controllare completamente il Toggle Component invertendo lo State proprio del parent Component. Questo significa che il parent Component dovrà contenere più logica, ma vi sarà meno State complessivo di cui doversi occupare. In qualunque modo si stia provando a mantenere due diverse State variables sincronizzate, si provi a portare lo State verso l'alto invece.

### 30.11. Passing data to the parent

Questo Child Component esegue il fetch di alcuni dati e poi li passa al parent Component in un Effect:

<code>

    import { useState, useEffect } from "react";

    function Parent() {
    	const [data, setData] = useState(null);

    	return <Child onFetched={setData} />;
    }

    function Child({ onFetched }) {
    	const data = useSomeAPI();

    	// 🔴 Evitare: Passare dati al parent in un Effect

    	useEffect(() => {
    		if (data) {
    			onFetched(data);
    		}
    	}, [onFetched, data]);
    	// ...
    }

</code>

In React, i dati scorrono dai parent Components ai loro children. Quando si vede qualcosa di sbagliato sullo schermo, si può tracciare da dove arriva l'informazione andando verso l'alto nella Components chain fino a che non si trova quale Component passa la prop sbagliata o ha lo State sbagliato. Quando i child Components aggiornano lo State dei loro parents negli Effects, il data flow diventa molto difficile da tracciare. Visto che sia il child che il parent necessitano degli stessi dati, si faccia invece eseguire il fetch dei dati al parent, e poi lo si passi verso il basso al child:

<code>

    function Parent() {
    	const data = useSomeAPI();
    	// ...
    	// ✅ Buono: passare i dati in basso al child
    	return <Child data={data} />;
    }

    function Child({data}) {
    	// ...
    }

</code>

Questo é più semplice e mantiene il data flow prevedibile: i dati scorrono verso il basso dal parent al child.

### 30.12. Subscribing to an external store

A volte, i Components hanno bisogno di sottoscriversi a dei dati fuori dallo State di React. Questi dati potrebbero essere da una library di terze parti o una browser API integrata. Visto che i dati potrebbero cambiare senza che React ne venga a conoscenza. si avrà bisogno di sottoscrivere manualmente tali Components. Questo viene spesso effettuato con un Effect, per esempio:

<code>

    import { useState, useEffect } from "react";

    function useOnlineStatus() {
    	// Non ideale: Sottoscrizione manuale ad un store in
    	// un Effect.

    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		function updateState() {
    			setIsOnline(navigator.online);
    		}

    		updateState();

    		window.addEventListener("online", updateState);
    		window.addEventListener("offline", updateState);
    		return () => {
    			window.removeEventListener("online", updateState);
    			window.removeEventListener("offline", updateState);
    		};
    	}, []);
    	return isOnline;
    }

    function ChatIndicator() {
    	const isOnline = useOnlineStatus();
    	// ...
    }

</code>

Qui, il Component si sottoscrive ad uno store esterno di dati (in questo caso la browser navigator.onLine API). Visto che questa API non esiste sul server (quindi non può essere usata dall'HTML iniziale), inizialmente lo State sarà impostato su true. Quando la value di tale data store cambierà nel browser, il Component aggiornerà il suo State.

Anche se é comune usare gli Effect per questo, React ha un Hook costruito per questo scopo per sottoscriversi ad uno store esterno, che é invece preferibile. Si cancelli l'Effect e lo si sostituisca con una chiamata a useSyncExternalStore:

<code>

    import { useState, useEffect, useSyncExternalStore } from "react";

    function subscribe(callback) {
    	window.addEventListener("online", callback);
    	window.addEventListener("offline", callback);
    	return () => {
    		window.removeEventListener("online", callback);
    		window.removeEventListener("offline", callback);
    	};
    }

    function useOnlineStatus() {
    	// ✅ Buono: sottoscrivere ad uno store esterno con un
    	// Hook integrato

    	return useSyncExternalStore(
    		subscribe, // React non sottoscriverà nuovamente fino
    		// a che non si passerà la stessa funzione
    		() => navigator.onLine, // Come ottenere la value sul client
    		() => true // Come ottenere la value sul server
    	);
    }

    function ChatIndicator() {
    	const isOnline = useOnlineStatus();
    	// ...
    }

</code>

Questo approccio é meno propenso ad errori rispetto al sincronizzare dati mutevoli con lo State di React con un Effect. Tipicamente, si scriverà un Custom Hook come useOnlineStatus() mostrato nella seconda parte dell'esempio, quindi non si dovrà ripetere questo codice nei Components individuali.

Si veda la documentazione relatica al subscribing a store esterni dai Components React:
[https://react.dev/reference/react/useSyncExternalStore](Link)

### 30.13. Fetching data

Molte App usano gli Effects per dare il via al fetch dei dati. E' abbastanza comune scrivere un Effect per il data fetching così:

<code>

    import { useState, useEffect } from "react";

    function SearchResults({ query }) {
    	const [results, setResults] = useState([]);
    	const [page, setPage] = useState(1);

    	useEffect(() => {
    		// 🔴 Evitare: Fetching senza logica di Cleanup
    		fetchResults(query, page).then((json) => {
    			setResults(json);
    		});
    	}, [query, page]);

    	function handleNextPageClick() {
    		setPage(page + 1);
    	}
    	// ...
    }

</code>

Non si ha realmente bisogno di muovere questo fetch in un Event Handler.

Questa sembra essere una contradizione con i precedenti esempi dove si aveva bisogno di inserire la logica dentro gli Evnet Handlers. Comunque, consideriamo che non sia l'evento della digitazione la ragione principale del fetch. I search input sono spesso prepopolati dall'URL, e l'utente potrebbe navigare avanti e indietro senza toccare l'input.

Non importa da dove page e query derivino. Mentre il Component é visibile, si vuole mantenere results sincronizzato con i dati dalla rete per gli attuali page e query. Ecco perché é un Effect.

Comunque il codice soprastante ha un bug. Si immagini di digitare "hello" velocemente. Allora la query cambierà da "h", a "he", "hel", "hell" e "hello". Questo darà il via a fetch separati, ma non vi sono garanzie riguardo a con quale ordine arriveranno le responses. Per esempio, la response ad "hell" potrebbe arrivare dopo la response ad "hello". Visto che si chiamerà setResults alla fine, si visualizzeranno i risultati sbagliati. Questa viene chiamata una "race condition": due differenti requests "fanno a gara" tra loro e arrivano con ordine differente rispetto a quanto ci si potrebbe aspettare.

Per sistemare la race condition, si ha bisogno di aggiungere una Cleanup function per ignorare le responses sterili:

<code>

    function SearchResults({ query }) {
    	const [results, setResults] = useState([]);
    	const [page, setPage] = useState(1);

    	useEffect(() => {
    		let ignore = false;
    		fetchResults(query, page).then((json) => {
    			if (!ignore) {
    				setResults(json);
    			}
    		});
    		return () => {
    			ignore = true;
    		};
    	}, [query, page]);

    	function handleNextPageClick() {
    		setPage(page + 1);
    	}
    	// ...
    }

</code>

Questo assicura che quando l'Effect eseguirà il fetch dei dati, tutte le responses, eccetto l'ultima request, verranno ignorate.

Gestire le race conditions non é l'unica difficoltà con l'implementazione del data fetching. Si potrebbe anche voler pensare al caching delle responses (in modo che lo user possa clickare Back e vedere lo screen precedente istantaneamente), come eseguire il fetch dei dati sul server (in modo che l'HTML renderizzato inizialmente contenga già il content dal fetch invece di uno spinner), e come evitare le network waterfalls (in modo che un child possa eseguire il fetch di altri dati senza dover aspettare ogni parent).

Questi problemi si applicano a tutte le UI Library, non solo a React.js. Risolvere questi problemi non é banale, ed é il motivo per il quale i framework moderni forniscono dei meccanismi per il data fetching dei dati integrati negli Effects.

Se non si vuole usare un framework ( e non si vuole costruirsene uno) ma si vuole rendere il data fetching dagli Effects più ergonomico, si consideri di estrarre la logica del fetching in un Custom Hook come in questo esempio:

<code>

    import { useState, useEffect } from "react";

    function SearchResults({ query }) {
    	const [page, setPage] = useState([]);
    	const params = new URLSearchParams({ query, page });
    	const results = useData(`/api/search${params}`);

    	function handleNextPageClick() {
    		setPage(page + 1);
    	}
    	// ...
    }

    function useData(url) {
    	const [data, setData] = useState(null);
    	useEffect(() => {
    		let ignore = false;
    		fetch(url)
    			.then((response) => response.json)
    			.then((json) => {
    				if (!ignore) {
    					setData(json);
    				}
    			});
    		return () => {
    			ignore = true;
    		};
    	}, [url]);
    	return data;
    }

</code>

Si potrebbe inoltre voler aggiungere della logica per la gestione degli errori e per tracciare se il content si sta caricando. Si può costruire un Hook come questo da soli o usare una delle molte soluzioni già disponibili nell'ecosistema React. Anche se questo da solo non sarà efficente tanto quando l'usare un meccanismo integrato per il fetch dei dati di un framework, muovere la logica dei fetch dei dati in un Custom Hook renderà più facile adottare un'efficente strategia per il data fething in seguito.

In generale, si deve ricorrere a scrivere degli Effects, tenendo un occhio a quando si può estrarre un pezzo di funzionalità in un Custom Hook con un orientamento più declerative costruito per lo scopo simile ad un API come useData sopra illustrato.
Meno grezze saranno le chiamate a useEffect nei Components, più facile sarà mantenere l'App.

### 30.14. Exercises

1-

Prima soluzione:

<code>

    import { useState } from 'react';
    import { initialTodos, createTodo } from './todos.js';

    export default function TodoList() {
    	const [todos, setTodos] = useState(initialTodos);
    	const [showActive, setShowActive] = useState(false);

    	const activeTodos = todos.filter(todo => !todo.completed);
    	const visibleTodos = showActive ? activeTodos : todos;

    	const footer = <footer>
    				{activeTodos.length} todos left
    			</footer>

    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={showActive}
    					onChange={e => setShowActive(e.target.checked)}
    				/>
    				Show only active todos
    			</label>
    			<NewTodo onAdd={newTodo => setTodos([...todos, newTodo])} />
    			<ul>
    				{visibleTodos.map(todo => (
    					<li key={todo.id}>
    						{todo.completed ? <s>{todo.text}</s> : todo.text}
    					</li>
    				))}
    			</ul>
    			{footer}
    		</>
    	);
    }

    function NewTodo({ onAdd }) {
    	const [text, setText] = useState('');

    	function handleAddClick() {
    		setText('');
    		onAdd(createTodo(text));
    	}

    	return (
    		<>
    			<input value={text} onChange={e => setText(e.target.value)} />
    			<button onClick={handleAddClick}>
    				Add
    			</button>
    		</>
    	);
    }

</code>

Seconda soluzione:

<code>

    import { useState } from 'react';
    import { initialTodos, createTodo } from './todos.js';

    export default function TodoList() {
    	const [todos, setTodos] = useState(initialTodos);
    	const [showActive, setShowActive] = useState(false);

    	const activeTodos = todos.filter(todo => !todo.completed);
    	const visibleTodos = showActive ? activeTodos : todos;

    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={showActive}
    					onChange={e => setShowActive(e.target.checked)}
    				/>
    				Show only active todos
    			</label>
    			<NewTodo onAdd={newTodo => setTodos([...todos, newTodo])} />
    			<ul>
    				{visibleTodos.map(todo => (
    					<li key={todo.id}>
    						{todo.completed ? <s>{todo.text}</s> : todo.text}
    					</li>
    				))}
    			</ul>
    			<footer>
    				{activeTodos.length} todos left
    			</footer>
    		</>
    	);
    }

    function NewTodo({ onAdd }) {
    	const [text, setText] = useState('');

    	function handleAddClick() {
    		setText('');
    		onAdd(createTodo(text));
    	}

    	return (
    		<>
    			<input value={text} onChange={e => setText(e.target.value)} />
    			<button onClick={handleAddClick}>
    				Add
    			</button>
    		</>
    	);
    }

</code>

✅ Perfetta seconda soluzione

2-

<code>

    import { useState, useMemo } from 'react';
    import { initialTodos, createTodo, getVisibleTodos } from './todos.js';

    export default function TodoList() {
    	const [todos, setTodos] = useState(initialTodos);
    	const [showActive, setShowActive] = useState(false);
    	const [text, setText] = useState('');
    	const [visibleTodos, setVisibleTodos] = useState([]);

    	useMemo(() => {
    		setVisibleTodos(getVisibleTodos(todos, showActive));
    	}, [todos, showActive])

    	function handleAddClick() {
    		setText('');
    		setTodos([...todos, createTodo(text)]);
    	}

    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={showActive}
    					onChange={e => setShowActive(e.target.checked)}
    				/>
    				Show only active todos
    			</label>
    			<input value={text} onChange={e => setText(e.target.value)} />
    			<button onClick={handleAddClick}>
    				Add
    			</button>
    			<ul>
    				{visibleTodos.map(todo => (
    					<li key={todo.id}>
    						{todo.completed ? <s>{todo.text}</s> : todo.text}
    					</li>
    				))}
    			</ul>
    		</>
    	);
    }

</code>

Corretto ma migliorabile:

<code>

    import { useState, useMemo } from 'react';
    import { initialTodos, createTodo, getVisibleTodos } from './todos.js';

    export default function TodoList() {
    	const [todos, setTodos] = useState(initialTodos);
    	const [showActive, setShowActive] = useState(false);
    	const [text, setText] = useState('');

    	const visibleTodos = useMemo(
    		() =>
    		getVisibleTodos(todos, showActive),
    		[todos, showActive])



    	function handleAddClick() {
    		setText('');
    		setTodos([...todos, createTodo(text)]);
    	}

    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={showActive}
    					onChange={e => setShowActive(e.target.checked)}
    				/>
    				Show only active todos
    			</label>
    			<input value={text} onChange={e => setText(e.target.value)} />
    			<button onClick={handleAddClick}>
    				Add
    			</button>
    			<ul>
    				{visibleTodos.map(todo => (
    					<li key={todo.id}>
    						{todo.completed ? <s>{todo.text}</s> : todo.text}
    					</li>
    				))}
    			</ul>
    		</>
    	);
    }

</code>

Si può rimuovere la State varible visibleTodos e l'Effect ed invece usare una costante visibleTodos con una chiamata a useMemo per salvare nella cache il result della chiamata a getvisibleTodos().
Con questo cambiamento getVisibleTodos() sarà chiamato solo se todos o showActive cambieranno.

3-

Prima soluzione:
Leviamo l'Effect e usiamo una key per rendere ogni section unica. Al cambio si scheda resteranno i dati della precedente, questo problema magari si può risolvere modificando l'Event Handler che avviene al click nel Component parent (non visibile):

 <code>

    import { useState } from 'react';

    export default function EditContact({ savedContact, onSave }) {
    	const [name, setName] = useState(savedContact.name);
    	const [email, setEmail] = useState(savedContact.email);

    	return (
    		<section key={savedContact.id}>
    			<label>
    				Name:{' '}
    				<input
    					type="text"
    					value={name}
    					onChange={e => setName(e.target.value)}
    				/>
    			</label>
    			<label>
    				Email:{' '}
    				<input
    					type="email"
    					value={email}
    					onChange={e => setEmail(e.target.value)}
    				/>
    			</label>
    			<button onClick={() => {
    				const updatedData = {
    					id: savedContact.id,
    					name: name,
    					email: email
    				};
    				onSave(updatedData);
    			}}>
    				Save
    			</button>
    			<button onClick={() => {
    				setName(savedContact.name);
    				setEmail(savedContact.email);
    			}}>
    				Reset
    			</button>
    		</section>
    	);
    }

 </code>

Seconda soluzione:
Aggiungiamo una key per rendere le section uniche e un useMemo per i cambiamenti tra una scheda e l'altra:

 <code>

    import { useState, useMemo } from 'react';

    export default function EditContact({ savedContact, onSave }) {
    	const [name, setName] = useState(savedContact.name);
    	const [email, setEmail] = useState(savedContact.email);

    	useMemo(() => {
    		setName(savedContact.name);
    		setEmail(savedContact.email);
    	}, [savedContact]);

    	return (
    		<section key={savedContact.id}>
    			<label>
    				Name:{' '}
    				<input
    					type="text"
    					value={name}
    					onChange={e => setName(e.target.value)}
    				/>
    			</label>
    			<label>
    				Email:{' '}
    				<input
    					type="email"
    					value={email}
    					onChange={e => setEmail(e.target.value)}
    				/>
    			</label>
    			<button onClick={() => {
    				const updatedData = {
    					id: savedContact.id,
    					name: name,
    					email: email
    				};
    				onSave(updatedData);
    			}}>
    				Save
    			</button>
    			<button onClick={() => {
    				setName(savedContact.name);
    				setEmail(savedContact.email);
    			}}>
    				Reset
    			</button>
    		</section>
    	);
    }

 </code>

Errate entrambe:
Dividere in due il Component EditContact. Si muova tutto lo State del Form nel Component interno EditForm. Si esporti l'esterno Editcontact Component e si passi savedContact.id come key all'istanza del Component EditFrom al suo interno non dimenticando le props, quindi con key={props.savedContact.id}.

Come risultato tutto lo State del form verrà resettato e ricreerà il DOM se si selezionerà un diverso contact:

 <code>

    import { useState } from 'react';

    export default function EditContact(props) {
    	return (
    		<EditForm
    			{...props}
    			key={props.savedContact.id}
    		/>
    	);
    }

    function EditForm({ savedContact, onSave }) {
    	const [name, setName] = useState(savedContact.name);
    	const [email, setEmail] = useState(savedContact.email);

    	return (
    		<section>
    			<label>
    				Name:{' '}
    				<input
    					type="text"
    					value={name}
    					onChange={e => setName(e.target.value)}
    				/>
    			</label>
    			<label>
    				Email:{' '}
    				<input
    					type="email"
    					value={email}
    					onChange={e => setEmail(e.target.value)}
    				/>
    			</label>
    			<button onClick={() => {
    				const updatedData = {
    					id: savedContact.id,
    					name: name,
    					email: email
    				};
    				onSave(updatedData);
    			}}>
    				Save
    			</button>
    			<button onClick={() => {
    				setName(savedContact.name);
    				setEmail(savedContact.email);
    			}}>
    				Reset
    			</button>
    		</section>
    	);
    }

 </code>

4- Il problema era causato all'Effect. Occorre pensare che il message dev'essere mandato solo quando lo user click su submit, non solo perché vede il Form. Quindi il sendMessage va inserito nell'Event Handler per il submit handleSubmit:

<code>

    import { useState} from 'react';

    export default function Form() {
    	const [showForm, setShowForm] = useState(true);
    	const [message, setMessage] = useState('');


    	function handleSubmit(e) {
    		e.preventDefault();
    		sendMessage(message);
    		setShowForm(false);
    	}

    	if (!showForm) {
    		return (
    			<>
    				<h1>Thanks for using our services!</h1>
    				<button onClick={() => {
    					setMessage('');
    					setShowForm(true);
    				}}>
    					Open chat
    				</button>
    			</>
    		);
    	}

    	return (
    		<form onSubmit={handleSubmit}>
    			<textarea
    				placeholder="Message"
    				value={message}
    				onChange={e => setMessage(e.target.value)}
    			/>
    			<button type="submit" disabled={message === ''}>
    				Send
    			</button>
    		</form>
    	);
    }

    function sendMessage(message) {
    	console.log('Sending message: ' + message);
    }

</code>

✅ Perfetto

## 31. Lifecycle of Reactive Effects

Gli Effects hanno un ciclo di vita diverso dai Components. I Components possono essere montati, aggiornati o smontati. Un Effect può fare solo due cose: cominciare a sincronizzare qualcosa e poi fermarsi dal sincronizzarlo.
Questo ciclo può cominciare molteplici volte se l'Effect dipende dalle prop e dallo State che cambia nel tempo. React fornisce una linter rule per controllare se si sono specificate le Dependencies dell'Effect correttamente. Questo mantiene l'Effect sincronizzato alle ultime props e State.

### 31.1. The lifecycle of an Effect

Ogni Component React passa attraverso lo stesso ciclo di vita:

• Un Component viene montato quando viene aggiunto allo screen.
• Un Component si aggiorna quando riceve delle nuove prop o del nuovo State, di solito in risposta ad un'interazione.
• Un Component viene smontato quando viene rimosso dallo screen.

E' un buon modo di pensare ai Components, ma non agli Effects. Invece, si provi a pensare agli Effects indipendentemente dal ciclo di vita del Component. Un Effect descrive come sincronizzare un sistema esterno alle correnti props e State. Come il codice cambia, la sincronizzazione avrà bisogno di avvenire più o meno spesso.

Per illustrare questo punto, si consideri questo Effect che connette il Component ad un server di una chat:

<code>

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);
    	// ...
    }

</code>

Il body dell'Effect specifica come cominciare a sincronizzare:

<code>

// ...

    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
    		connection.disconnect();
    	};

// ...

</code>

La Cleanup Function restituita dall'Effect specifica come fermare la sincronizzazione:

<code>

    return () => {
    			connection.disconnect();
    		};

</code>

Intuitivamente, si potrebbe pensare che React dovrebbe cominciare a sincronizzare quando il Component viene montato e si ferma da sincronizzare quando il Component viene smontato. Comunque, non é quella la fine. A volte potrebbe essere necessario cominciare a sincronizzare e fermarsi molteplici volte mentre il Component rimane smontato.

Vediamo perché questo é necessario, perché accade e come possiamo controllare questo comportamento.

Nota: Alcuni Effects non restituiscono affato una Cleanup function. Più spesso si vorrà restituirne una - ma se non lo si farà, React si comporterà come se restituissimo una Cleanup function empty.

### 31.2. Why synchronization may need to happen more than once

Si immagini che questo Component ChatRoom riceva una prop roomId che l'utente prende in un dropdown menu. Diciamo che inizialmente lo user prenda la room "general" come roomId. La tua app mostrerà la chat room "general":

<code>

    	const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) { // <--- "general"

    	// ...

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Dopo che la UI viene visualizzata, React eseguirà l'Effect per cominciare a sincronizzarsi. Si connetterà con la room "general":

<code>

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) { // <--- "general"
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		// <--- Si connette alla room "general"
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Più tardi, l'utente sceglie una room differente dal dropdown menu (per esempio "travel"). Prima, React aggiornerà la UI:

<code>

    	const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) { // <--- "travel"

    	// ...

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Si pensi ora a cosa accadrà dopo. Lo user vede che "travel" é la chat room selezionata. Comunque, l'Effect che si é eseguito l'ultima volta é ancora connesso alla room "general". La prop "roomId" é stata cambiata, quindi ciò che l'Effect avrà fatto (connettersi con la room "general") non incontrerà più la UI.

A questo punto, si vuole che React faccia due cose:

1. Si fermi dal sincronizzarsi con il vecchio roomId (disconnettersi dalla room "general")

2. Cominci a sincronizzarsi con il nuovo roomId (connettersi con la room "travel")

Fortunatamente, si é già detto a React come fare entrambe queste cose. Il body dell'Effect specifica come cominciare la sincronizzazion, e la Cleanup function specifica come invece fermarla. Tutto ciò che React ha bisogno di fare é chiamarli nel corretto ordine e con le corrette props e State. Vediamo come avviene esattamente.

### 31.3. How React re-synchronizes your Effect

Ricordiamo che il Component ChatRoom ha ricevuto una nuova value che la sua roomId prop. Prima era "general" ora é "travel". React necessita di risincronizzare gli Effects per riconnettersi con una diversa room.

Per fermare la sincronizzazione, React chiamerà la Cleanup function che l'Effect restituisce dopo essersi connessa con la "general" room. Visto che "roomId" era "general", la Cleanup function di disconnetterà dalla room "general":

<code>

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) { // <--- "general"
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		// <--- Si connette alla room "general"
    		connection.connect();
    		return () => {
    			connection.disconnect(); // <--- si disconnette dalla room "general"
    		};
    	}, [roomId]);

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Poi React eseguirà l'Effect che si ha fornito durante questo render. Questa volta, roomId é "travel" quindi comincerà a sincronizzarsi alla chat room "travel" (fino a che anche la sua Cleanup function non verrà anch'essa chiamata):

<code>

    function ChatRoom({ roomId }) { // <--- "travel"
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		// <--- Si connette alla room "travel"
    		connection.connect();

    		// ...

    	}
    }

</code>

Grazie a questo, si sarà ora connessi alla stessa room che lo user ha scelto nella UI, disastro scongiurato.

Ogni volta dopo che il Component si re-renderizza con un diverso roomId, l'Effect si risincronizzerà. Per esempio, diciamo che lo user cambia roomId da "travel" a "music". React fermerà nuovamente la sincronizzazione dell'Effect chiamando la sua Cleanup function (disconnettendo dalla room "travel"). Poi comincerà a sincronizzarsi nuovamente eseguendo il suo body con la nuova prop roomId (connettendosi alla room "music").

Finalmente, quando lo user si sposta in uno screen differente non vi é bisogno di restare connesso con nulla. React fermerà la sincronizzazione dell'Effect un'ultima volta e disconnettendo dalla chat room "music".

### 31.4. Thinking from the Effect's perspective

Ricapitoliamo tutto ciò che accade dalla prospettiva del Component ChatRoom:

1. ChatRoom viene montato con roomId impostato a "general"
2. ChatRoom viene aggiornato con roomId impostato a "travel"
3. ChatRoom viene aggiornato con roomId impostato a "music"
4. ChatRoom viene smontato.

Durante ognuno di questo punti nel ciclo di vita di un Component, l'Effect compie diverse cose:

1. L'Effect viene connesso con la room "general"
2. L'Effect viene disconnesso dalla room "general" e connesso con la room "travel"
3. L'Effect viene disconnesso dalla room "travel" e connesso con la room "music"
4. L'Effect viene disconnesso dalla room "music".

Ora pensiamo a cosa accade dalla prospettiva dell'Effect stesso:

<code>

    useEffect(() => {
    		// L'Effect viene connesso alla room specificata con il roomId...
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			// ...fino a che non viene disconnesso
    			connection.disconnect();
    		};
    	}, [roomId]);

</code>

Questa struttura potrebbe ispirare per vedere cosa accade come una sequenza di periodi di tempo non sovrapponibili:

1. L'Effect viene connesso con la room "general", fino a quando non viene disconnesso
2. L'Effect viene connesso alla room "travel", fino a quando non viene disconnesso
3. L'Effect viene connesso alla room "music" fino a quando non viene disconnesso.

Precedentemente, pensavamo dalla prospettiva del Component. Quando si sta guardando dalla prospettiva di un Component, si é tentati di pensare agli Effects come a delle "callback" o "events del ciclo di vita" che si attivano in uno specifico momento come "dopo un render" o "prima di venire smontato". Questo modo di pensare diviene complicato in fretta, meglio evitarlo.

Invece, ci si concentri sempre su un singolo ciclo di start e stop per volta. Non dovrebbe importare se un Component viene montato, aggiornato o smontato. Tutto ciò che occorre fare é descrivere come cominciare la sincronizzazione e come fermarla. Se lo si fa al meglio, l'Effect sarà resiliente all'essere avviato e fermato tutte le volte che sarà necessario.

Questo dovrebbe far ricordare come non pensare se un Component viene montato o aggiornato quando si scrive la logica di render che crea il JSX. Si descrive ciò che dovrebbe essere sullo screen, e React figura il resto.

### 31.5. How React verifies that your Effect can re-synchronize

Ecco un esempio. Si prema "Open chat" per montare il Component ChatRoom:

<code>

chat.js

    export function createConnection(serverUrl, roomId) {
    	// Una reale implementazione connetterebbe al server
    	return {
    		connect() {
    			console.log(
    				'✅ Connecting to "' + roomId + '" room at ' + serverUrl + "..."
    			);
    		},
    		disconnect() {
    			console.log('❌ Disconnected from "' + roomId + '" room at ' + serverUrl);
    		}
    	};
    }

ChatRoomContainer.jsx

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);
    	return <h1>Welcome to the {roomId} room!</h1>;
    }

    export default function ChatRoomContainer() {
    	const [roomId, setRoomId] = useState("general");
    	const [show, setShow] = useState(false);
    	return (
    		<>
    			<label>
    				Choose the chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<button onClick={() => setShow(!show)}>
    				{show ? "Close Chat" : "Open Chat"}
    			</button>
    			{show && <hr />}
    			{show && <ChatRoom roomId={roomId} />}
    		</>
    	);
    }

</code>

Si noti che quando il Component viene montato per la prima volta, si vedranno tre log:

1. ✅ Connecting to "general" room at https://localhost:1234... - solo in Development
2. ❌ Disconnected from "general" room at https://localhost:1234.
   solo in Development
3. ✅ Connecting to "general" room at https://localhost:1234...

I primi due log sono Development-only. In fase di Development, React rimonta con Component una volta.

React verifica che l'Effect possa risincronizzarsi forzandolo a farlo immediatamente in Development. Questo potrebbe ricordare il gesto di aprire una porta e richiuderla per controllare se si chiude correttamente. React avvia e ferma l'Effect una volta in più in Development per controllare se si ha implementato la fase di Cleanup correttamente.

La ragione principale per la quale l'Effect sarà risincronizzato in pratica é per controllare se i dati che usa vengono cambiati. Nell'esempio sopra illustrato, cambia la chat room selezionata. Si noti come, quando roomId cambia, l'Effect si risincronizzi.

Comunque, vi sono anche casi inusuali dove la risincronizzazione é necessaria. Per esempio, si provi a editare la serverUrl mentre la chat é aperta. Si noti che l'Effect si risincronizza in risposta al cambio appena effettuato. In futuro, React potrebbe aggiungere più features per relazionarsi alla risincronizzazione.

### 31.6. How React knows that it needs to re-synchronize the Effect

Ci si starà chiedendo come React sa che l'Effect necessita si essere risincronizzato dopo che roomId cambia. Avviene perché si ha detto a React che il codice dipende da roomId includendolo nella lista delle dependencies:

<code>

    function ChatRoom({ roomId }) {
    	// <--- La prop roomId potrebbe cambiare nel tempo
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		// <--- questo Effect legge roomId
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);
    	// <--- quindo si dice a React che questo Effect "dipende da" roomId
    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Ecco come funziona:

1. Si sa che roomId é una prop, che significa che può cambiare nel tempo
2. Si sa che l'Effect legge roomdId (quindi la sua logica dipende da una value che può cambiare più avanti)
3. Ecco perché la si specifica come Dependency dell'Effect (in modo che venga risincronizzato al cambio roomId).

Ogni volta che il Component si re-renderizza, React osserverà l'Array di Dependency che é stato passato. Se una delle values nell'Array é differente dalla value nello stesso posto in cui la si é passata nel render precedente, React risincronizzerà l'Effect.

Per esempio, se si fosse passato ["general"] nel render iniziale e poi si passasse ["travel"] durante il render successivo, React comparerà "general" e "travel". Queste sono values differenti (comparate tramite Object.is), quindi React risincronizzerà l'Effect. D'altro canto, se il Component viene re-renderizzato ma roomId non é cambiato, l'Effect rimarrà connesso con la stessa room.

### 31.7. Each Effect represents a separate synchronization process

Meglio non aggiungere logica non relazionata con l'Effect solo perché questa logica ha bisogno di eseguirsi nello stesso momento di un Effect già scritto. Per esempio, diciamo di voler mandare un event analytics quando l'utente visita la room. Si ha già un Effect che dipende da roomId, quindi si potrebbe essere tentati di aggiungere la chiamata all'analytics qui:

<code>

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		// --->
    		logVisit(roomId);
    		// <---
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);
    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Ma immaginiamo che in seguito si aggiunga un'altra dependency a quest'Effect che necessita di ristabilire la connessione. Se quest'Effect viene risincronizzato, chiamerà anche
logVisit(roomId) per la stessa room, che non é ciò che si vuole. Si esegua il log delle visite in un processo separato dalla connessione. Si scrivano piuttosto come due Effects separati:

<code>

    function ChatRoom({ roomId }) {

    	useEffect(() => {
    		logVisit(roomId);
    	}, [roomId]);

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);
    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Ogni Effect nel codice dovrebbe rappresentare un processo di sincronizzazione separato ed indipendente.

Nell'esempio soprastante, cancellare un Effect non romperà la logica dell'altro Effect. Questa é una buona indicazione che sincronizzano due cose differenti, quindi ha senso dividerle. D'altro canto, se si divide della logica coesiva in Effects separati, il codice potrebbe sembrare più "pulito", ma sarebbe più difficile da mantenere. Ecco perché si dovrebbe pensare se i processi sono i medesimi o separati, non se il codice si mostra più pulito.

### 31.8. Effects "react" to reactive rules

L'Effect legge due variabili (serverUrl e roomId), ma solo una viene specificata come dependency, roomId:

<code>

function ChatRoom({ roomId }) {

    useEffect(() => {
    	// --->
    	const connection = createConnection(serverUrl, roomId);
    	// <---
    	connection.connect();
    	return () => {
    		connection.disconnect();
    	};
    }, [roomId]);
    return <h1>Welcome to the {roomId} room!</h1>;

}

</code>

Perché serverUrl non ha bisogno di essere una dependency?

Perché serverUrl non cambia mai durante un re-render. E' sempre la stessa non importa quante volte il Component venga rerenderizzato e perché. Visto che serverUrl non cambia mai, non avrebbe senso specificarla come dependency. Dopo tutto, le dependencies fanno qualcosa solo quando cambiano nel tempo.

D'altro canto, roomId potrebbe essere diversa al rerender. Le props, lo State e altre value dichiarate dentro il Component sono "reactive" perché vengono calcolate durante il rendering e partecipano al data flow di React.

Se serverUrl fosse stata una State variable, sarebbe stata reactive. Le values Reactive devono essere incluse come dependencies:

<code>

    function ChatRoom({ roomId }) {
    	// <--- le Prop cambiano nel tempo

    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");
    	// <--- lo State potrebbe cambiare nel tempo

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		// <--- l'Effect legge Props e State

    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId, serverUrl]);
    	// <--- quindi si dirà a React che quest'Effect "dipende da"...
    	// Props e State

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

Includendo serverUrl come una dependency, ci si assicura che l'Effect si risincronizzi in caso cambi.

Si provi a cambiare la chat room selezionata o editare l'URL del server in quest'esempio:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId, serverUrl]);

    	return (
    		<>
    			<label>
    				Server URL:{" "}
    				<input
    					value={serverUrl}
    					onChange={(event) => setServerUrl(event.target.value)}
    				/>
    			</label>
    			<h1>Welcome to the {roomId} room!</h1>
    		</>
    	);
    }

    export default function ChatRoomContainer() {
    	const [roomId, setRoomId] = useState("general");
    	return (
    		<>
    			<label>
    				Choose the chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<hr />
    			<ChatRoom roomId={roomId} />
    		</>
    	);
    }

</code>

In qualunque momento di cambi un value Reactive come roomId o serverUrl, l'Effect si riconnetterà al server della chat.

### 31.9. What an Effect with empty dependencies means

Cosa accadrebbe se muovessimo sia serverUrl che roomId fuori dal Component?

<code>

    const serverUrl = "https://localhost:1234";
    const roomId = "general";

    function ChatRoom() {

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, []); // ✅ Tutte le Dependencies dichiarate

    	return (
    		// ...)}

</code>

Ora il codice dell'Effect non usa alcuna value reactive, quindi il suo Dependency Array può essere vuoto [].

Pensando dalla prospettiva di un Component, l'Array delle Dependency vuoto [] significa che quest'Effect si connette alla room della chat solo quando il Component viene montato, e si disconnette solo quando il Component viene smontato. Si tenga a mente che React risincronizzerà ancora una volta in più in Development come stress-test sulla logica.

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";
    const roomId = "general";

    function ChatRoom() {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, []);

    	return (
    		<>
    			<h1>Welcome to the {roomId} room!</h1>
    		</>
    	);
    }

    export default function ChatRoomContainer() {
    	const [show, setShow] = useState(false);
    	return (
    		<>
    			<button onClick={() => setShow(!show)}>
    				{show ? "Close chat" : "Open chat"}
    			</button>
    			{show && <hr />}
    			{show && <ChatRoom />}
    		</>
    	);
    }

</code>

Comunque se si pensa dalla prospettiva di un Effect, non si ha bisogno di pensare a quando viene montato e smontato. Ciò che é importante é che sia specificato cosa fa l'Effect per iniziare e finire la sincronizzazione. Oggi, non ha reactive dependencies. Ma se mai si volesse integrare la possibilità di far cambiare roomId o serverUrl nel tempo (diventando così reactive), il codice dell'Effect non cambierebbe. Occorrerebbe solamente aggiungere le values come dependencies.

### 31.10. All variables declared in the component body be reactive

Le Props e lo State non sono le uniche values reactive. Le values che possono essere calcolate da queste sono anch'esse reactive. Se le Props o lo State cambiassero, il Component attiverebbe un re-render, e le value calcolate da queste cambierebbero a loro volta. Questo é il motivo per il quale tutte le variables dal body del Component usate dall'Effect dovrebbero essere nella dependency list dell'Effect.

Diciamo che lo user possa sceglie un server di una chat in un dropdown menu, ma si possa configurare un server di default in settings. Supponiamo di aver già inserito lo State settings in un context così si leggerà settings da tale context. Ora si calcola la serverUrl in base al server selezionato dalle prop e al server di default:

<code>

    function ChatRoom({ roomId, selectedServerUrl }) {
    	// roomId é reactive
    	const settings = useContext(SettingContext);
    	// settings é reactive
    	const serverUrl = selectedServerUrl ?? settings.defaultServerUrl;
    	// serverUrl é reactive
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		// <--- l'Effect legge roomId e serverUrl
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId, serverUrl]);
    	// <--- l'Effect quindi ha bisogno di risincronizzare quando una di queste cambia

    	return (
    		<>
    			<h1>Welcome to the {roomId} room!</h1>
    		</>
    	);
    }

</code>

In quest'esempio, serverUrl non é una prop o una State variable. E' una variabile regolare che si calcola durante il rendering. Ma viene calcolata durante il rendering, quindi potrebbe cambiare con un re-render. Ecco perché e reactive.

Tutte le values dentro al Component (incluse le props, lo State e tutte le variabili nel body del Component) sono Reactive. Ogni value reactive può cambiare al re-render quindi si avrà bisogno di includere le Reactive Values come Dependency dell'Effect.

In altre parole, gli Effect "reagiscono" a tutte le values dal body del Component.

### 31.11. Can global or mutable values be dependencies?

Le mutable values (incluse le global variables) non sono reactive.

Una Mutable Value come location.pathname non può essere una dependency. E' mutevole, quindi può cambiare in ogni momento completamente fuori dal data flow del rendering di React. Cambiarla non attiverà un re-rendering del Component. Inoltre, persino se venisse specificata nelle Dependencies, React non saprebbe di risincronizzare l'Effect al momento del cambio. Questo inoltre rompe le regole di React perché le perché leggendo dei dati mutevoli durante il rendering (che é quando si calcolano le dependency) rompe la purezza del rendering. Invece, si dovrebbe leggere o subscribe a una value mutevole con useSyncExternalStore.

Inoltre una value mutevole come ref.current, o cose che si possono leggere da questa, non può essere una dependency.
Il ref object restituito da useRef stesso può essere una Dependency, ma la sua property current é mutevole intenzionalmente. Permette di tenere traccia di qualcosa senza attivare un re-render. Ma visto che cambiandola non si attiva un re-render, non é una value reactive, e React non saprà di rieseguire l'Effect quando cambia.

Come apprenderemo, un linter controllerà questi problemi automaticamente.

### 31.12. React verifies that you specified every reactive value as a dependency

Se il linter é configurato per React, controllerà che ogni value reactive usata dal codice dell'Effect venga dichiarata come sua dependency. Per esempio, questo é un lint error perché sia roomId che serverUrl sono reactive:

<code>

    function ChatRoom({ roomId }) {
    	// roomId é reactive
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");
    	// serverUrl é reactive
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, []);
    	// <--- qualcosa non va qui
    }

</code>

Questo potrebbe sembrare un errore di React, ma React sta puntando realmente ad un bug nel codice. Sia roomId che serverUrl potrebbero cambiare nel tempo, ma ci si dimenticherà di risincronizzare l'Effect quando cambieranno. Si rimarrà connessi all'iniziale roomId e serverUrl persino che lo user scegliesse delle values differenti nella UI.

Per sistemare questo bug, si segua il consiglio del linter di specificare roomId e serverUrl come dependencies dell'Effect:

<code>

    function ChatRoom({ roomId }) {
    	// roomId é reactive
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");
    	// serverUrl é reactive
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId, serverUrl]);
    	// <--- tutte le Dependencies dichiarate
    }

</code>

Si provi questa correzione. L'errore del linter se n'é andato e la chat si riconnette quando necessario.

Nota:
In alcuni casi, React sa che una value non cambia mai anche se é stata dichiarata all'interno del Component. Per esempio, la setter function restituita da useState ed il ref object restituito da useRef sono stabili (stable) - garantiscono che non cambieranno al re-render. Le Stable Values non sono Reactive, quindi si possono omettere dalla lista. Includerle é permesso: non cambieranno quindi non importa.

### 31.13. What to do when you don't want to re-synchronize

Nell'esempio precedente, si é sistemato un error del lint elencando roomId e serverUrl come dependencies.

Comunque, si può "provare" al linter che queste values non sono reactive values, cioé non possono cambiare come risultato di un re-render. Per esempio, se serverUrl e roomId non dipendono dal rendering e hanno sempre le stessa values, si possono muovere fuori dal Component. Ora non necessiteranno di essere dependencies:

<code>

    function ChatRoom() {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, []); // ✅ Tutte le dependencies dichiarate

    		return (
    			// ...
    		) }

</code>

Si possono anche muovere dentro all'Effect. Non sono calcolate durante il rendering, quindi non sono reactive:

<code>

    function ChatRoom() {
    	useEffect(() => {
    		const serverUrl = "https://localhost:1234"; // serverUrl non é reactive
    		const roomId = "general"; // roomId non é reactive
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, []); // ✅ Tutte le dependencies dichiarate
    }

</code>

Gli Effects sono blocchi di codice reactive. Si risincronizzano quando le values che si leggono dentro ad esse cambiano. A differenza degli Event, che si eseguono solo per interazione, gli Effects si eseguono quando la sincronizzazione é necessaria.

Non si possono "scegliere" le dependencies. Le dependencies devono includere ogni value reactive che si legge nell'Effect. Il linter forza questo. Alle volte ri-sincronizzare troppo spesso potrebbe portare a problemi come loop infiniti nell'Effect. Non si sistemino questo problemi sopprimendo il linter. Ecco cosa fare invece:

• **Controllare che l'Effect rappresenti un processo di sincronizzazione indipendente**.
Se l'Effect non sincronizza nulla, potrebbe essere non necessario. Se sincronizza varie cose indipendenti, le si dividano.

• **Se si vuole leggere l'ultima value delle prop o dello State senza "reagire" (reacting) a questi e resincronizzare l'Effect**, si può dividere l'Effect in una parte reactive (che si manterrà nell'Effect) e una parte non reactive (che si estrarrà in qualcosa chiamato un Effect Event). Vedi prossimo capitolo.

• **Evitare di relazionarsi con object e functions come dependencies**. Se si creano objects e funzioni durante il rendering e poi li si leggono da un Effect, saranno differenti ad ogni render. Questo causerà la risincronizzazione dell'Effect ogni volta. Vedi capitolo Removing unnecessary dependencies from Effects.

Nota:
Il linter é un amico, ma i suoi poteri sono limitati. Il linter sa solamente quando le dependencies sono errate. Non conosce il modo migliore per risolvere ogni caso. Se il linter suggerisce una dependency, ma aggiungendola si causa un loop, non significa che il linter dovrebbe essere ignorato. Si ha bisogno di cambiare il codice all'interno o all'esterno dell'Effect così che quella value non sia più reactive e non se ne necessiti più come dependency.

Se si ha del codebase esistente, si potrebbe avere degli Effects che sopprimono così il linter:

<code>

    useEffect(() => {
    	// ...
    	// 🔴 Evitare di sopprimere il linter in questo modo:
    	// eslint-ignore-next-line react-hooks/exhaustive-deps
    }, [])

</code>

Nelle prossime pagine, si vedrà come sistemare questo codice senza rompere le regole. Vale la pena sistemarlo.

### 31.14. Exercises

1- Così l'Effect verrà risincronizzato ad ogni render, quindi ad ogni modifica dell'input. Occorre un Dependency Array con roomId come dependency:

<code>

    import { useState, useEffect } from 'react';
    import { createConnection } from './chat.js';

    const serverUrl = 'https://localhost:1234';

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState('');

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]);

    	return (
    		<>
    			<h1>Welcome to the {roomId} room!</h1>
    			<input
    				value={message}
    				onChange={e => setMessage(e.target.value)}
    			/>
    		</>
    	);
    }

    export default function App() {
    	const [roomId, setRoomId] = useState('general');
    	return (
    		<>
    			<label>
    				Choose the chat room:{' '}
    				<select
    					value={roomId}
    					onChange={e => setRoomId(e.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<hr />
    			<ChatRoom roomId={roomId} />
    		</>
    	);
    }

</code>

✅ Perfetto

2-

<code>

    import { useState, useEffect } from 'react';

    export default function App() {
    	const [position, setPosition] = useState({ x: 0, y: 0 });
    	const [canMove, setCanMove] = useState(true);

    	useEffect(() => {
    		function handleMove(e) {
    			setPosition({ x: e.clientX, y: e.clientY });
    		}
    		if(canMove){
    			window.addEventListener('pointermove', handleMove);
    			return () => window.removeEventListener('pointermove', handleMove);
    		}
    	}, [canMove]);

    	return (
    		<>
    			<label>
    				<input type="checkbox"
    					checked={canMove}
    					onChange={e => setCanMove(e.target.checked)}
    				/>
    				The dot is allowed to move
    			</label>
    			<hr />
    			<div style={{
    				position: 'absolute',
    				backgroundColor: 'pink',
    				borderRadius: '50%',
    				opacity: 0.6,
    				transform: `translate(${position.x}px, ${position.y}px)`,
    				pointerEvents: 'none',
    				left: -20,
    				top: -20,
    				width: 40,
    				height: 40,
    			}} />
    		</>
    	);
    }

</code>

✅ Perfetto

Alternativa:

<code>

    ...
    function handleMove(e) {
    			if (canMove) {
    				setPosition({ x: e.clientX, y: e.clientY });
    			}
    		}
    ...

</code>

3-

Rimuovere commento, viene letto da linter.
// eslint-disable-next-line react-hooks/exhaustive-deps

<code>

    	import { useState, useEffect } from 'react';

    	export default function App() {
    		const [position, setPosition] = useState({ x: 0, y: 0 });
    		const [canMove, setCanMove] = useState(true);

    		useEffect(() => {
    			function handleMove(e) {
    			if (canMove) {
    				setPosition({ x: e.clientX, y: e.clientY });
    			}
    		}
    			window.addEventListener('pointermove', handleMove);
    			return () => window.removeEventListener('pointermove', handleMove);
    		}, [canMove]);

    		return (
    			<>
    				<label>
    					<input type="checkbox"
    						checked={canMove}
    						onChange={e => setCanMove(e.target.checked)}
    					/>
    					The dot is allowed to move
    				</label>
    				<hr />
    				<div style={{
    					position: 'absolute',
    					backgroundColor: 'pink',
    					borderRadius: '50%',
    					opacity: 0.6,
    					transform: `translate(${position.x}px, ${position.y}px)`,
    					pointerEvents: 'none',
    					left: -20,
    					top: -20,
    					width: 40,
    					height: 40,
    				}} />
    			</>
    		);
    	}

</code>

✅ Perfetto

4- Partire dall'eliminare commenti come:
// eslint-disable-next-line react-hooks/exhaustive-deps

Ora si rileverà che si necessita della dependency createConnection. Aggiungendola all'Array si risolverà il bug:

<code>

    import { useState, useEffect } from 'react';

    export default function ChatRoom({ roomId, createConnection }) {
    	useEffect(() => {
    		const connection = createConnection(roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId, createConnection]);

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

✅ Perfetto
Soluzione alternativa capibile con prossimo capitolo:

<code>

    import { useState, useEffect } from 'react';
    import {
    	createEncryptedConnection,
    	createUnencryptedConnection,
    } from './chat.js';

    export default function ChatRoom({ roomId, isEncrypted }) {
    	useEffect(() => {
    		const createConnection = isEncrypted ?
    			createEncryptedConnection :
    			createUnencryptedConnection;
    		const connection = createConnection(roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId, isEncrypted]);

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

5-

<code>

    import { useState, useEffect } from 'react';
    import { fetchData } from './api.js';

    export default function Page() {
    	const [planetList, setPlanetList] = useState([])
    	const [planetId, setPlanetId] = useState('');

    	const [placeList, setPlaceList] = useState([]);
    	const [placeId, setPlaceId] = useState('');

    	useEffect(() => {
    		let ignore = false;
    		fetchData('/planets').then(result => {
    			if (!ignore) {
    				console.log('Fetched a list of planets.');
    				setPlanetList(result);
    				setPlanetId(result[0].id);
    			}
    		});
    		return () => {
    			ignore = true;
    		}
    	}, []);

    	useEffect(() => {
    		let ignore = false;
    		if(planetId && !ignore){
    			fetchData("/planets/" + planetId + "/places").then((res) => {
    			setPlaceList(res);
    			setPlaceId(res[0].id)
    		})
    		}
    		return () => {
    			ignore = true;
    		}
    	}, [planetId])


    	return (
    		<>
    			<label>
    				Pick a planet:{' '}
    				<select value={planetId} onChange={e => {
    					setPlanetId(e.target.value);
    				}}>
    					{planetList.map(planet =>
    						<option key={planet.id} value={planet.id}>{planet.name}</option>
    					)}
    				</select>
    			</label>
    			<label>
    				Pick a place:{' '}
    				<select value={placeId} onChange={e => {
    					setPlaceId(e.target.value);
    				}}>
    					{placeList.map(place =>
    						<option key={place.id} value={place.id}>{place.name}</option>
    					)}
    				</select>
    			</label>
    			<hr />
    			<p>You are going to: {placeId || '???'} on {planetId || '???'} </p>
    		</>
    	);
    }

</code>

✅ Corretta, non perfetta. Molto simile.

## 32. Separating Events from Effects

Gli Event Handlers si rieseguono solo quando si performa la stessa interazione nuovamente. A differenza degli Event Handlers, gli Effects si risincronizzano se qualche value che leggono, come prop o State variable, é differente da ciò che era durante il rendering precedente. A volte, si vuole un mix dei due comportamenti: un Effect che si riesegue in risposta ad alcune values ma non ad altre. Questa pagina insegnerà come farlo.

### 32.1. Choosing between event handlers and Effects

Prima, ricapitoliamo la differenza tra Event Handlers ed Effects.

Si immagini di implementare un Component ChatRoom. Le richieste si mostrano così:

1. Il Component dovrebbe connettersi automaticamente alla chat room selezionata
2. Quando si clicka il button "Send", dovrebbe mandare un message alla chat.

Diciamo di avere già implementato il codice per questi, ma non siamo sicuri di dove inserirlo. Si dovrebbero usare gli Event Handlers o gli Effects? Ogni volta che si ha bisogno di rispondere a questa domanda si consideri perché il codice ha bisogno di eseguirsi.

### 32.2. Event handlers run in response to specific interactions

Dalla prospettiva dell'utente, mandare un message dovrebbe avvenire perché il button specifico "Send" é stato clickato. Lo user sarebbe basito se si mandasse il messaggio in un qualsiasi altro momento per una qualsiasi altra ragione. Ecco perché a mandare un message dovrebbe essere un Event Handler. Gli Event Handler permettono di gestire delle specifiche interazioni:

<code>

    import { useState } from "react";

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState("");
    	// ...
    	function handleSendClick() {
    		sendMessage(message);
    	}
    	// ...
    	return (
    		<>
    			<input
    				value={message}
    				onChange={(event) => setMessage(event.target.value)}
    			/>
    			<button onClick={handleSendClick}>Send</button>
    		</>
    	);
    }

</code>

Con un Event Handler, si può essere sicuri che sendMessage(message) si eseguirà solo se l'utente premerà il button.

### 32.3. Effects run whenever synchronization is needed

Ricordiamo che si ha anche la necessità di mantenere connesso il Component alla chat room. Dove metteremo questo codice?

La ragione per eseguire questo codice non é qualche particolare interazione. Non importa perché o come lo user ha navigato fino allo screen della chat room. Ora che stanno guardando a questa e possono interagirvi, il Component ha bisogno di rimanere connesso con il server della chat selezionato. Persino se il ChatRoom Component fosse lo screen iniziale dell'App e lo user non avesse ancora compiuto nessuna azione, si avrebbe ancora bisogno di connetterlo. Ecco perché é un Effect:

<code>

    function ChatRoom({ roomId }) {

    	// ...
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);

    	return (
    		// ...
    	);
    }

</code>

Con questo codice si può essere sicuri che vi sarà sempre una connessione attiva al server della chat selezionato correntemente, senza dover tener conto di una specifica interazione eseguita dallo user. Se l'utente ha solamente aperto l'App, selezionato una room differente o navigato ad un altro screen e tornato indietro, l'Effect si assicura che il Component rimanga sincronizzato con la room selezionata correntemente, e riconnetterà se fosse necessario.

<code>

    import { useState, useEffect } from "react";
    import { createConnection, sendMessage } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState("");

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);

    	function handleSendClick() {
    		sendMessage(message);
    	}

    	return (
    		<>
    			<h1>Welcome to the {roomId} room</h1>
    			<input
    				value={message}
    				onChange={(event) => setMessage(event.target.value)}
    			/>
    			<button onClick={handleSendClick}>Send</button>
    		</>
    	);
    }

</code>

### 32.4. Reactive values and reactive logic

Si potrebbe dire che gli Event Handlers sono sempre attivati "manualmente", per esempio clickando un button. Gli Effects, d'altro canto, sono "automatici": si eseguono e si rieseguono tanto spesso quanto é loro necessario per restare sincronizzati.

Vi é una cosa ancora più precisa a cui pensare.

Le Props, lo State e le variabili dichiarate dentro al body del Component vengono chiamate **Reactive Values**.
In quest'esempio, serverUrl non é una Reactive value, ma roomId e message lo sono. Partecipano al data flow del rendering:

<code>

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState("");
    }

</code>

Delle Reactive Values come queste possono cambiare a causa di un re-render. Per esempio, lo user potrebbe editare message o scegliere un differente roomId dal dropdowm menu. Gli Event Handlers e gli Effects rispondono ai cambiamenti in modo diverso:

• **La logica dentro gli Event Handlers non é reactive**. Non si eseguirà di nuovo a meno che lo user non compia la stessa interazione nuovamente (per esempio un click). Gli Event Handlers possono leggere delle Reactive Values senza "reagire" ai loro cambiamenti

• **La logica dentro un Effect é reactive**. Se l'Effect legge delle Reactive Values, occorrerà specificarle come Dependency.
Poi, se un re-render causasse un cambiamento in tale value, React rieseguirà la logica dell'Effect con la nuova value.

Rivisitiamo il precedente esempio per illustrare questa differenza.

### 32.5. Logic inside event handlers is not reactive

Si guardi questa riga di codice. Questa logica potrebbe essere reactive o no?

<code>
	sendMessage(message);
</code>

Dalla prospettiva dell'utente un cambiamento a message non significa che si voglia mandare tale message. Significa solamente che lo user ha digitato. In altre parole, la logica che manda un message non dovrebbe essere reactive. Non dovrebbe eseguirsi nuovamente a causa di una Reactive Value che é cambiata. Ecco perché appartiene ad un Event Handler:

<code>

    function handleSendClick(){
    	sendMessage(message);
    }

</code>

Gli Event Handlers non sono Reactive, quindi
sendMessage(message) si eseguirà solamente quando lo user clickerà sul button Send.

### 32.6. Logic inside Effects is reactive

Ora toriamo su queste righe:

<code>

    	const connection = createConnection(serverUrl, roomId);
    	connection.connect();

</code>

Dalla prospettiva dell'utente, un cambiamento al roomId significa che si vuole connettersi con una room differente. In altre parole, la logica per connettere la room dovrebbe essere Reactive. Si vuole che queste righe di codice si mantengano al passo con la Reactive Value, e si eseguano nuovamente se la value é differente. Ecco perché appartengono ad un Effect:

<code>

    useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);

</code>

Gli Effects sono Reactive, quindi
createConnection(serverUrl, roomId) e connection.connect() si eseguiranno per ogni distinta value di roomId. L'Effect mantiene la connessione con la chat sincronizzata alla room selezionata correntemente.

### 32.7. Extracting non-reactive logic out of Effects

Le cose divengono più articolate quando si vuole mixare la logica Reactive con la logica non-Reactive.

Per esempio, si immagini di voler mostrare una notifica quando lo user si connette alla chat. Se legge la value corrente del theme (dark o light) dalle prop in modo che si possa mostrare la notifica del colore corrente:

<code>

    useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.on("connected", () => {
    			showNotification("Connected", theme);
    		});
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);

</code>

Comunque, theme é una reactive value (può cambiare come risultato di un re-render), e ogni Reactive Value letta da un Effect deve essere dichiarata come sua Dependency. Ora occorrerà specificare theme come Dependency dell'Effect:

<code>

    useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.on("connected", () => {
    			showNotification("Connected", theme);
    		});
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId, theme]);

</code>

Si provi ora quest'esempio per notarne il problema:

<code>

    import { useState, useEffect } from "react";
    import { createConnection, sendMessage } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId, theme }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.on("connected", () => {
    			showNotification("Connected", theme);
    		});
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId, theme]);

    	function handleSendClick() {
    		sendMessage(message);
    	}

    	return (
    		<>
    			<h1>Welcome to the {roomId} room</h1>
    		</>
    	);
    }

    export default function ChatRoomContainer() {
    	const [roomId, setRoomId] = useState("general");
    	const [isDark, setIsDark] = useState(false);
    	return (
    		<>
    			<label>
    				Choose ypur chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<label>
    				<input
    					type="checkbox"
    					checked={isDark}
    					onChange={(event) => setIsDark(event.target.checked)}
    				/>
    				Use Dark Theme
    			</label>
    			<ChatRoom roomId={roomId} theme={isDark ? "dark" : "light"} />
    		</>
    	);
    }

</code>

Quando il roomId cambia, la chat si riconnette come ci si potrebbe aspettare. Ma visto che anche theme é una Dependency, la chat si riconnette ogni vota che si passa dal theme dark a quello light. Questo non va bene.

In altre parole, non si vuole che questa riga sia reactive, anche se si trova dentro ad un Effect, che é reactive:

<code>

    showNotification("Connected", theme);

</code>

Si avrà la necessità quindi di separare in qualche modo questa logica non reactive dall'Effect reactive intorno a questa.

### 32.8. Declaring an Effect Event

NOTA: Questa sezione é un'API sperimentale che non é ancora stata rilasciata in una versione stabile di React.

Si usi uno speciale Hook chiamato useEffectEvent per estrarre questa logica non reactive fuori dall'Effect:

<code>

    function ChatRoom({ roomId, theme }) {
    	const onConnected = useEffectEvent(() => {
    		showNotification("Connected", theme);
    	});
    }

</code>

Qui, onConnected viene chiamato un Effect Event. E' una parte della logica dell'Effect, ma si comporta più come un Event Handler. La logica dentro a questo non é reactive, e vede sempre l'ultima valie delle props e dello State.

Ora si può chiamare l'Effect Event onConnected da dentro l'Effect:

<code>

    function ChatRoom({ roomId, theme }) {
    	const onConnected = useEffectEvent(() => {
    		showNotification("Connected", theme);
    	});

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.on("connected", () => {
    			onConnected();
    		});
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]); // ✅ Tutte le dependencies dichiarate
    	// ...
    }

</code>

Questo risolve il problema. Si noti che si é rimosso onConnected (e anche theme) dalla lista delle dependencies dell'Effect. Gli Effect Events non sono reactive e devono essere omessi dalle dependencies.

Si verifichi (nella sandbox nell'esempio, fuori non funziona, vedi inizio paragrafo) che questo nuovo comportamento funzioni come ci si aspetta:

<code>

    import { useState, useEffect } from "react";
    import { experimental_useEffectEvent as useEffectEvent } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId, theme }) {
    	const onConnected = useEffectEvent(() => {
    		showNotification("Connected", theme);
    	});

    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.on("connected", () => {
    			onConnected();
    		});
    		connection.connect();
    		return () => {
    			connection.disconnect();
    		};
    	}, [roomId]);

    	return (
    		<>
    			<h1>Welcome to the {roomId} room</h1>
    		</>
    	);
    }

    export default function ChatRoomContainer() {
    	const [roomId, setRoomId] = useState("general");
    	const [isDark, setIsDark] = useState(false);
    	return (
    		<>
    			<label>
    				Choose ypur chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<label>
    				<input
    					type="checkbox"
    					checked={isDark}
    					onChange={(event) => setIsDark(event.target.checked)}
    				/>
    				Use Dark Theme
    			</label>
    			<ChatRoom roomId={roomId} theme={isDark ? "dark" : "light"} />
    		</>
    	);
    }

</code>

Si potrebbe pensare che gli Effects Events siamo similari agli Event Handlers. La differenza principale é che gli Event Handlers si eseguono in risposta ad un interazione dell'utente, mentre gli Effect Events vengono attivati dal codice scritto dagli Effects. Gli Effects Events permettono di di "rompere la catena" tra la reattività degli Effects ed il codice che non dovrebbe essere reactive.

### 32.9. Reading latest props and state with Effect Events

NOTA: Questa sezione é un'API sperimentale che non é ancora stata rilasciata in una versione stabile di React.

Gli Effect Events permettono di sistemare molti pattern dove si potrebbe essere tentati di sopprimere il Dependency Linter.

Per esempio, diciamo di avere un Effect che logga la visita al Component Page:

<code>

    function Page() {
    	useEffect(() => {
    		logVisit();
    	}, []);
    	// ...
    }

</code>

Più avanti, si potrebbero aggiungere molteplici routes al sito. Ora il Component Page riceve una prop url con il path corrente. Si vuole passare la url come parte della chiamata logVisit, ma il Dependency Linter si lamenta:

<code>

    function Page({url}){
    	useEffect(() => {
    		logVisit(url);
    	}, []); // 🔴 Il React Hook useEffect ha una dependency
    							mancante: url
    	// ...
    }

</code>

Si pensi a cosa si vuole che faccia il codice. Si vuole loggare una visita separata per differenti URL visto che ogni URL rappresenta un Page differente. In altre parole, questa chiamata a logVisit dovrebbe essere reactive rispetto all'url. Ecco perché, in tale caso, ha senso seguire il Dependency Linter ed aggiungere url come una dependency:

<code>

    function Page({url}){
    	useEffect(() => {
    		logVisit(url);
    	}, [url]); // ✅ Tutte le Dependencies sono dichiarate
    	// ...
    }

</code>

Ora diciamo che vogliamo includere il number di items nello shopping cart insieme con ogni visita alla pagina:

<code>

    import { useEffect, useContext } from "react";

    function Page({ url }) {
    	const { items } = useContext(ShoppingcartContext);
    	const numberOfItems = items.length;

    	useEffect(() => {
    		logVisit(url, numberOfItems);
    	}, [url]); // 🔴 Il React Hook useEffect ha una dependency
    							// mancante
    	// ...
    }

</code>

Si é usato numberOfItems dentro l'Effect, quindi il Linter chiede di aggiungerlo come una Dependency. Comunque, non si vuole che la chiamata a logVisit sia reactive rispetto a numberOfItems. Se lo user mette qualcosa nel Shopping Cart, e il numberOfItems cambia, questo non significa che lo user abbia visitato la pagina di nuovo. In altre parole, visitare la page é, in un certo senso, un "event". Avviene in un preciso momento nel tempo.

Dividiamo il codice in due parti:

<code>

    function Page({ url }) {
    	const { items } = useContext(ShoppingcartContext);
    	const numberOfItems = items.length;

    	const onVisit = useEffectEvent((visitedUrl) => {
    		logVisit(visitedUrl, numberOfItems);
    	});

    	useEffect(() => {
    		onVisit(url);
    	}, [url]); // ✅ Tutte le dependencies dichiarate
    	// ...
    }

</code>

Qui onVisit é un Effect Event. Il codice dentro a questo non é reactive. Ecco perché si può usare numbersOfItems (o ogni altra value reactive) senza preoccuparsi che possa causare la riesecuzione del codice che lo circonda al momento di un cambiamento.

D'altro canto, l'Effect stesso rimane reactive. Il codice dentro l'Effect usa la prop url, quindi l'Effect si rieseguirà dopo ogni re-render con una diversa prop url. Questo, a sua volta, chiamerà l'Effect Event onVisit.

Come risultato, si chiamerà logvisit per ogni cambiamento all'url, e verrà sempre letta l'ultima value di numberOfItems. Comunque, se numberOfItems cambia da solo, questo non causerà nessuna riesecuzione del codice.

Nota:
Vi é anche la possibilità di chiamare onVisit() senza arguments, e leggere url dentro a questo:

<code>

    function Page({ url }) {
    	const { items } = useContext(ShoppingcartContext);
    	const numberOfItems = items.length;

    	const onVisit = useEffectEvent(() => {
    		logVisit(url, numberOfItems);
    	});

    	useEffect(() => {
    		onVisit();
    	}, [url]);
    	// ...
    }

</code>

Questo funzionerebbe, ma é meglio passare questo url all'Effect Event esplicitamente. Passando url come un argument all'Effect Event, si sta dicendo che visitare una page un un differente url costituisce un "event" separato dalla prospettiva dell'utente.

L'argument visitedUrl é una parte dell'event che é accaduto:

<code>

    function Page({ url }) {
    	const { items } = useContext(ShoppingcartContext);
    	const numberOfItems = items.length;

    	const onVisit = useEffectEvent((visitedUrl) => {
    		logVisit(visitedUrl, numberOfItems);
    	});

    	useEffect(() => {
    		onVisit(url);
    	}, [url]);
    	// ...
    }

</code>

Visto che l'Effect chiede "esplicitamente" la visitedUrl, ora non si può rimuovere accidentalmente url dalle Dependencies ddell'Effect. Se si rimuove url dalle dependency (causando il fatto che pages distinte vengano contate come una singola), il linter avvertirà. Si vorrà che onVisit sia reactive con riguardo verso url, quindi invece di leggere l'url all'interno (dove on sarà reactive), lo si passa dall'Effect.

Questo diviene importante se vi della logica asincrona dentro l'Effect:

<code>

    function Page({ url }) {
    	const { items } = useContext(ShoppingcartContext);
    	const numberOfItems = items.length;

    	const onVisit = useEffectEvent((visitedUrl) => {
    		logVisit(visitedUrl, numberOfItems);
    	});

    	useEffect(() => {
    		setTimeout(() => {
    			onVisit(url);
    		}, 5000); // delay del logging delle visite
    	}, [url]);
    	// ...
    }

</code>

Qui, url dentro a onVisit corrisponde all'ultimo url (che può essere appena cambiata), ma visitedUrl corrisponde all'url che originariamente ha causato l'esecuzione di questo Effect (e questa chiamata ad onVisit).

### 32.10. Is it okay to suppress the dependency linter insted?

Nelle codebases esistenti, si potrebbe vedere il linter soppresso in questo modo:

<code>

    function Page({ url }) {
    	const { items } = useContext(ShoppingCartContext);
    	const numberOfItems = items.length;

    	useEffect(() => {
    		logVisit(url, numberOfItems);
    		// 🔴 Evitare di sopprimere il linter in questo modo:
    		// eslint-disable-next-line react-hooks/exhaustive-deps
    	}, [url]);
    	// ...
    }

</code>

Dopo che useEffectEvent diverrà una parte stabile di React, verrà raccomandato di non sopprimere **mai** il linter.

Il primo lato negativo del sopprimere la regola del lint é che React non avviserà più quando l'Effect avrà necessità di "reagire" alle nuove dependency reactive introdotte nel codice. Nell'esempio precedente, si é aggiunto url alle dependecies perché React si é ricordato di farlo. Non si otterranno più tali notifiche per le future mdifiche a tale Effect se si disabilita il linter. Questo porterà sicuramente a bug.

Ecco un esempio di un bug confuso se si sopprime il linter. In quest'esempio, la funzione handleMove si suppone legga la State variable corrente canMove in modo da decidere se il dot dovrebbe seguire il cursore. Comunque, canMove é sempre true dentro ad handleMove.

Si riesce a vedere perché?

<code>

    export default function Dot() {
    	const [position, setPosition] = useState({ x: 0, y: 0 });
    	const [canMove, setCanMove] = useState(true);

    	function handleMove(event) {
    		if (canMove) {
    			setPosition({ x: event.clientX, y: event.clientY });
    		}
    	}

    	useEffect(() => {
    		window.addEventListener("pointermove", handleMove);
    		return () => window.removeEventListener("pointermove", handleMove);
    		// eslint-disable-next-line react-hooks/exhaustive-deps
    	}, []);

    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={canMove}
    					onChange={(event) => setCanMove(event.target.checked)}
    				/>
    				The dot is allowed to move
    			</label>
    			<hr />
    			<div
    				style={{
    					position: "absolute",
    					backgroundColor: "pink",
    					borderRadius: "50%",
    					opacity: 0.6,
    					transform: `translate(${position.x}px, ${position.y}px)`,
    					pointerEvents: "none",
    					left: -20,
    					top: -20,
    					width: 40,
    					height: 40
    				}}
    			/>
    		</>
    	);
    }

</code>

Il problema con questo codice é la soppressione del Dependency Linter. Se si rimuove la soppressione, si vedrà che questo Effect dovrebbe dipendere dalla funzione handleMove. Questo ha senso: handleMove viene dichiarato dentro il body del Component, il che la rende una value reactive. Ogni value reactive dovrebbe essere specificata come dependency, o potrebbe potenzialmente essere sterile tutto il tempo.

L'autore del codice originale ha "mentito" a React dicendo che l'Effect non dipende ([]) da nessuna value reactive. Questo é il motivo per il quale React non ha risincronizzato l'Effect dopo che canMove é stato cambiato (ed handleMove con questo). Visto che React non ha risincronizzato l'Effect, l'handleMove attaccato come listener é la stessa handleMove function creata durante il rendering iniziale. Durante il render iniziale, canMove era true, che é il motivo per cui handleMove dal render iniziale vedrà sempre tale value true.

Se non si sopprimerà mai il linter, non si vedranno mai problemi con values sterili.

Con useEffectEvent, non vi é la necessità di "mentire" al linter, e il codice funzionerà come ci si aspetta:

<code>

    import { useState, useEffect } from "react";
    import { experimental_useEffectEvent as useEffectEvent } from "react";

    export default function Dot() {
    	const [position, setPosition] = useState({ x: 0, y: 0 });
    	const [canMove, setCanMove] = useState(true);

    	const onMove = useEffectEvent((event) => {
    		if (canMove) {
    			setPosition({ x: event.clientX, y: event.clientY });
    		}
    	});

    	useEffect(() => {
    		window.addEventListener("pointermove", onMove);
    		return () => window.removeEventListener("pointermove", onMove);
    	}, []);

    	return (
    		<>
    			<label>
    				<input
    					type="checkbox"
    					checked={canMove}
    					onChange={(event) => setCanMove(event.target.checked)}
    				/>
    				The dot is allowed to move
    			</label>
    			<hr />
    			<div
    				style={{
    					position: "absolute",
    					backgroundColor: "pink",
    					borderRadius: "50%",
    					opacity: 0.6,
    					transform: `translate(${position.x}px, ${position.y}px)`,
    					pointerEvents: "none",
    					left: -20,
    					top: -20,
    					width: 40,
    					height: 40
    				}}
    			/>
    		</>
    	);
    }

</code>

Questo non significa che useEffectEvent é sempre la soluzione corretta. Si dovrebbe applicarla alle righe di codice che non si vuole che siano reactive. Nel codice soprastante, non si vuole che il codice dell'Effect sia reactive con riguardi verso canMove. Ecco perché ha senso estrarre un Effect Event.

Si veda il capitolo Removing Effect Dependencies per altre alternative correte alla soppressione del linter.

### 32.11. Limitations of Effect Events

NOTA: Questa sezione é un'API sperimentale che non é ancora stata rilasciata in una versione stabile di React.

Gli Effect Events sono molto limitati riguardo a per cosa li si possono usare:

• Li si può chiamare solo dentro agli Effects

• Non si possono mai passare ad altri Components o Hooks.

Per esempio, non si può dichiarare o passare un Effect Event come questo:

<code>

    import { useState, useEffect } from "react";

    function Timer() {
    	const [count, setCount] = useState(0);

    	const onTick = useEffectEvent(() => {
    		setCount(count + 1);
    	});

    	useTimer(onTick, 1000); // 🔴 Evitare: passare Effect Events

    	return <h1>{count}</h1>;
    }

    function useTimer(callback, delay) {
    	useEffect(() => {
    		const id = setInterval(() => {
    			callback();
    		}, delay);
    		return () => {
    			clearInterval(id);
    		};
    	}, [delay, callback]); // Si avrà bisogno di specificare "callback"
    	// come dependency
    }

</code>

Invece, si dichiarino sempre gli Effect Events direttamente vicino agli Effects che li usano:

<code>

    import { useState, useEffect } from "react";

    function Timer() {
    	const [count, setCount] = useState(0);

    	useTimer(() => {
    		setCount(count + 1);
    	}, 1000);
    	return <h1>{count}</h1>;
    }

    function useTimer(callback, delay) {
    	const onTick = useEffectEvent(() => {
    		callback();
    	});

    	useEffect(() => {
    		const id = setInterval(() => {
    			onTick(); // ✅ Buono: viene chiamato localmente dentro un Effect
    		}, delay);
    		return () => {
    			clearInterval(id);
    		};
    	}, [delay]); // No vi é bisogno di specificare "onTick" (un...
    	// ...Effect Event) come dependency
    }

</code>

Gli Effect Events sono "pezzi" non reactive del codice dell'Effect. Dovrebbero essere vicini all'Effect che li usa.

### 32.12. Exercises

1-

<code>

    import { useState, useEffect } from 'react';

    export default function Timer() {
    	const [count, setCount] = useState(0);
    	const [increment, setIncrement] = useState(1);

    	useEffect(() => {
    		const id = setInterval(() => {
    			setCount(c => c + increment);
    		}, 1000);
    		return () => {
    			clearInterval(id);
    		};
    	}, [increment]);

    	return (
    		<>
    			<h1>
    				Counter: {count}
    				<button onClick={() => setCount(0)}>Reset</button>
    			</h1>
    			<hr />
    			<p>
    				Every second, increment by:
    				<button disabled={increment === 0} onClick={() => {
    					setIncrement(i => i - 1);
    				}}>–</button>
    				<b>{increment}</b>
    				<button onClick={() => {
    					setIncrement(i => i + 1);
    				}}>+</button>
    			</p>
    		</>
    	);
    }

</code>

✅ Perfetto

2-

<code>

    import { useState, useEffect } from 'react';
    import { experimental_useEffectEvent as useEffectEvent } from 'react';

    export default function Timer() {
    	const [count, setCount] = useState(0);
    	const [increment, setIncrement] = useState(1);

    	const onTick = useEffectEvent(() => {
    		setCount(c => c + increment);
    	})

    	useEffect(() => {
    		const id = setInterval(() => {
    			ontick();
    		}, 1000);
    		return () => {
    			clearInterval(id);
    		};
    	}, []);

    	return (
    		<>
    			<h1>
    				Counter: {count}
    				<button onClick={() => setCount(0)}>Reset</button>
    			</h1>
    			<hr />
    			<p>
    				Every second, increment by:
    				<button disabled={increment === 0} onClick={() => {
    					setIncrement(i => i - 1);
    				}}>–</button>
    				<b>{increment}</b>
    				<button onClick={() => {
    					setIncrement(i => i + 1);
    				}}>+</button>
    			</p>
    		</>
    	);
    }

</code>

✅ Perfetto

3- Qui si necessita che il delay sia una Dependency, quindi si elimini l'Effect Event e si inserica il setInterval nell'Effect con delay nel Dependency Array:

<code>

    import { useState, useEffect } from 'react';
    import { experimental_useEffectEvent as useEffectEvent } from 'react';

    export default function Timer() {
    	const [count, setCount] = useState(0);
    	const [increment, setIncrement] = useState(1);
    	const [delay, setDelay] = useState(100);

    	const onTick = useEffectEvent(() => {
    		setCount(c => c + increment);
    	});

    	useEffect(() => {
    		const id = setInterval(() => {
    			onTick();
    		}, delay);
    		return () => {
    			clearInterval(id);
    		}
    	}, [delay]);

    	return (
    		<>
    			<h1>
    				Counter: {count}
    				<button onClick={() => setCount(0)}>Reset</button>
    			</h1>
    			<hr />
    			<p>
    				Increment by:
    				<button disabled={increment === 0} onClick={() => {
    					setIncrement(i => i - 1);
    				}}>–</button>
    				<b>{increment}</b>
    				<button onClick={() => {
    					setIncrement(i => i + 1);
    				}}>+</button>
    			</p>
    			<p>
    				Increment delay:
    				<button disabled={delay === 100} onClick={() => {
    					setDelay(d => d - 100);
    				}}>–100 ms</button>
    				<b>{delay} ms</b>
    				<button onClick={() => {
    					setDelay(d => d + 100);
    				}}>+100 ms</button>
    			</p>
    		</>
    	);
    }

</code>

✅ Perfetto

4-

<code>

    import { useState, useEffect } from 'react';
    import { experimental_useEffectEvent as useEffectEvent } from 'react';
    import { createConnection, sendMessage } from './chat.js';
    import { showNotification } from './notifications.js';

    const serverUrl = 'https://localhost:1234';

    function ChatRoom({ roomId, theme }) {
    	const onConnected = useEffectEvent((connectedRoom) => {
    		showNotification('Welcome to ' + connectedRoom, theme);
    	});

    	useEffect(() => {
    		let ignore = false;
    		let id;
    		const connection = createConnection(serverUrl, roomId);
    		if(!ignore){
    			connection.on('connected', () => {
    				id = setTimeout(() => {
    					onConnected(roomId);
    				}, 2000);
    			});
    		}
    		connection.connect();
    		return () => {
    			clearTimeout(id);
    			ignore = true;
    			connection.disconnect()
    		};
    	}, [roomId]);

    	return <h1>Welcome to the {roomId} room!</h1>
    }

    export default function App() {
    	const [roomId, setRoomId] = useState('general');
    	const [isDark, setIsDark] = useState(false);
    	return (
    		<>
    			<label>
    				Choose the chat room:{' '}
    				<select
    					value={roomId}
    					onChange={e => setRoomId(e.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<label>
    				<input
    					type="checkbox"
    					checked={isDark}
    					onChange={e => setIsDark(e.target.checked)}
    				/>
    				Use dark theme
    			</label>
    			<hr />
    			<ChatRoom
    				roomId={roomId}
    				theme={isDark ? 'dark' : 'light'}
    			/>
    		</>
    	);
    }

</code>

Prima task: ✅ Perfetto
Seconda task: ✅ Quasi perfetta, aggiunto solo ignore in più rispetto alla soluzione.

## 33. Removing Effect Dependencies

Quando si scrive un Effect, il Linter verificherà che si sia inclusa ogni value reactive che l'Effect legge nella lista delle Dependency, come Props e State. Questo assicura che l'Effect rimanga sincronizzato con le ultime Props e State del Component. Le dependencies non necessarie potrebbero causare un esecuzione troppo frequente o persino un infinite loop. Si segua questo capitolo per revisionare e rimuovere le dependencies non necessarie dagli Effects.

### 33.1. Dependencies sholud match the code

Quando si scrive un Effect, occorre prima specificare come cominciare e finire ciò che si vuole che l'Effect faccia:

<code>

    import { useState, useEffect } from "react";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    		// ...
    	});
    }

</code>

Poi, se si lascia la lista delle Effect Dependency vuota ([]), il linter suggerirà le corrette dependencies:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, []); // Si sistemi l'errore qui
    	return <h1>Welcome ti the {roomId} room</h1>;
    }

    export default function ChatRoomContainer() {
    	const [roomId, setRoomId] = useState("general");
    	return (
    		<>
    			<label>
    				Choose the chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<hr />
    			<ChatRoom roomId={roomId} />
    		</>
    	);
    }

</code>

Qui il Linter segnalerà la Dependency mancante roomId.
Si completi l'Array in base a cosa dice il linter:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]); // ✅ Tutte le Dependencies dichiarate
    	return <h1>Welcome ti the {roomId} room</h1>;
    }

    export default function ChatRoomContainer() {
    	const [roomId, setRoomId] = useState("general");
    	return (
    		<>
    			<label>
    				Choose the chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<hr />
    			<ChatRoom roomId={roomId} />
    		</>
    	);
    }

</code>

Gli Effects "reagiscono" alle reactive values. Visto che roomId é una reactive value, cioé può cambiare a causa di un re-render, il linter verifica che si sia specificata come una Dependency. Se roomId riceve una value differente, react risincronizzarà l'Effect. Questo assicura che la chat rimanga connessa con la room selezionata e reagisca in caso di selezione dal dropdown menù:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]);
    	return <h1>Welcome ti the {roomId} room</h1>;
    }

    export default function ChatRoomContainer() {
    	const [roomId, setRoomId] = useState("general");
    	return (
    		<>
    			<label>
    				Choose the chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<hr />
    			<ChatRoom roomId={roomId} />
    		</>
    	);
    }

</code>

### 33.2. To remove a dependency, prove that it's not a dependency

Si noti che non si possono "scegliere" le dependencies dell'Effect. Ogni Reactive Value usata dal codice dell'Effect deve essere dichiarata nella lista delle Dependencies. La Dependencies List viene determinata dal codice che la circonda:

<code>

    function ChatRoom({ roomId }) {
    	// <--- Questa é una reactive value

    	useEffect(() => {

    		const connection = createConnection(serverUrl, roomId);
    		// <--- Questo Effect legge tale reactive value

    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]);
    	// <--- ✅ Quindi si deve specificare tale reactive value...
    	// come una dependency dell'Effect.

    	return <h1>Welcome ti the {roomId} room</h1>;
    }

</code>

Le Reactive values includono le Props e tutte le variabili e funzioni dichiarate direttamente dentro al Component. Visto che roomId é una value reactive, non si può rimuoverla dalla Dependency List. Il Linter non lo permetterà:

<code>

    function ChatRoom({ roomId }) {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, []); // 🔴 L'Hook di React useEffect ha una dependency
    					// mancante: roomId
    	return <h1>Welcome to the {roomId} room</h1>;
    }

</code>

E il Linter ha ragione. Visto che roomId può cambiare nel tempo, questo potrebbe introdurre dei bug nel codice.

Per rimuovere una Dependency, si "provi" al Linter che non é necessario che sia un Dependency. Per esempio, si può muovere roomId fuori dal Component per provare che non é reactive e non cambierà al momento dei re-render:

<code>

    const serverUrl = "https://localhost:1234";
    const roomId = "music"; // Non più una value reactive

    function ChatRoom() {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, []); // ✅ Tutte le dependencies dichiarate
    	return <h1>Welcome to the {roomId} room</h1>;
    }

</code>

Ora che roomId non é più una reactive value, e quindi non cambierà al re-render, non vi é più bisogno che sia una Dependency:

<code>

    const serverUrl = "https://localhost:1234";
    const roomId = "music";

    function ChatRoom() {
    	useEffect(() => {
    		const connection = createConnection(serverUrl, roomId);
    		connection.connect();
    		return () => connection.disconnect();
    	}, []);
    	return <h1>Welcome to the {roomId} room</h1>;
    }

</code>

Ecco il motivo per cui si può specificare ora una Dependency List Empty ([]). L'Effect realmente non dipende più da nessuna value reactive, quindi non ha davvero più bisogno di rieseguirsi quando una qualsiasi prop o state del Component cambia.

### 33.3. To change the dependencies, change the code

Si potrebbe aver notato un pattern nel workflow:

1. Prima, si cambia il codice dell'Effect o come le reactive values vengono dichiarate.

2. Poi, si segue il Linter e si aggiustano le dependencies che corrispondono al codice che si ha cambiato.

3. Se non si é felici con la lista delle dependencies, si torni indietro al primo punto e si cambia nuovamente il codice.

L'ultima parte é importante. Se si vuole cambiare le dependencies, si cambi il codice attorno prima. Si può pensare alla Dependency List come ad una lista di tutte le reactive values usate dal codice dell'Effect. Non si sceglie cosa inserire in tale lista. La lista descrive il codice. Per cambiare la dependency list quindi, si cambi il codice.

Si dovrebbe sentirsi come se si stesse cambiando un'equazione. Si potrebbe cominciare con un obiettivo, per esempio rimuovere una dependency, e si avrà bisogno di "trovare" il codice che corrisponde con l'obiettivo. Vi é una lista di ricette comuni fortunatamente che si possono provare per semplificare le cose.

Nota:
Se si ha una codebase esistente, si potrebbe avere degli Effects che sopprimono il Linter in questo modo:

<code>

    useEffect(() => {
    	// ...
    	// 🔴 Evitare di sopprimere il Linter in questo modo:
    	// eslint-ignore-next-line react-hooks/exhaustive-deps
    }, []);

</code>

Quando le dependecies non corrispondono al codice, vi é un serio rischio di introdurre dei bug. Sopprimendo il Linter, si "mente" a React riguardo le values dalle quali l'Effect dipende.
Invece si usino le tecniche illustrate sotto.

### 33.4. Why is suppressing the dependency linter so dangerous?

Sopprimere il Linter porta a dei bug molto controintuitivi che si rivelano difficili da trovare e sistemare. Ecco un esempio:

<code>

    import { useState, useEffect } from "react";

    export default function Timer() {
    	const [count, setCount] = useState(0);
    	const [increment, setIncrement] = useState(1);

    	function onTick() {
    		setCount(count + increment);
    	}

    	useEffect(() => {
    		const id = setInterval(onTick, 1000);
    		return () => clearInterval(id);
    		// eslint-disable-next-line react-hooks/exhaustive-deps
    	}, []);

    	return (
    		<>
    			<h1>
    				Counter: {count}
    				<button onClick={() => setCount(0)}>Reset</button>
    			</h1>
    			<hr />
    			<p>
    				Every second, increment by:
    				<button
    					disabled={increment === 0}
    					onClick={() => {
    						setIncrement((i) => i - 1);
    					}}
    				>
    					-
    				</button>
    				<b>{increment}</b>
    				<button
    					onClick={() => {
    						setIncrement((i) => i + 1);
    					}}
    				>
    					+
    				</button>
    			</p>
    		</>
    	);
    }

</code>

Diciamo di che si vuole eseguire l'Effect "solo al momento che viene montato il Component". Si é letto che l'Empty Dependency List ([]) da proprio quello, quindi si é deciso di ignorare il linter e specificare forzatamente [] come Dependency.

Questo counter si supporne venga incrementato ogni secondo dall'ammontare configurabile con i due button. Comunque, visto che si ha "mentito" a React dicendogli che non dipende da nulla, React continuerà sempre ad usare la onTick function dal render iniziale. Durante tale render, count era 0 e increment era 1. Ecco perché onTick da tale render chiama sempre setCount(0 + 1) ogni secondo, e si vedrà sempre 1. Bug come questi sono difficili da sistemare quando sono divisi tra molteplici Components.

Vi é sempre una soluzione migliore rispetto all'ignorare il Linter. Per sistemare questo codice, occorre aggiungere onTick alla Dependency List, mentre per assicurarsi che l'interval sia sempre impostato una sola volta, si renda onTick un Effect Event, vedi capitolo precedente sperimentale.

Si raccomanda di trattare l'Error del Dependency Lint come un errore di compilazione. Se non lo si sopprime, non si vedranno mai bug come questo. Ora si documenteranno le alternative per questo e altri casi.

### 33.5. Removing unnecessary dependencies

Ogni volta che si aggiustano le Dependency di un Effect per riflettere il codice, si guardi alla Dependency List. Ha senso per l'Effect rieseguirsi quando una di queste dependencies cambia? A volte la risposta é no:

• Si potrebbero voler rieseguire parti differenti dell'Effect a differenti condizioni

• Si potrebbe voler leggere solo l'ultima value di qualche dependency invece di "reagire" ai suoi cambiamenti

• Una Dependency potrebbe cambiare troppo spesso incondizionatamente perché é un object o una funzione.

Per trovare la soluzione corretta, occorre rispondere ad alcune domande sull'Effect. Percorriamole.

### 33.6. Should this code move to an event handler?

La prima cosa alla quale si dovrebbe pensare é se questo codice dovrebbe essere un Effect certamente.

Si immagini un form. Al submit, si imposta la submitted State variable a true. Occorre mandare una POST request e mostrare una notifica. Si é inserita questa logica dentro ad un Effect che "reagisce" a quando submitted diviene true:

<code>

    import { useState, useEffect } from "react";

    function Form() {
    	const [submitted, setSubmitted] = useState(false);

    	useEffect(() => {
    		if (submitted) {
    			// 🔴 Evitare: logica specifica di un Event dentro
    			// ad un Effect
    			post("/api/register");
    			showNotification("Successfully registered.");
    		}
    	}, [submitted]);

    	function handleSubmit() {
    		setSubmitted(true);
    	}
    	// ...
    }

</code>

Più avanti, si vuole dare uno style al message delle notification in base al tema corrente, quindi si legge il theme corrente. Visto che theme viene dichiarata nel body del Component, é una value reactive, quindi aggiungiamola come dependency:

<code>

    import { useState, useEffect, useContext } from "react";
    const theme = useContext(ThemeContext);

    function Form() {
    	const [submitted, setSubmitted] = useState(false);

    	useEffect(() => {
    		if (submitted) {
    			// 🔴 Evitare: logica specifica di un Event dentro
    			// ad un Effect
    			post("/api/register");
    			showNotification("Successfully registered.", theme);
    		}
    	}, [submitted, theme]); // ✅ Tutte le Dependency dichiarate

    	function handleSubmit() {
    		setSubmitted(true);
    	}
    	// ...
    }

</code>

Facendo questo, si é introdotto un bug. Si immagini di inviare il form (submit) prima e dopo lo switch tra i theme Dark e Light. La value di theme cambierà, l'Effect si rieseguirà, e quindi si vedrà la stessa notifica nuovamente.

Il problema qui é che non dovrebbe essere un Effect per prima cosa. Si vuole mandare una POST request e mostrare una notifica in risposta al submit del form, che é una particolare interazione. Per eseguire del codice in risposta ad una particolare interazione si deve inserire tale logica in un corrispondente Event Handler:

<code>

    import { useState, useEffect, useContext } from "react";

    function Form() {
    	const theme = useContext(ThemeContext);

    	function handleSubmit() {

    		// ✅ Buono: logica specifica di un Event chiamata da un...
    		// ...Event Handler

    		post("/api/register");
    		showNotification("Successfully registered.", theme);
    	}
    	// ...
    }

</code>

Ora che il codice é in un Event Handler non é reactive. Quindi si eseguirà solamente quando lo user eseguirà il submit del form. Si vedano capitoli "Choosing between event handlers and Effects" e "How to delete unnecessary Effects".

### 33.7. Is your Effect doing several unrelated things?

La domanda successiva che occorre porsi é se l'Effect sta vacendo varie cose non relazionate.

Si immagini di creare un Form per le spedizioni dove lo user necessita di scegliere la città e l'area. Si esegue il fetch della lista di cities dal server in base alla country selezionata per mostrarle in un dropdown:

<code>

    import { useState, useEffect } from "react";

    function ShippingForm({ country }) {
    	const [cities, setCities] = useState(null);
    	const [city, setCity] = useState(null);

    	useEffect(() => {
    		let ignore = false;
    		fetch(`/api/cities?country=${country}`)
    			.then((response) => response.json())
    			.then((json) => {
    				if (!ignore) {
    					setCities(json);
    				}
    			});
    		return () => {
    			ignore = true;
    		};
    	}, [country]); // ✅ Tutte le Dependencies dichiarate

    	// ...
    }

</code>

Questo é un buon esempio di fetching dei dati in un Effect.
Si sta sincronizzando lo State cities con il network in base alla prop country. Non si può farlo in un Event Handler perché si ha la necessità di eseguire il fetch appena ShippingForm viene visualizzato e se country cambia (non importa quale interazione li causi).

Ora diciamo di voler aggiungere una seconda selected box per le city areas, che dovrebbe eseguire il fetch delle areas in base alla city selezionata. Si potrebbe cominciare aggiungendo una seconda chiamata a fetch per la lista delle areas dentro lo stesso Effect:

<code>

    import { useState, useEffect } from "react";

    function ShippingForm({ country }) {
    	const [cities, setCities] = useState(null);
    	const [city, setCity] = useState(null);
    	const [areas, setAreas] = useState(null);

    	useEffect(() => {
    		let ignore = false;
    		fetch(`/api/cities?country=${country}`)
    			.then((response) => response.json())
    			.then((json) => {
    				if (!ignore) {
    					setCities(json);
    				}
    			});

    		// 🔴 Evitare: Un singolo Effect sincronizza due
    		// processi indipendenti

    		if (city) {
    			fetch(`/api/areas?city=${city}`)
    				.then((response) => response.json())
    				.then((json) => {
    					if (!ignore) {
    						setAreas(json);
    					}
    				});
    		}
    		return () => {
    			ignore = true;
    		};
    	}, [country, city]); // ✅ Tutte le Dependencies dichiarate

    	// ...
    }

</code>

Comunque, visto che l'Effect ora usa la city State variable, si ha aggiunto alla lista delle Dependencies city. Che, infatti, introduce un problema: quando lo user seleziona una città differente, l'Effect si rieseguirà e chiamerà
fetchCities(country). Come risultato, si eseguirà nuovamente il fetch riottenendo la lista delle cities anche se non necessario.

Il problema con questo codice é che si stanno sincronizzando due cose differenti non relazionate:

1. Si vuole sincronizzare lo State cities al network basandosi sulla prop country.

2. Si vuole sincronizzare lo State areas al network basandosi allo State city.

Occorre dividere la logica in due Events, ognuno dei quali reagisce alla prop con cui necessita di sincronizzarsi:

<code>

    import { useState, useEffect } from "react";

    function ShippingForm({ country }) {
    	const [cities, setCities] = useState(null);

    	useEffect(() => {
    		let ignore = false;
    		fetch(`/api/cities?country=${country}`)
    			.then((response) => response.json())
    			.then((json) => {
    				if (!ignore) {
    					setCities(json);
    				}
    			});
    		return () => {
    			ignore = true;
    		};
    	}, [country]); // ✅ Tutte le Dependencies dichiarate

    	const [city, setCity] = useState(null);
    	const [areas, setAreas] = useState(null);
    	useEffect(() => {
    		let ignore = false;

    		if (city) {
    			fetch(`/api/areas?city=${city}`)
    				.then((response) => response.json())
    				.then((json) => {
    					if (!ignore) {
    						setAreas(json);
    					}
    				});
    		}
    		return () => {
    			ignore = true;
    		};
    	}, [city]); // ✅ Tutte le Dependencies dichiarate

    	// ...
    }

</code>

Ora il primo Effect si riesegue solamente se country cambia, mentre il secondo Effect si riesegue quando city cambia. Ora sono stati separati in base allo scopo: due cose differenti sono sincronizzate da due Effects separati. Due Effects separati hanno due dependency list separate, in modo che si attivino l'un l'altro in modo non intenzionale.

Il codice finale é più lungo dell'originale, ma dividere questi Effects é ancora corretto. Ogni Effect dovrebbe rappresentare un indipendente processo di sincronizzazione. In quest'esempio, cancellare un Effect non rompe la logica dell'altro Effect. Questo significa che sincronizzano cose differenti, e va bene dividerle. Se si é interessati alla duplicazione, si può migliorarla estraendo la logica ripetitiva in un Custom Hook (vedi capitolo successivo).

### 33.8. Are you reading some state to calculate the next state?

Questo Effect aggiorna la State variable message con un Array appena creato ogni volta che arriva un nuovo message:

<code>

    import { useState, useEffect } from "react";

    function ChatRoom({ roomId }) {
    	const [messages, setMessages] = useState([]);

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			setMessages([...messages, receivedMessage]);
    		});
    		// ...
    	});
    }

</code>

Questo usa la variable messages per creare un nuovo array cominciando da tutti i messages esistenti e aggiunge il nuovo message alla fine. Comunque, visto che messages é una value reactive letta da un Effect, deve essere una dependency:

<code>

    import { useState, useEffect } from "react";

    function ChatRoom({ roomId }) {
    	const [messages, setMessages] = useState([]);

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			setMessages([...messages, receivedMessage]);
    		});
    		return () => connection.disconnect();
    	}, [roomId, messages]); // ✅ Tutte le dependecies dichiarate
    }

</code>

E rendendo messages una dependency subentra un problema.

Ogni volta che si riceve un message, setMessage() causa il re-render del Component con un nuovo Array messages che include il message ricevuto. Comunque, visto che questo Effect ora dipende da messages, questo sinsincronizzerà anche l'Effect. Quindi ogni nuovo message farà riconnettere la chat. Non proprio ciò che vorrebbe lo user.

Per sistemare il problema, non si legga messages dentro all'Effect. Invece, si passi un'Updater Function a setMessages:

<code>

    import { useState, useEffect } from "react";

    function ChatRoom({ roomId }) {
    	const [messages, setMessages] = useState([]);

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			// --->
    			setMessages((msgs) => [...msgs, receivedMessage]);
    			// <---
    		});
    		return () => connection.disconnect();
    	}, [roomId]); // ✅ Tutte le dependecies dichiarate
    }

</code>

Si noti come l'Effect non legga affatto la variabile messages ora. Occorre solamente passare un Update Function come
msgs => [...msgs, receivedMessage]. React inserisce la updater function in una coda (queue) e fornisce l'argument msgs a questa durante il successivo render. Questo é il motivo l'Effect stesso non ha più bisogno di dipendere da messages. Come risultato di questa sistemazione, ricevere un messaggio nella chat non causerà più la riconnessione alla chat.

### 33.9. Do you want to read a value without "reacting" to its changes?

NOTA: Questa sezione descrive un'API sperimentale, come nel capitolo precedente.

Si supponga di voler riprodurre un suono quando l'utente riceve un nuovo messaggio ma meno che isMuted non sia true:

<code>

    import { useState, useEffect } from "react";

    function ChatRoom({ roomId }) {
    	const [messages, setMessages] = useState([]);
    	const [isMuted, setIsMuted] = useState(false);

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			setMessages((msgs) => [...msgs, receivedMessage]);
    			if (!isMuted) {
    				playSound();
    			}
    		});
    		return () => connection.disconnect();
    	}, [roomId]);
    }

</code>

Visto che l'Effect usa isMuted nel suo codice, occorre aggiungerlo alle dependencies:

<code>

    function ChatRoom({ roomId }) {
    	const [messages, setMessages] = useState([]);
    	const [isMuted, setIsMuted] = useState(false);

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			setMessages((msgs) => [...msgs, receivedMessage]);
    			if (!isMuted) {
    				playSound();
    			}
    		});
    		return () => connection.disconnect();
    	}, [roomId, isMuted]); // ✅ Tutte le dependencies dichiarate
    }

</code>

Il problema é che ogni volta che isMuted cambia (per esempio quando lo user preme il toggle "Muted"), l'Effect si risincronizza, e si riconnette alla chat. Questo non la User Experience desiderata. In quest'esempio anche disabilitare il linter non funzionerà, se lo si fa isMuted resterrà bloccato (stuck) alla sua vecchia value.

Per risolvere questo problema, si necessita di estrarre la logca che non dovrebbe essere reactive fuori dall'Effect. Non si vuole che questo Effect "reagisca" ai cambiamenti di isMuted. Si muova quindi questo pezzo di logica in un Effect Event:

<code>

    import { useState, useEffect } from "react";

    function ChatRoom({ roomId }) {
    	const [messages, setMessages] = useState([]);
    	const [isMuted, setIsMuted] = useState(false);

    	const onMessage = useEffectEvent((receivedMessage) => {
    		setMessages((msgs) => [...msgs, receivedMessage]);
    		if (!isMuted) {
    			playSound();
    		}
    	});

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			onMessage(receivedMessage);
    		});
    		return () => connection.disconnect();
    	}, [roomId]); // ✅ Tutte le dependencies dichiarate
    }

</code>

Gli Effect Events permettono di dividere un Effect in parti reactive (che dovrebbero "reagire" alle reactive values come roomId ed i loro cambiamenti) ed in parti non-reactive (che leggono solamente le loro ultime values, come onMessage legge isMuted). Ora che si legge isMuted dentro un Effect Event non vi é bisogno che sia una dependency dell'Effect. Come risultato, la chat non si riconnetterà quando si usa il toggle "Muted" impostandolo da on a off, risolvendo il problema originale.

### 33.10. Wrapping an event handler from the props

Si potrebbe incappare in un problema similare quando il Component riceve un Event Handler come prop:

<code>

    function ChatRoom({ roomId, onReceivedMessage }) {
    	const [messages, setMessages] = useState([]);

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			onReceivedMessage(receivedMessage);
    		});
    		return () => connection.disconnect();
    	}, [roomId, onReceivedMessage]); // ✅ Tutte le dependencies dichiarate
    }

</code>

Supponiamo che il parent Component passi una funzione onReceivedMessage ad ogni render:

<code>

    <ChatRoom
    		roomId={roomId}
    		onReceivedMessage={receivedMessage => {
    			// ...
    		}}
    />

</code>

Visto che onReceivedMessage é una dependency, causerebbe la risincronizzazione dell'Effect dopo ogni re-render del parent. Questo lo farebbe riconnettere alla chat. Per risolvere questo problema, si avvolga la chiamata in un Effect Event.

<code>

    import { useState, useEffect } from "react";

    function ChatRoom({ roomId, onReceivedMessage }) {
    	const [messages, setMessages] = useState([]);

    	const onMessage = useEffectEvent((receivedMessage) => {
    		onReceivedMessage(receivedMessage);
    	});

    	useEffect(() => {
    		const connection = createConnection();
    		connection.connect();
    		connection.on("message", (receivedMessage) => {
    			onMessage(receivedMessage);
    		});
    		return () => connection.disconnect();
    	}, [roomId]); // ✅ Tutte le dependencies dichiarate
    }

</code>

Gli Effect Events non sono reactive, quindi non si necessita di specificarli come dependencies. Come risultato, la chat non si riconnetterà più nemmeno se il parent Component passasse una funzione che é differente ad ogni render.

### 33.11. Separating reactive and non-reactive code

In quest'esempio si vuole loggare una visita ogni volta che roomId cambia. Si vuole includere il corrente notificationCount per ogni log, ma non si vuole un cambiamento a notificationCount per attivare un log event.

La soluzione é di nuovo dividere il codice non-reactive in un Effect Event:

<code>

    function Chat({ roomId, notificationCount }) {
    	const onVisit = useEffectEvent((visitedRoomId) => {
    		logVisit(visitedRoomId, notificationCount);
    	});

    	useEffect(() => {
    		onVisit(roomId);
    	}, [roomId]); // ✅ Tutte le dependencies dichiarate
    	// ...
    }

</code>

Si vuole che la logica sia reactive con riguardo verso roomId, quindi si legge roomId dentro l'Effect. Comunque non si vuole un cambiamento a notificationCount per loggare una visita supplementare, quindi si legge notificationCount dentro un Effect Event. Si vedano maggiori dettagli sugli Effect Event nello scorso capitolo.

### 33.12. Does some reactive value change unintentionally?

A volte, si vuole che l'Effect "reagisca" ad una certe value, ma tale value cambia più spesso di quanto si vorrebbe, e potrebbe non riflettere nessun effettivo cambiamento dalla prospettiva dell'utente. Per esempio, diciamo che si é creato un object options nel body del Component, e poi si legge tale object da dentro un Effect:

<code>

import { useState, useEffect } from "react";

function ChatRoom({ roomId }) {
// ...
const options = {
serverUrl: serverUrl,
roomId: roomId
};

    useEffect(() => {
    	const connection = createConnection(options);
    	connection.connect();
    }, []);

}

</code>

Questo object viene dichiarato nel body del Component, quindi é una value reactive. Quando si legge una reactive value come questa dentro ad un Effect, la si dichiara come una dependency. Questo assicura che l'Effect "reagisca" ai suoi cambiamenti:

<code>

    import { useState, useEffect } from "react";

    function ChatRoom({ roomId }) {
    	// ...
    	const options = {
    		serverUrl: serverUrl,
    		roomId: roomId
    	};

    	useEffect(() => {
    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [options]); // ✅ Tutte le dependencies sono dichiarate
    	// ...
    }

</code>

E' importante dichiararlo come una dependency. Questo assicura per esempio che se roomId cambia, l'Effect si riconnetterà alla chat con il nuovo options. Comunque, vi é anche un problema con il codice soprastante. Per vederlo, si provi a scrivere nell'input basandosi su questo codice:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState("");

    	// Linter temporaneamente disabilitato per dimostrare...
    	// ...il problema --->

    	// eslint-disable-next-line react-hooks/exhaustive-deps

    	const options = {
    		serverUrl: serverUrl,
    		roomId: roomId
    	};

    	useEffect(() => {
    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [options]);

    	return (
    		<>
    			<h1>Welcome to the {roomId} room!</h1>
    			<input
    				value={message}
    				onChange={(event) => setMessage(event.target.value)}
    			/>
    		</>
    	);
    }

    export default function ChatContainer() {
    	const [roomId, setRoomId] = useState("general");
    	return (
    		<>
    			<label>
    				Choose the chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<hr />
    			<ChatRoom roomId={roomId} />
    		</>
    	);
    }

</code>

Nel codice soprastante, l'input si aggiorna solamente la State variable message. Da un prospettiva dell'utente, questo non dovrebbe aver effetto sulla connessione della chat. Comunque, ogni volta che si aggiorna message, il Component si re-renderizza. Quando il Component si re-renderizza, il codice dentro a questo si riesegue da zero.

Un nuovo object options viene quindi creato da zero ad ogni re-render del Component ChatRoom. React vede che l'object options é un object differente dall'object options creato durante l'ultimo render. Questo é il motivo per il quale l'Effect si risincronizza, visto che dipende da options, e la chat si riconnette ad ogni digitazione.

Questo problema affligge solo gli objects e le funzioni. In JavaScript, ogni nuovo object e nuova funzione creata viene considerata distinta dalle altre. Non importa se il content al loro interno possa essere lo stesso.

<code>

    // Durante il primo render
    const options1 = { serverUrl: "https://localhost:1234", roomId: "music" };
    // Durante il secondo render
    const options2 = { serverUrl: "https://localhost:1234", roomId: "music" };
    // Questi sono due objects differenti
    console.log(Object.is(options1, options2));
    // ---> false

</code>

Le dependencies degli Objects e delle Functions possono far risincronizzare l'Effect più spesso di quanto si necessiti.

Per questo motivo, se possibile, si dovrebbe provare ad evitare gli objects e le functions come dependencies dell'Effect. Invece si provi a muoverli fuori dal Component, o dentro l'Effect oppure estreando delle values primitive da questi.

### 33.13. Move static objects and functions outside your component

Se l'object non dipende da props o dallo State, si può muovere tale object fuori dal Component:

<code>
	const options = {
		serverUrl: "https://localhost:1234",
		roomId: "music"
	};

    function ChatRoom() {
    	const [message, setMessage] = useState("");

    	useEffect(() => {
    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, []); // ✅ Tutte le dependencies dichiarate
    	// ...
    }

</code>

In questo modo, si proverà al Linter che non é reactive. Non può cambiare come risultato di un re-render, quindi non necessita di essere una dependency. Ora re-renderizzare ChatRoom non causerà la risincronizzazione dell'Effect.

Questo funziona anche per le funzioni:

<code>

    function createOptions() {
    	return {
    		serverUrl: "https://localhost:1234",
    		roomId: "music"
    	};
    }

    function ChatRoom() {
    	const [message, setMessage] = useState("");

    	useEffect(() => {
    		const options = createOptions();
    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, []); // ✅ Tutte le dependencies dichiarate
    }
    // ...

</code>

Visto che createOptions viene dichiarato fuori dal Component, non é una value reactive. Ecco perché non necessita di essere specificata nelle dependencies dell'Effect e perché non causa mai la risincronizzazione dell'Effect.

### 33.14. Move dynamic objects and functions inside your Effect

Se l'object dipende da qualche value reactive che può cambiare come risultato di un re-render, come una prop roomId, non si può spostarla al di fuori del Component. Si può, invece, muovere la sua creazione all'interno del codice dell'Effect:

<code>

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState("");

    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};

    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]); // ✅ Tutte le dependencies dichiarate
    	// ...
    }

</code>

Ora che options viene dichiarato dentro all'Effect, non é più una dependency dell'Effect. Invece, l'unica value reactive usata dall'Effect é roomId. Visto che roomId non é un Object o una function, si può essere sicuri che non sarà differente in modo non intenzionale. In JavaScript, i numbers e le strings sono comparati in base al loro content:

<code>

    // Durante il primo render
    const roomId1 = "music";
    // Durante il render successivo
    const roomId2 = "music";
    // queste due strings sono le stesse
    console.log(Object.is(roomId1, roomId2)); // true

</code>

Grazie a questo aggiustamento, la chat non si riconnette più se si edita l'input:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState("");

    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};

    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]);

    	return (
    		<>
    			<h1>Welcome to the {roomId} room!</h1>
    			<input
    				value={message}
    				onChange={(event) => setMessage(event.target.value)}
    			/>
    		</>
    	);
    }

    export default function ChatContainer() {
    	const [roomId, setRoomId] = useState("general");
    	return (
    		<>
    			<label>
    				Choose the chat room:{" "}
    				<select
    					value={roomId}
    					onChange={(event) => setRoomId(event.target.value)}
    				>
    					<option value="general">general</option>
    					<option value="travel">travel</option>
    					<option value="music">music</option>
    				</select>
    			</label>
    			<hr />
    			<ChatRoom roomId={roomId} />
    		</>
    	);
    }

</code>

Comunque, si riconnetterà quando si cambierà roomId nel dropdown, come ci si aspetta.

Questo funziona anche per le funzioni:

<code>

    const serverUrl = "https://localhost:1234";

    function ChatRoom({ roomId }) {
    	const [message, setMessage] = useState("");

    	useEffect(() => {
    		function createOptions() {
    			return {
    				serverUrl: serverUrl,
    				roomId: roomId
    			};
    		}

    		const options = createOptions();
    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId]); // ✅ Tutte le dependencies dichiarate
    }

</code>

Si possono scrivere delle proprie funzioni per raggruppare pezzi di logica dentro l'Effect. Anche se si dichiarano dentro all'Effect, non sono values reactive, quindi non necessitano di essere dependencies dell'Effect.

### 33.15. Read primitive values from objects

Alle volte, si può ricevere un object dalle prop:

<code>

    function ChatRoom({ options }) {
    	const [message, setMessage] = useState("");

    	useEffect(() => {
    		const connection = createConnection(options);
    		connection.connect();
    		return () => connection.disconnect();
    	}, [options]); // ✅ Tutte le dependencies dichiarate
    }

</code>

Il rischio qui é che il parent Component possa creare l'object durante il rendering:

<code>

    <ChatRoom
    	roomId={roomId}
    	options={{
    		serverUrl: serverUrl,
    		roomId: roomId
    	}}
    />

</code>

Questo potrebbe causare che l'Effect si riconnetta ogni volta che il parent Component si re-renderizza. Per sistemare questo, si leggano le informazioni dall'object fuori dall'Effect, e si eviti di avere objects e functions dependencies:

<code>

    function ChatRoom({ options }) {
    	const [message, setMessage] = useState("");

    	const [roomId, serverUrl] = options;
    	useEffect(() => {
    		const connection = createConnection({
    			serverUrl: serverUrl,
    			roomId: roomId
    		});
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId, serverUrl]); // ✅ Tutte le dependencies dichiarate
    // ...
    }

</code>

La logica diviene un po' ripetitiva, visto che si leggono delle values da un object fuori dall'Effect e poi si crea un object con le stesse values dentro l'Effect nel metodo createConnection. Ma rende molto esplicito da quali informazioni l'Effect dipende effettivamente. Se un object viene ricreato non intenzionalmente dal parent Component, la chat non si riconnetterà. Comunque, se options.roomId o options.serverUrl fossero realmente differenti, la chat allora si riconnetterebbe.

### 33.16. Calculate primitive values from functions

Lo stesso approccio può funzionare per le funzioni. Per esempio, supponiamo che il parent Component passi una funzione:

<code>

    <ChatRoom
    	roomId={roomId}
    		getOptions={() => {
    				return {
    				serverUrl: serverUrl,
    				roomId: roomId
    			};
    		}}
    />

</code>

Per evitare di renderla una dependency (e facendole così causare la riconnessione al re-render), la si chiami fuori dall'Effect. Questo restituisce le values roomId e serverUrl che non sono objects, e che si possono leggere dentro all'Effect:

<code>

    function ChatRoom({ getOptions }) {
    	const [message, setMessage] = useState("");

    	const { roomId, serverUrl } = getOptions();
    	useEffect(() => {
    		const connection = createConnection({
    			serverUrl: serverUrl,
    			roomId: roomId
    		});
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId, serverUrl]); // ✅ Tutte le dependencies dichiarate
    }

</code>

Questo funziona con le funzioni pure perché sono sicure da chiamare durante il rendering. Se la funzione é un Event Handler, ma non si vuole che i suoi cambiamenti risincronizzino l'Effect, lo si avvolga invece in un Effect Event.

### 33.17. Exercises

1-
<code>

    import { useState, useEffect } from 'react';

    export default function Timer() {
    	const [count, setCount] = useState(0);

    	useEffect(() => {
    		console.log('✅ Creating an interval');
    		const id = setInterval(() => {
    			console.log('⏰ Interval tick');
    			setCount(prevCount => {
    				return prevCount + 1
    			});
    		}, 1000);
    		return () => {
    			console.log('❌ Clearing an interval');
    			clearInterval(id);
    		};
    	}, []);

    	return <h1>Counter: {count}</h1>
    }

</code>

✅ Perfetto

2-

<code>

    import { useState, useEffect, useRef } from 'react';
    import { experimental_useEffectEvent as useEffectEvent } from 'react';
    import { FadeInAnimation } from './animation.js';

    function Welcome({ duration }) {
    	const ref = useRef(null);

    	const onStart = useEffectEvent((anim) => {
    		anim.start(duration);
    	})

    	useEffect(() => {
    		const animation = new FadeInAnimation(ref.current);
    		onStart(animation);
    		return () => {
    			animation.stop();
    		};
    	}, []);

    	return (
    		<h1
    			ref={ref}
    			style={{
    				opacity: 0,
    				color: 'white',
    				padding: 50,
    				textAlign: 'center',
    				fontSize: 50,
    				backgroundImage: 'radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%)'
    			}}
    		>
    			Welcome
    		</h1>
    	);
    }

    export default function App() {
    	const [duration, setDuration] = useState(1000);
    	const [show, setShow] = useState(false);

    	return (
    		<>
    			<label>
    				<input
    					type="range"
    					min="100"
    					max="3000"
    					value={duration}
    					onChange={e => setDuration(Number(e.target.value))}
    				/>
    				<br />
    				Fade in duration: {duration} ms
    			</label>
    			<button onClick={() => setShow(!show)}>
    				{show ? 'Remove' : 'Show'}
    			</button>
    			<hr />
    			{show && <Welcome duration={duration} />}
    		</>
    	);
    }

</code>

✅ Perfetto

3- Avviene perché al momento del cambio di theme avviene un re-render da parte di setIsDark, quindi viene inviato un nuovo object options al Component ChatRoom, che perciò riesegue l'Effect e riconnette alla chat. Per sistemare usare la sintassi es6 di scomposizione const {serverUrl, roomId} = options, in modo da passare come dependenies dell'Effect non più l'object ma delle costanti ricavate. Al cambio di theme quindi non verranno più rilevate come un object differente ma al cambio di queste values sì:

<code>

    import { useEffect } from 'react';
    import { createConnection } from './chat.js';

    export default function ChatRoom({ options }) {
    	const { serverUrl, roomId } = options;
    	useEffect(() => {
    		const connection = createConnection({
    			serverUrl: serverUrl,
    			roomId: roomId
    		});
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId, serverUrl]);

    	return <h1>Welcome to the {options.roomId} room!</h1>;
    }

</code>

✅ Perfetto, senza consiglio attivato

4-

<code>

    import { useState, useEffect } from 'react';
    import { experimental_useEffectEvent as useEffectEvent } from 'react';
    import { showNotification } from './notifications.js';
    import {
    	createEncryptedConnection,
    	createUnencryptedConnection,
    } from './chat.js';


    export default function ChatRoom({ isEncrypted, options }) {
    	const {roomId, isDark} = options;
    	const onMessage = useEffectEvent((msg) => {
    		showNotification('New message: ' + msg, isDark ? 'dark' : 'light')
    	})

    	useEffect(() => {
    		function createConnection() {
    					const options = {
    						serverUrl: 'https://localhost:1234',
    						roomId: roomId
    					};
    					if (isEncrypted) {
    						return createEncryptedConnection(options);
    					} else {
    						return createUnencryptedConnection(options);
    					}
    		}
    		const connection = createConnection();
    		connection.on('message', (msg) => onMessage(msg));
    		connection.connect();
    		return () => connection.disconnect();
    	}, [isEncrypted, roomId]);

    	return <h1>Welcome to the {roomId} room!</h1>;
    }

</code>

✅ Quasi perfetto, messo in difficoltà ma risultato molto similare.

## 34. Reusing Logic with Custom Hooks

React é fornito di vari Hooks integrati come useState, useContext e useEffect. A volte si vorrebbe che ci fosse un Hook per qualche scopo specifico: per esempio, per il fetch dei dati, per tenere traccia di se uno user é online, o connettere ad una chat room. Si potrebbe non trovare questi Hook in React, ma si può creare il proprio Hook per le necessità dell'App.

### 34.1. Custom Hooks: Sharing logic between components

Si immagini di sviluppare un App che si relaziona pesantemente con il network, come la maggior parte delle App fa. Si vuole avvisare lo user se la connessione di rete si é accidentalmente spenta mentre si usa l'App. Come si potrebbe fare? Sembra si abbia bisogno di due cose nel Component:

1. Un pezzo di State che tracci che il network é online.

2. Un Effect che sottoscriva agli Events globali online e offline, e aggiorni lo State.

Questo mantiene il Component sincronizzato con lo status della rete. Si potrebbe cominciare con qualcosa come questo:

<code>

    import { useState, useEffect } from "react";

    export default function StatusBar() {
    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		function handleOnline() {
    			setIsOnline(true);
    		}
    		function handleOffline() {
    			setIsOnline(false);
    		}
    		window.addEventListener("online", handleOnline);
    		window.addEventListener("offline", handleOffline);

    		return () => {
    			window.removeEventListener("online", handleOnline);
    			window.removeEventListener("offline", handleOffline);
    		};
    	}, []);

    	return <h1>{isOnline ? "✅ Online" : "❌ Disconnected"}</h1>;
    }

</code>

Si provi a scollegare la rete e si vedrà come questo Component StatusBar si aggiorna in risposta alle azioni.

Ora si immagini di voler anche usare la stessa logica in un Component differente. Si vuole implementare un Save button che diverrà disabilitato e mostrerà "Reconnetting..." invece di "Save" mentre la rete é offline.

Per cominciare, si può copiare ed incollare lo State isOnline e l'Effect in SaveButton:

<code>

    import { useState, useEffect } from "react";

    export default function SaveButton() {
    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		function handleOnline() {
    			setIsOnline(true);
    		}
    		function handleOffline() {
    			setIsOnline(false);
    		}
    		window.addEventListener("online", handleOnline);
    		window.addEventListener("offline", handleOffline);

    		return () => {
    			window.removeEventListener("online", handleOnline);
    			window.removeEventListener("offline", handleOffline);
    		};
    	}, []);

    	function handleSaveClick() {
    		console.log("✅ Progress saved");
    	}

    	return (
    		<button disabled={isOnline} onClick={handleSaveClick}>
    			{isOnline ? "Save progress" : "Reconnetting"}
    		</button>
    	);
    }

</code>

Si verifichi che, se si spegne la connessione di rete, il button cambi aspetto.

Questi due Components funzionano bene, ma la duplicazione della logica tra questi sembra sfortunata. Sembra che anche se hanno una visual appearance differente, si voglia riusare la logica tra questi.

### 34.2. Extracting your own custom Hook from a component

Immaginiamo per un momento che, similarmente a useState e useEffect, vi fosse un Hook integrato useOnlineStatus. Allora entrambi questi Components potrebbero essere semplificati e si potrebbe eliminare la duplicazione tra questi:

<code>

    function StatusBar() {
    	const isOnline = useOnlineStatus();

    	return <h1>{isOnline ? "✅ Online" : "❌ Disconnected"}</h1>;
    }

    function SaveButton() {
    	const isOnline = useOnlineStatus();

    	function handleSaveClick() {
    		console.log("✅ Progress saved");
    	}

    	return (
    		<button disabled={!isOnline} onClick={handleSaveClick}>
    			{isOnline ? "Save progress" : "Reconnecting..."}
    		</button>
    	);
    }

</code>

Anche se non esite tale Hook integrato, si può crearlo da soli.
Si dichiari una funzione chiamata useOnlineStatus e si sposti tutto il codice duplicato dentro a questo dai Components scritti in precedenza:

<code>

    import { useState, useEffect } from "react";

    export function useOnlineStatus() {
    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		function handleOnline() {
    			setIsOnline(true);
    		}
    		function handleOffline() {
    			setIsOnline(false);
    		}
    		window.addEventListener("online", handleOnline);
    		window.addEventListener("offline", handleOffline);

    		return () => {
    			window.removeEventListener("online", handleOnline);
    			window.removeEventListener("offline", handleOffline);
    		};
    	}, []);
    	return isOnline;
    }

</code>

Alla fine della funzione si restituisce isOnline. Questo permette ai Components di leggere tale value:

<code>

useOnlineStatus.jsx

    import { useState, useEffect } from "react";

    export function useOnlineStatus() {
    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		function handleOnline() {
    			setIsOnline(true);
    		}
    		function handleOffline() {
    			setIsOnline(false);
    		}
    		window.addEventListener("online", handleOnline);
    		window.addEventListener("offline", handleOffline);

    		return () => {
    			window.removeEventListener("online", handleOnline);
    			window.removeEventListener("offline", handleOffline);
    		};
    	}, []);
    	return isOnline;
    }

ButtonsContainer.jsx

    import { useOnlineStatus } from "./useOnlineStatus";

    function StatusBar() {
    	const isOnline = useOnlineStatus();

    	return <h1>{isOnline ? "✅ Online" : "❌ Disconnected"}</h1>;
    }

    function SaveButton() {
    	const isOnline = useOnlineStatus();

    	function handleSaveClick() {
    		console.log("✅ Progress saved");
    	}

    	return (
    		<button disabled={!isOnline} onClick={handleSaveClick}>
    			{isOnline ? "Save progress" : "Reconnecting..."}
    		</button>
    	);
    }

    export default function ButtonsContainer() {
    	return (
    		<>
    			<SaveButton />
    			<StatusBar />
    		</>
    	);
    }

</code>

Si verifichi che la rete accesa e spenta aggiorni entrambi i Components ✅.

Ora i Components non hanno molta logica ripetitiva. Cosa più importante, il codice dentro a questi descrive cosa vogliono fare (usare l'online status) piuttosto che come farlo (eseguendo il subscribe ai browser events).

Quando si estrae la logica dentro ai Custom Hooks, si possono nascondere i dettagli nodosi di come ci si interfaccia con dei sistemi esterni o con una browser API. Il codice dei Components esprime i propri intenti, non l'implementazione.

### 34.3. Hook names always start with use

Le Applicazioni React sono costruite dai Components. I Components sono costruiti da Hooks, non importa se integrati o custom. Se si é fortunati si useranno spesso Hooks costruiti da altri, ma occorrerà anche costruirne da soli.

Occorrerà seguire queste convenzioni sui names da utilizzare:

1. **I Components React devono cominciare con una Lettera Maiuscola**, come StatusBar e SavedButton. I Components React hanno inoltre bisogno di restituire qualcosa che React sappia come giostrare, come un pezzo di JSX.

2. **I names degli Hooks devono cominciare con use seguito da una Lettera Maiuscola**, come useState (integrato) o useOnlineStatus (custom, visto in precedenza). Gli Hooks dovrebbero restituire value arbitrarie.

Questa convenzione garatisce che si possa sempre cercare un Component e sapere dov'é il suo State, gli Effects mentre le altre features React possono essere "nascoste". Per esempio, se si vede una chiamata ad una funzione getColor() dentro ad un Component, si può essere sicuri che non contiene dello State React al suo interno perché il suo name non comincia con use. Comunque una chiamata ad una funzione come useOnlineStatus molto probabilmente conterrà chiamate ad altri Hooks al suo interno.

Nota:
Se il linter é configurato per React, forzerà questa convenzione dei names. Se si modificherà useOnlineStatus in getOnlineStatus si noterà che il Linter non permetterà più di chiamare useState o useEffect dentro a questo. Solo gli Hooks ed i Components possono chiamare altri Hooks.

### 34.4. Should all functions called during rendering start with the use prefix?

No. Le funzioni che non chiamano Hooks non necessitano di essere Hooks.

Se la funzione non chiama nessun Hook, si eviti il prefisso use. Invece, la si scriva come una funzione regolare senza il prefisso use. Per esempio, invece di una useSorted che non chiama Hooks, la si chiami invece getSorted:

<code>

    // 🔴 Evitare: Un Hook che non usa Hooks
    function useSorted(items) {
    	return items.slice().sort();
    }

    // ✅ Buono: Una funzione regolare che non usa Hooks
    function getSorted(items) {
    	return items.slice().sort();
    }

</code>

Questo assicura che il codice possa chiamare questa funzione regolare ovunque, incluse le condizioni:

<code>

    function List({ items, shouldSort }) {
    	let dipslyedItems = items;
    	if (shouldSort) {
    		dipslyedItems = getSorted(items);
    	}
    	// ...
    }

</code>

Si dovrebbe dare il prefisso use ad una funzione (e questo la rende un Hook) se usa almeno un Hook al suo interno:

<code>

    // ✅ Buono: Un Hook che usa un altro Hook
    function useAuth() {
    	return useContext(Auth);
    }

</code>

Tecnicamente questo non é forzato da React. In principio, si potevano create degli Hook che non chiamassero altri Hooks. Questo era spesso confusionario e limitante quindi é meglio evitare questo pattern. Comunque, vi sono dei rari casi dove può essere utile. Per esempio, forse una funzione non usa un Hook ora, ma si ha pianificato di aggiungere qualche chiamata a qualche Hook in futuro. Allora ha senso nominarli con il prefisso use:

<code>

    // ✅ Buono: Un Hook che sicuramente userà un altro Hook più avanti
    function useAuth(){

    	// DA FARE: Sostituire questa linea quando l'autenticazione
    	// verrà implementata
    	// return useContext(Auth)

    	return TEST_USER;
    }

</code>

Allora i Components non saranno più capaci di chiamarlo condizionatamente. Questo diverrà importante quando si aggiungeranno effettivamente delle chiamate agli Hooks al suo interno. Se non si sta pianificando di effettuare delle chiamate agli Hooks al suo interno, ora o più tardi, non lo si renda un Hook.

### 34.5. Custom Hooks let you share stateful logic, not state itself

Nell'esempio precedente, quando si accede e si spegne la rete, entrambi i Components si aggiornavano insieme. Comunque, é errato pensare che una singola State variable isOnline venga condivisa tra questi. Si veda questo codice:

<code>

    function StatusBar() {
    	const isOnline = useOnlineStatus();
    	// ...
    }

    function SaveButton() {
    	const isOnline = useOnlineStatus();

    	// ...

    }

</code>

Funziona alla stesso modo rispetto a prima dell'estrazione della duplicazione:

<code>

    function StatusBar() {
    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		// ...
    	}, [])
    }

    function SaveButton() {
    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		// ...
    	}, [])
    }

</code>

Vi sono due State variables completamente indipendenti ed Effects. Potrebbe accadere che questi abbiamo la stessa value allo stesso momento perché sono stati sincronizzati con la stessa value esterna (se la rete é attiva).

Per illustrare meglio questo, abbiamo bisogno di due esempi differenti. Si consideri questo Component Form:

<code>

    import { useState } from "react";

    export default function Form() {
    	const [firstName, setFirstName] = useState("Mary");
    	const [lastName, setLastName] = useState("Poppins");

    	function handleFirstNameChange(event) {
    		setFirstName(event.target.value);
    	}

    	function handleLastNameChange(event) {
    		setLastName(event.target.value);
    	}

    	return (
    		<>
    			<label>
    				First name:
    				<input value={firstName} onChange={handleFirstNameChange} />
    			</label>
    			<label>
    				Last name:
    				<input value={lastName} onChange={handleLastNameChange} />
    			</label>
    			<p>
    				<b>
    					Good morning, {firstName} {lastName}
    				</b>
    			</p>
    		</>
    	);
    }

</code>

Vi é della logica ripetitiva per ogni field del form:

1. Vi é un pezzo di State (firstName e lastName)
2. Vi é un change handler (handleFirstName e handleLastName)
3. Vi é un pezzo di JSX che specifica la value e gli attributes onChange per tale input.

Si può quindi estrarre la logica ripetitiva in questo Custom Hook useFormInput:

<code>

useFormInput.jsx

    	import { useState } from 'react';

    	export function useFormInput(initialValue) {
    		const [value, setValue] = useState(initialValue);

    		function handleChange(e) {
    			setValue(e.target.value);
    		}

    		const inputProps = {
    			value: value,
    			onChange: handleChange
    		};

    		return inputProps;
    	}

App.jsx

    import { useFormInput } from "./useFormInputCustomHooks";

    export default function Form() {
    	const firstNameProps = useFormInput("Mary");
    	const lastNameProps = useFormInput("Poppins");

    	return (
    		<>
    			<label>
    				First name:
    				<input {...firstNameProps} />
    			</label>
    			<label>
    				Last name:
    				<input {...lastNameProps} />
    			</label>
    			<p>
    				<b>
    					Good morning, {firstNameProps.value} {lastNameProps.value}
    				</b>
    			</p>
    		</>
    	);
    }

</code>

Si noti che dichiara solo una State variable chiamata value.

Comunque, il Form Component chiama useFormInput due volte:

<code>

    export default function Form() {
    		const firstNameProps = useFormInput("Mary");
    		const lastNameProps = useFormInput("Poppins");
    		// ...
    }

</code>

Ecco il motivo per il quale funziona come se si stessero dichiarando due State variables.

I Custom Hooks permettono di condividere la Stateful Logic non lo State in se. Ogni chiamata all'Hook é completamente indipendente da ogni altra chiamata allo stesso Hook. Questo é il motivo per il quale i due esempi illustrati sopra sono completamente equivalenti. Il comportamento prima e dopo aver estratto un Custom Hook é identico.

Quando si necessita di condividere lo State in se tra molteplici Components, si usi il Lift Up dello State e lo si passi verso il basso come prop.

### 34.6. Passing reactive values between Hooks

Il codice dentro i Custom Hooks si rieseguirà durante ogni re-render del Component. Ecco perché, come i Components, anche i Custom Hooks hanno bisogno di essere puri. Si pensi al codice dei Custom Hooks come parte del body di un Component.

Proprio perché i Custom Hooks si re-renderizzano con il Component, hanno sempre bisogno di ricevere le ultime Props e State. Per vedere cosa significa, si consideri questo esempio di chat room. Si cambi la URL del server o la chat room:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";
    // import {showNotification} from

    export default function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");

    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};
    		const connection = createConnection(options);
    		connection.on("message", (msg) => {
    			showNotification("New message: " + msg);
    		});
    		connection.connect();
    		return () => connection.disconnect();
    	}, [roomId, serverUrl]);

    	return (
    		<>
    			<label>
    				Server URL:
    				<input
    					value={serverUrl}
    					onChange={(event) => setServerUrl(event.target.value)}
    				/>
    			</label>
    			<h1>Welcome to the {roomId} room!</h1>
    		</>
    	);
    }

</code>

Quando si cambia serverUrl o roomId, l'Effect "reagisce" ai cambiamenti e si risincronizza. Si può capire dalla console che la chat si riconnette ogni volta che si cambiano le dependencies dell'Effect.

Ora, muoviamo il codice dell'Effect in un Custom Hook:

<code>

    export default function useChatRoom({ serverUrl, roomId }) {
    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};
    		const connection = createConnection(options);
    		connection.connect();
    		connection.on("message", (msg) => {
    			showNotification("New message: " + msg);
    		});
    		return () => connection.disconnect();
    	}, [roomId, serverUrl]);
    }

</code>

Questo permette al Component ChatRoom di chiamare il Custom Hook senza preoccuparsi di come funziona internamente:

<code>

    import { useState, useEffect } from "react";
    import { createConnection } from "../chat";
    // import {showNotification} from
    import useChatRoom from "./useChatRoomCustomHooks";

    export default function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");
    	useChatRoom({
    		roomId: roomId,
    		serverUrl: serverUrl
    	})

    	return (
    		<>
    			<label>
    				Server URL:
    				<input
    					value={serverUrl}
    					onChange={(event) => setServerUrl(evnet.target.value)}
    				/>
    			</label>
    			<h1>Welcome to the {roomId} room!</h1>
    		</>
    	);
    }

</code>

Questo sembra molto più semplice, ma fa la stessa cosa.

Si noti che la logica risponde ai cambiamenti di Prop e State. Si provi a cambiare live l'URL del server o la room selezionata:

<code>

useChatRoom.jsx

    import { createConnection } from "../chat";
    // import {showNotification} from
    import { useEffect } from "react";

    export default function useChatRoom({ serverUrl, roomId }) {
    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};
    		const connection = createConnection(options);
    		connection.connect();
    		connection.on("message", (msg) => {
    			showNotification("New message: " + msg);
    		});
    		return () => connection.disconnect();
    	}, [roomId, serverUrl]);
    }

ChatRoom.jsx

    import { useState } from "react";
    import useChatRoom from "./useChatRoomCustomHooks";

    export default function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");
    	useChatRoom({
    		roomId: roomId,
    		serverUrl: serverUrl
    	});

    	return (
    		<>
    			<label>
    				Server URL:
    				<input
    					value={serverUrl}
    					onChange={(event) => setServerUrl(evnet.target.value)}
    				/>
    			</label>
    			<h1>Welcome to the {roomId} room!</h1>
    		</>
    	);
    }

</code>

Si noti che si sta prendendo la value restituita da un Hook:

<code>

    const [serverUrl, setServerUrl] = useState("https://localhost:1234"); // <---

</code>

e la si passa come input in un altro Hook:

<code>

    useChatRoom({
    		roomId: roomId,
    		serverUrl: serverUrl // <---
    });

</code>

Ogni volta che il Component ChatRoom si re-renderizza, passa l'ultima roomId e serverUrl all'Hook. Questo é il motivo per il quale l'Effect si riconnette alla chat se le loro values sono differenti dopo un re-render.

### 34.7. Passing event handlers to custom Hooks

Nota: Questa sezione descrive un API sperimentale non ancora distribuita in una versione stabile di React.

Visto che si comincia ad usare useChatRoom in più Components, si potrebbe voler poter personalizzare il suo comportamento. Per esempio, al momento, la logica per casa fare quando un message arriva é hardcoded dentro all'Hook:

<code>

    import { createConnection } from "../chat";
    // import {showNotification} from
    import { useEffect } from "react";

    export default function useChatRoom({ serverUrl, roomId }) {
    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};
    		const connection = createConnection(options);
    		connection.connect();
    		// --->
    		connection.on("message", (msg) => {
    			showNotification("New message: " + msg);
    		});
    		// <---
    		return () => connection.disconnect();
    	}, [roomId, serverUrl]);
    }

</code>

Diciamo di voler far tornare questa logica al Component:

<code>

    export default function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");

    	useChatRoom({
    		roomId: roomId,
    		serverUrl: serverUrl,
    		onReceiveMessage(msg) {
    			showNotification("New message: " + msg);
    		}
    	});
    	// ...
    	}

</code>

Per far funzionare questo, si cambi il Custom Hook per poter prendere onReceiveMessage come una delle sue named options:

<code>

    import { createConnection } from "../chat";
    import { useEffect } from "react";

    export default function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};
    		const connection = createConnection(options);
    		connection.connect();
    		connection.on("message", (msg) => {
    			// --->
    			onReceiveMessage(msg);
    			// <---
    		});
    		return () => connection.disconnect();
    	}, [roomId, serverUrl, onReceiveMessage]);
    	// ✅ Tutte le dependencies dichiarate
    }

</code>

Questo funzionerà, ma vi é un altro ulteriore miglioramento che si può fare quando un Custom Hook accetta gli Event Handlers.

Aggiungendo una dependency onReceiveMessage non é l'ideale perché causerà la riconnessione della chat ogni volta che il Component si re-renderizzerà. Si avvolga questo Event Handler in un Effect Event per rimuoverlo dalla dependencies:

<code>

    import { createConnection } from "../chat";
    import { useEffect } from "react";

    export default function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {

    	// --->
    	const onMessage = useEffectEvent(onReceiveMessage);
    	// <---

    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};
    		const connection = createConnection(options);
    		connection.connect();

    		connection.on("message", (msg) => {
    			// --->
    			onMessage(msg);
    			// <---
    		});

    		return () => connection.disconnect();
    	}, [roomId, serverUrl]);
    	// ✅ Tutte le dependencies dichiarate
    }

</code>

Ora la chat non si riconnetterà ogni volta che il ChatRoom Component viene re-renderizzato. Ecco la demo completa funzionante del passaggio di un Event ad un Custom Hook:

<code>

ChatRoom.jsx

    import { useState } from "react";
    import useChatRoom from "./useChatRoomCustomHooks";
    // import {showNotification} from

    export default function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");

    	useChatRoom({
    		roomId: roomId,
    		serverUrl: serverUrl,
    		onReceiveMessage(msg) {
    			showNotification("New message: " + msg);
    		}
    	});

    	return (
    		<>
    			<label>
    				Server URL:
    				<input
    					value={serverUrl}
    					onChange={(event) => setServerUrl(evnet.target.value)}
    				/>
    			</label>
    			<h1>Welcome to the {roomId} room!</h1>
    		</>
    	);
    }

useChatRoom.jsx

    import { createConnection } from "../chat";
    import { useEffect } from "react";

    export default function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
    	const onMessage = useEffectEvent(onReceiveMessage);

    	useEffect(() => {
    		const options = {
    			serverUrl: serverUrl,
    			roomId: roomId
    		};
    		const connection = createConnection(options);
    		connection.connect();

    		connection.on("message", (msg) => {
    			onMessage(msg);
    		});

    		return () => connection.disconnect();
    	}, [roomId, serverUrl]);
    }

</code>

Si noti come non vi é più la necessità di sapere come useChatRoom funzioni per poter usarlo. Si può aggiungerlo ad ogni altro Component, passare qualsiasi altra option, e funzionerà allo stesso modo. Questo é il potere dei Custom Hooks.

### 34.8. When to use custom Hooks

Non occorre estrarre un Custom Hook per ogni piccolo bit duplicato del codice. Un po' di duplicazione va bene. Per esempio, estrarre un Hook useFormInput per avvolgere una singola chiamata a useState come fatto precedentemente é probabilmente non necessario.

Comunque, se si scrive un Effect, si consideri se potrebbe essere più chiaro scriverlo in un Custom Hook. Non si necessita degli Effects molto spesso, quindi se ne stiamo scrivendo uno, significa che si necessita di "fare un passo fuori da React" per sincronizzare con qualche sistema esterno o per fare qualcosa per il quale React non ha API integrata. Avvolgerlo in un Custom Hook permette di comunicare più precisamente l'intento e come il data flow passa tra questo.

Per esempio, si consideri un Component ShippingForm che mostra due dropdown: uno mostra la lista di cities e l'altro mostra la lista di aree nella città selezionata. Si potrebbe cominciare con del codice che si mostra come questo:

<code>

    import { useState, useEffect } from "react";

    function ShippingForm({ country }) {
    	const [cities, setCities] = useState(null);
    	// Questo Effect esegue il fetch per una country
    	useEffect(() => {
    		let ignore = false;
    		fetch(`/api/cities?country=${country}`)
    			.then((response) => response.json)
    			.then((json) => {
    				if (!ignore) {
    					setCities(json);
    				}
    			});
    		return () => {
    			ignore = true;
    		};
    	}, [country]);

    	const [city, setCity] = useState(null);
    	const [areas, setAreas] = useState(null);
    	// Questo Effect esegue il fetch per la city selezionata
    	useEffect(() => {
    		let ignore = false;
    		fetch(`/api/areas?city=${city}`)
    			.then((response) => response.json())
    			.then((json) => {
    				if (!ignore) {
    					setAreas(json);
    				}
    			});
    		return () => {
    			ignore = true;
    		};
    	}, [city]);

    	// ...
    }

</code>

Sebbene questo codice sia abbastanza ripetitivo, é corretto mantenere questi Effects separati tra loro. Questo sincronizzano due cose differenti, quindi non si dovrebbe fonderli insieme in un singolo Effect. Invece, si può semplificare il Component ShippingForm mostrato sopra estraendo la logica comune tra loro in un Hook useData:

<code>

    import { useState, useEffect } from "react";

    function useData(url) {
    	const [data, setData] = useState(null);

    	useEffect(() => {
    		if (url) {
    			let ignore = false;
    			fetch(url)
    				.then((response) => response.json())
    				.then((json) => {
    					if (!ignore) {
    						setData(json);
    					}
    				});
    			return () => {
    				ignore = true;
    			};
    		}
    	}, [url]);
    	return data;
    }

</code>

Ora si può sostituire entrmbi gli Effects nel Component ShippingForm con delle chiamate a useData:

<code>

    import { useState } from "react";
    import { useData } from "./useData";

    function ShippingForm({ country }) {
    	const cities = useData(`/api/cities?country=${country}`);
    	const [city, setCity] = useState(null);
    	const areas = useData(city ? `/api/areas?city=${city}` : null);
    	// ...
    }

</code>

Estrarre un Custon Hook rende il data flow esplicito. Si inserisce l'url e si ottiene data come output. "Nascondendo" l'Effect dentro a useData, si previene inoltre che qualcuno che lavorerà al Component ShippingForm aggiunga delle dependencies non necessarie a questo. Con il tempo, la maggior parte degli Effects nell'App saranno nei Custom Hooks.

### 34.9. Keep your custom Hook focused on concrete high-level use cases - Deep Dive

Si cominci scegliendo il name del Custom Hook. Se si é in difficoltà nel scegliere un name chiaro, potrebbe significare che l'Effect é troppo accoppiato con il resto della logica del Component, e non é ancora pronto per essere estratto.

Idealmente, il name del Custom Hook dovrebbe essere chiaro abbastanza che persino una persona che non scrive codice spesso possa indovinare cosa fa l'Hook, cosa prende e cosa restituisce:

• ✅ useData(url)
• ✅ useImpressionLog(eventName, extraData)
• ✅ useChatRoom(options)

Quando si sincronizza con un sistema esterno, il name del Custom Hook potrebbe essere più tecnico e usare un gergo specifico di quel sistema. Va bene che sia lungo abbastanza da essere chiaro ad una persona familiare con tale sistema:

• ✅ useMediaQuery(query)
• ✅ useSocket(url)
• ✅ useIntersectionObserver(ref, options)

Si tengano i Custom Hooks concentrati su degli use cases di alto livello. Si eviti di creare e usare Custom Hooks "sul ciclo di vita" che agiscono come alternative e wrapper di convenienza per l'API useEffect stessa:

• 🔴 useMount(fn)
• 🔴 useEffectOnce(fn)
• 🔴 useUpdateEffect(fn)

Per esempio, questo Hook useMount prova ad assicurarsi che del codice si esegua solo al momento in cui un Component "viene montato":

<code>

    function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState('https://localhost:1234');

    	// 🔴 Evitare: uso dei Custom Hooks "sul ciclo di vita"

    	useMount(() => {
    		const connection = createConnection({ roomId, serverUrl });
    		connection.connect();

    		post('/analytics/event', { eventName: 'visit_chat' });
    	});
    	// ...
    }

    // 🔴 Evitare: creazione di Custom Hooks "sul ciclo di vita"
    function useMount(fn) {
    	useEffect(() => {
    		fn();
    	}, []); // 🔴 useEffect manca di una dependency "fn"
    }

</code>

I Custom Hooks "sul ciclo di vita" come useMount non entrano bene nel paradigma di React. Per esempio, questo codice ha un errore (non "reagisce" ai cambiamenti di roomId o serverUrl), ma il linter non avvisa su questo perché il linter controlla solo le chiamate dirette a useEffect. Non sa nulla riguardo il nostro Hook.

Se si sta scrivendo un Effect, si cominci usando l'API React direttamente:

<code>

    import { useEffect, useState } from "react";

    function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");

    	useEffect(() => {
    		const connection = createConnection({ serverUrl, roomId });
    		connection.connect();
    		return () => connection.disconnect();
    	}, [serverUrl, roomId]);

    	useEffect(() => {
    		post("/analytics/event", { eventName: "visit_chat", roomId });
    	}, [roomId]);

    	// ...
    }

</code>

Poi si può, ma non si deve per forza, estrarre un Custom Hook per diversi casi di alto livello:

<code>

    import { useEffect, useState } from "react";

    function ChatRoom({ roomId }) {
    	const [serverUrl, setServerUrl] = useState("https://localhost:1234");

    	// ✅ Ottimo: Custom Hooks con names adatti al loro scopo

    	useChatRoom({ serverUrl, roomId });
    	useImpressionLog("visit_chat", { roomId });

    	// ...
    }

</code>

Un buon Custom Hook rende il codice della chiamata più declerative vincolandosi a ciò che fa. Per esempio, useChatRoom(options) può connettersi solamente alla chat room, mentre useImpressionLog(eventName, extraData) può solamente mandare degli impression log all'analytics. Se il Custom Hook API non si lega a degli use cases ed é molto astratto, nel lungo periodo potrebbe introdurre più problemi rispetto a quelli che risolverebbe.

### 34.10. Custom Hooks help you migrate to better patterns

Gli Effects sono delle "vie di fuga": si usano quando si necessita di "fare un passo fuori da React" e quando non vi é una migliore soluzione integrata per il proprio use case. Con il tempo, l'obiettivo del team di React é ridurre il numero di Effects nell'App al minimo fornendo soluzioni più specifiche per specifici problemi. Avvolgendo gli Effects in dei Custom Hooks renderà più facile aggiornare il codice quando queste soluzioni saranno disponibili.

Ritorniamo a questo esempio:

<code>

    import { useState, useEffect } from "react";

    export function useOnlineStatus() {
    	const [isOnline, setIsOnline] = useState(true);
    	useEffect(() => {
    		function handleOnline() {
    			setIsOnline(true);
    		}
    		function handleOffline() {
    			setIsOnline(false);
    		}
    		window.addEventListener("online", handleOnline);
    		window.addEventListener("offline", handleOffline);

    		return () => {
    			window.removeEventListener("online", handleOnline);
    			window.removeEventListener("offline", handleOffline);
    		};
    	}, []);
    	return isOnline;
    }

</code>

Qui, useOnlineStatus viene implementato con una coppia di useState e useEffect. Comunque, non é la migliore soluzione possibile. Vi sono innumerevoli casi limite che non considera. Per esempio, assume che quando il Component viene montato, isOnline sia già true, ma questo potrebbe essere errato se la rete si é già scollegata. Si può usare l'API navigator.online per controllarlo, ma usarlo direttamente non funzionerà sul server per generare l'HTML iniziale. In breve, questo codice può essere migliorato.

Fortunatamente, React 18 introduce un'API dedicata chiamata useSyncExternalStore che si prende cura di questi problemi. Ecco l'esempio dell'Hook useOnlineStatus riscritto prendendo le migliorie di questa nuova API:

<code>

useOnlineStatus.jsx:

    import { useSyncExternalStore } from "react";

    function subscribe(callback) {
    	window.addEventListener("online", callback);
    	window.addEventListener("offline", callback);
    	return () => {
    		window.removeEventListener("online", callback);
    		window.removeEventListener("offline", callback);
    	};
    }

    export function useOnlineStatus() {
    	return useSyncExternalStore(
    		subscribe,
    		() => navigator.onLine, // come ottenere la value sul client
    		() => true // come ottenere la value sul server
    	);
    }

StatusBar&SavedButton.jsx

    import { useOnlineStatus } from "./useOnlineStatus";

    function StatusBar() {
    	const isOnline = useOnlineStatus();

    	return <h1>{isOnline ? "✅ Online" : "❌ Disconnected"}</h1>;
    }

    function SaveButton() {
    	const isOnline = useOnlineStatus();

    	function handleSaveClick() {
    		console.log("✅ Progress saved");
    	}

    	return (
    		<button disabled={!isOnline} onClick={handleSaveClick}>
    			{isOnline ? "Save progress" : "Reconnecting..."}
    		</button>
    	);
    }

    export default function ButtonsContainer() {
    	return (
    		<>
    			<SaveButton />
    			<StatusBar />
    		</>
    	);
    }

</code>

Si noti come non si necessita di cambiare nessun Component per effettuare questa migrazione:

<code>

function StatusBar() {
const isOnline = useOnlineStatus();
// ...
}

function SaveButton() {
const isOnline = useOnlineStatus();
// ...
}

</code>

Queste sono altre ragioni per le quali avvolgere gli Effects nei Custom Hooks é spesso benefico:

1. Si rende il data flow da e per gli Effects molto esplicito.

2. Permette ai Components di concentrarsi sull'intento piuttosto che sull'esatta implementazione degli Effects.

3. Quando React aggiunge delle nuove features, si possono rimuovere tali Effects senza cambiare nessun Component.

Similarmente ad un design system, si potrebbe trovare utile cominciare ad estrarre degli idiomi comuni dai Components dell'App in dei Custom Hooks. Questo manterrà il codice dei Components concentrato sull'intento e permetterà di evitate di scrivere spesso Effects grezzi. Molti Custom Hooks eccellenti sono mantenuti dalla community di React.

### 34.11. Will React provide any built-in solution for data fetching? - Deep Dive

Si sta ancora lavorando ai dettagli, ma ci aspettiamo che in futuro, si scriverà il data fetching in questo modo:

<code>

    import { use } from "react";

    function ShippingForm({country}){

    	const cities = use (fetch(`/api/cities?country=${country}`));
    	const [city, setCities] = useState(null);
    	const areas = city ? use(fetch(`/api/areas?city=${city}`) : null);
    	// ...

    }

</code>

Se si usa un Custom Hook come useData mostrato sopra, richiederà pochi cambiamenti migrare ad un approccio raccomandato eventualmente, rispetto che scrivere un Effect grezzo in ogni Component manualmente. Comunque, il vecchio approccio funziona ancora bene.

### 34.12. There is more than one way to do it

Diciamo di voler implementare un'animazione fade-in da zero usando l'API del browser requestAnimationFrame. Si potrebbe cominciare con un Effect che imposta un loop di un'animazione. Durante ogni frame dell'animazione, si può cambiare l'opacità del DOM node che si ospita in una ref fino a che non raggiunge la value di 1. Si potrebbe comiciare così:

<code>

    import { useState, useEffect, useRef } from "react";

    function Welcome() {
    	const ref = useRef(null);

    	useEffect(() => {
    		const duration = 1000;
    		const node = ref.current;

    		let startTime = performance.now();
    		let frameId = null;

    		function onFrame(now) {
    			const timePassed = now - startTime;
    			const progress = Math.min(timePassed / duration, 1);
    			onProgress(progress);
    			if (progress < 1) {
    				// abbiamo ancora dei frame da inserire
    				frameId = requestAnimationFrame(onFrame);
    			}
    		}

    		function onProgress(progress) {
    			node.style.opacity = progress;
    		}

    		function start() {
    			onProgress(0);
    			startTime = performance.now();
    			frameId = requestAnimationFrame(onFrame);
    		}

    		function stop() {
    			cancelAnimationFrame(frameId);
    			startTime = null;
    			frameId = null;
    		}

    		start();
    		return () => stop();
    	}, []);

    	return (
    		<h1 className="welcome" ref={ref}>
    			Welcome
    		</h1>
    	);
    }

    export default function WelcomeContainer() {
    	const [show, setShow] = useState(false);
    	return (
    		<>
    			<button onClick={() => setShow(!show)}>{show ? "Remove" : "SHow"}</button>
    			<hr />
    			{show && <Welcome />}
    		</>
    	);
    }

</code>

Per rendere il Component più leggibile, si potrebbe estrarre la logica in un Custom Hook useFadeIn:

<code>

    import { useEffect } from "react";

    export function useFadeIn(ref, duration) {
    	useEffect(() => {
    		const node = ref.current;

    		let startTime = performance.now();
    		let frameId = null;

    		function onFrame(now) {
    			const timePassed = now - startTime;
    			const progress = Math.min(timePassed / duration, 1);
    			onprogress(progress);
    			if (progress < 1) {
    				frameId = requestAnimationFrame(onFrame);
    			}
    		}

    		function onProgress(progress) {
    			node.style.opacity = progress;
    		}

    		function start() {
    			onProgress(0);
    			startTime = performance.now();
    			frameId = requestAnimationFrame(onFrame);
    		}

    		function stop() {
    			cancelAnimationFrame(frameId);
    			startTime = null;
    			frameId = null;
    		}

    		start();
    		return () => stop();
    	}, [ref, duration]);
    }

</code>

Si può mantenere il codice di useFadeIn così com'é, ma si può anche rifattorizzarlo ulteriormente. Per esempio, si può estrarre la logica per impostare il loop dell'animazione fuori da useFadeIn in un Custom Hook useAnimationLoop:

<code>

    import { useState, useEffect } from "react";
    import { experimental_useEffectEvent as useEffectEvent } from "react";

    export function useFadeIn(ref, duration) {
    	const [isRunning, setIsRunning] = useState(true);

    	useAnimationLoop(isRunning, (timePassed) => {
    		const progress = Math.min(timePassed / duration, 1);
    		ref.current.style.opacity = progress;
    		if (progress === 1) {
    			setIsRunning(false);
    		}
    	});
    }

    function useAnimationLoop(isRunning, drawFrame) {
    	const onFrame = useEffectEvent(drawFrame);

    	useEffect(() => {
    		if (!isRunning) {
    			return;
    		}

    		let startTime = performance.now();
    		let frameId = null;

    		function tick(now) {
    			const timePassed = now - startTime;
    			onFrame(timePassed);
    			frameId = requestAnimationFrame(tick);
    		}

    		tick();
    		return () => cancelAnimationFrame(frameId);
    	}, [isRunning]);
    }

</code>

Comunque, non si deve farlo per forza. Come per le regular functions, alla fine siamo noi a decidere dove disegnare i confini tra le differenti parti del codice. Si può anche prendere un approccio molto differente. Invece di mantenere la logica nell'Effect, si può muovere la maggior parte della logica imperativa dentro ad una class JavaScript:

<code>
animation.js

    export class FadeAnimation {
    	constructor(node) {
    		this.node = node;
    	}

    	start(duration) {
    		this.duration = duration;
    		this.onProgress(0);
    		this.startTime = performance.now();
    		this.frameId = requestAnimationFrame(() => this.onFrame());
    	}

    	onFrame() {
    		const timePassed = performance.now() - this.startTime;
    		const progress = Math.min(timePassed / this.duration, 1);
    		this.onProgress(progress);
    		if (progress === 1) {
    			this.stop();
    		} else {
    			// abbiamo ancora frame da creare
    			this.frameId = requestAnimationFrame(() => this.onFrame());
    		}
    	}

    	onProgress(progress) {
    		this.node.style.opacity = progress;
    	}
    	stop() {
    		cancelAnimationFrame(this.frameId);
    		this.startTime = null;
    		this.frameId = null;
    		this.duration = 0;
    	}
    }

useFadeIn.jsx

    import { useEffect } from "react";
    import { FadeAnimation } from "./animation";

    export function useFadeIn(ref, duration) {
    	useEffect(() => {
    		const animation = new FadeAnimation(ref.current);
    		animation.start(duration);
    		return () => {
    			animation.stop();
    		};
    	}, [ref, duration]);
    }

</code>

Gli Effects ti permettono di connettere React a dei sistemi esterni. Più si necessita di coordinamento tra gli Effects (per esempio per concatenare animazioni multiple), più ha senso estrarre tale logica completamente fuori dagli Effects e dagli Hooks. Poi, il codice che si ha estratto diviene "il sistema esterno". Questo permette agli Effect di restare semplici visto che necessitano solamente di mandare dei messages al sistema che si é mosso fuori da React.

Gli esempi sopra mostrati assumono che la logica del fade-in sia necessariamente scritta in JavaScript. Comunque, questa particolare animazione é sia più semplice che più efficente da implementare con una CSS animation plain:

<code>

    .welcome {
    	color: white;
    	padding: 50px;
    	text-align: center;
    	font-size: 50px;
    	background-image: radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%);

    	animation: fadeIn 1000ms;
    }

    @keyframes fadeIn {
    	0% { opacity: 0; }
    	100% { opacity: 1; }
    }

</code>

Alle volte, non si necessita nemmeno di un Hook.

### 34.13. Exercises

1-

<code>
useCounter.jsx

    import {useState, useEffect} from "react";

    export function useCounter(){
    	const [count, setCount] = useState(0);

    	useEffect(() => {
    		const id = setInterval(() => {
    			setCount(c => c + 1);
    		}, 1000);
    		return () => clearInterval(id);
    	}, [])
    	return count;
    }

App.jsx

    import { useCounter } from "./useCounter"

    export default function Counter() {
    	const count = useCounter();
    	return <h1>Seconds passed: {count}</h1>;
    }

</code>

✅ Perfetto

2-

<code>

App.jsx

    export default function Counter() {
    	const [delay, setDelay] = useState(1000);
    	const count = useCounter(delay);
    	return (
    		<>
    			<label>
    				Tick duration: {delay} ms
    				<br />
    				<input
    					type="range"
    					value={delay}
    					min="10"
    					max="2000"
    					onChange={e => setDelay(Number(e.target.value))}
    				/>
    			</label>
    			<hr />
    			<h1>Ticks: {count}</h1>
    		</>
    	);
    }

useCounter.jsx

    export function useCounter(delay) {
    	const [count, setCount] = useState(0);
    	useEffect(() => {
    		const id = setInterval(() => {
    			setCount(c => c + 1);
    		}, delay);
    		return () => clearInterval(id);
    	}, [delay]);
    	return count;
    }

</code>

✅ Perfetto

3-

<code>

useCounter.jsx

    import { useState, useEffect } from 'react';
    import { useInterval } from "./useInterval";

    export function useCounter(delay) {
    	const [count, setCount] = useState(0);
    	useInterval(() => {
    		setCount(c => c + 1)
    	}, delay)
    	return count;
    }

useInterval.jsx

    import { useEffect } from "react";

    export function useInterval(onTick, delay){
    	useEffect(() => {
    		const id = setInterval(onTick, delay);
    		return () => clearInterval(id);
    	}, [onTick, delay]);
    	return onTick; // Non serve restituire onTick
    }

</code>

✅ Quasi Perfetto, solo aggiunto in più return onTick

4-

Non si aggiorna perché ad ogni chiamata della funzione, avviene un rerender. Quando onTick viene chiamato é una funzione diversa dal punto di vista dell'Effect, quindi avviene sempre un clearInterval ad ogni secondo. Questo non permette all'useInterval in App.jsx di eseguirsi. Utilizzando un EffectEvent con argument onTick si dirà all'Effect che questa value é sempre la stessa, non subisce variazioni, perciò la si può eliminare dal dependecies array:

<code>

    import { useEffect } from 'react';
    import { experimental_useEffectEvent as useEffectEvent } from 'react';

    export function useInterval(onTick, delay) {

    	const tick = useEffectEvent(onTick);

    	useEffect(() => {
    		const id = setInterval(tick, delay);
    		return () => {
    			clearInterval(id);
    		};
    	}, [delay]);
    }

</code>

✅ Perfetto, spiegazione ed esecuzione

5-

<code>

    import {useState, useEffect} from "react";
    import { usePointerPosition } from './usePointerPosition.js';

    function useDelayedValue(value, delay) {
    	const [delayedValue, setDelayedValue] = useState(value);
    	useEffect(() => {
    		const id = setTimeout(() => {  // non serve id
    			setDelayedValue(value);
    		}, delay);
    	}, [value, delay])
    	return delayedValue;
    }

    export default function Canvas() {
    	const pos1 = usePointerPosition();
    	const pos2 = useDelayedValue(pos1, 100);
    	const pos3 = useDelayedValue(pos2, 200);
    	const pos4 = useDelayedValue(pos3, 100);
    	const pos5 = useDelayedValue(pos3, 50);
    	return (
    		<>
    			<Dot position={pos1} opacity={1} />
    			<Dot position={pos2} opacity={0.8} />
    			<Dot position={pos3} opacity={0.6} />
    			<Dot position={pos4} opacity={0.4} />
    			<Dot position={pos5} opacity={0.2} />
    		</>
    	);
    }

    function Dot({ position, opacity }) {
    	return (
    		<div style={{
    			position: 'absolute',
    			backgroundColor: 'pink',
    			borderRadius: '50%',
    			opacity,
    			transform: `translate(${position.x}px, ${position.y}px)`,
    			pointerEvents: 'none',
    			left: -20,
    			top: -20,
    			width: 40,
    			height: 40,
    		}} />
    	);
    }

</code>

Risposta necessità cleanup: no, altrimenti verrebbe bloccato lo scorrere dei cerchi successivi al primo, azzerando il timeout e quindi la delayedValue.

✅ Quasi Perfetto. Piccolo dettaglio: salvare id non serve.
✅ Perfetta spiegazione.

# Ottava parte - Projects - Recipe App

## 1. Intro

Questo progetto illusterà la crezione di un sito di ricette.
Si baserà sui dati proveninti da Edamam.

Iniziamo con il setup iniziale:

<code>

    import { useState } from "react";

    function App() {
    	const [count, setCount] = useState(0);

    	const APP_ID = "e138bbcb";
    	const APP_KEY = "0a8efd0ec4c9cce24d50abc6dc70f261";
    	const exampleReq = `https://api.edamam.com/search?q=chicken&app_id=${APP_ID}&app_key=${APP_KEY}`;

    	return (
    		<>
    			<div className="App">
    				<form className="search-form">
    					<input className="search-bar" type="text" />
    					<button className="search-button" type="submit">
    						Search
    					</button>
    				</form>
    			</div>
    		</>
    	);
    }

    export default App;

</code>

## 2. Sviluppo

Spiegazione useRef - vedi documentazione.

Separazione autonoma Components.

Introduzione useEffect.

Creata alternatica a semplice useEffect, useData Custom Hook.

Completato il tutorial lato React, con codice:

<code>

INSERIRE CODICE

</code>

Ora passiamo alla creazione di un CSS module.
Creiamo un file recipe.module.css.
Scriviamo una class recipe che useremo nel Component Recipe.jsx.
Nel Component importiamo il module come:

<code>

    import style from "./recipe.module.css";

</code>

Per usare la class scritta nel module:

<code>

    export default function Recipe({ title, calories, image, ingredients }) {
    	return (
    		<>
    			<div className={style.recipe}> // <--- usare style.recipe
    				<h1>{title}</h1>
    				<ol>
    					{ingredients.map((ingredient, index) => (
    						<li key={`${ingredient.food}_index_${index}`}>{ingredient.text}</li>
    					))}
    				</ol>
    				<p>{calories}</p>
    				<img className={style.image} src={image} alt={title} />
    				// <--- usare style.image
    			</div>
    		</>
    	);
    }

</code>

Per usare le classes dischiarate nel module, usiamo className={} con all'interno style.nameOfTheClass.

# Nona parte - Styling

## 1. Modules:

Esempio di CSS module.
Partiamo da un Component:

<code>

    import React from "react";

    const Navigation = ({ links }) => {
    	return (
    		<div>
    			<ul>
    				{links.map((link) => {
    					<li key={link.to}>
    						<a href={link.to}>{link.label}</a>
    					</li>;
    				})}
    			</ul>
    		</div>
    	);
    };

    export default Navigation;

</code>

Ora creiamo un file Navigation.module.css con delle classes CSS scritte al suo interno:

<code>

    .navigation {
    	background-color: #222;
    }

    .navigation-list {
    	list-style: none;
    	margin: 0;
    	padding: 0;

    	display: flex;
    	justify-content: center;
    }

    .navigation-list-item {
    	margin: 10px 20px;
    }

    .navigation-list-item-anchor {
    	text-decoration: none;
    	color: #ffffff;
    }

    .navigation-list-item-anchor:visited {
    	color: #ffffff;
    }

    .navigation-list-item-anchor:hover {
    	color: #525dce;
    }

</code>

Ora si importi il module con l'import Statement nel Component Navigation:

<code>
	import styles from "./Navigation.module.css";
</code>

Si aggiungano ora le property className ai vari elements del Component Navigation:

<code>

    const Navigation = ({ links }) => {
    	const ref = useRef(null);
    	console.log(ref.current);
    	return (
    		<div ref={ref} className={styles["navigation"]}>
    			<ul className={styles["navigation-list"]}>
    				{links.map((link) => {
    					return (
    						<li key={link.to} className={styles["navigation-list-item"]}>
    							<a
    								href={link.to}
    								className={styles["navigation-list-item-anchor"]}
    							>
    								{link.label}
    							</a>
    						</li>
    					);
    				})}
    			</ul>
    		</div>
    	);
    };

    export default Navigation;

</code>

## 2. Inline CSS

Esempio di Inline CSS:

<code>

    const divStyle = {
    	color: 'blue',
    	backgroundImage: 'url(' + imgUrl + ')',
    };
    function HelloWorldComponent() {
    	return <div style={divStyle}>Hello World!</div>;
    	// ...
    }

</code>

## 3. Styled Components

Esempio di Styled Component. Questo usa il Tagged Template Literal:

<code>

Button.jsx:

    import styled from "styled-components";

    export const Button = styled.button`
    	fonst-size: 1em;
    	margin: 1em;
    	padding: 0.25em 1em;
    	border: 2px solid palevioletred;
    	border-radius: 3px;

    	backgrounf: ${(props) => props.primary && "palevioletred"};
    	color: ${(props) => (props.primary ? "white" : "palevioletred")};
    `;

App.jsx:

    	import { Button } from "./Button";

    export default function App(){
    	return (
    		<Button primary>Github</Button>
    		<Button>Try it out</Button>
    	)
    }

</code>

## 4. Stylable

## 5. CSS in JS

I Styled Components sono una parte del CSS in JS.
